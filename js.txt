/*!
 * Â© 2022 Exacq Technologies. All Rights Reserved
 */
/*globals s2:false,ev_URL:false,wireUpS2Customizations:false*/
(function() {
    // Load S2 Customizations
    if (window.loadCamera && typeof s2 === 'undefined') {
        var script = document.createElement("script");
        script.setAttribute("src", ev_URL + "s2.js");
        script.setAttribute("type", "text/javascript");

        var callbackPerformed = false;

        var onLoadFunction = function() {
            var state = script.readyState;

            if (!callbackPerformed && (!state || /loaded|complete/.test(state))) {
                callbackPerformed = true;
                wireUpS2Customizations();
            }
        };

        //Once the script has loaded, call the wire up function
        script.onreadystatechange = onLoadFunction;
        script.onload = onLoadFunction;

        document.body.appendChild(script);
    }
}());
/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * The root global object for this API.
     * @type Object
     */
    window.EVWEB2 = {};

    /**
     * Advanced configuration options.  These should not be modified.
     * @type {Object}
     */
    EVWEB2.config = {
        /**
         * The default stream ID to be used when requesting video.
         * @type String
         */
        defaultStreamId: null,
        /**
         * Interval for polling a trigger on, in milliseconds.
         * @type Number
         */
        triggerPollingRate: 1000,
        /**
         * Timeout specified for JSONP requests before issuing an error response.
         * @type Number
         */
        jsonpRequestTimeout: 5000
    };

    /**
     * Internal Use Only. The base error strings returned from the web service.
     * @ignore
     * @type Object
     */
    EVWEB2.errors = {
        config: "invalid session",
        servers: "{\n\tERROR\n}",
        login: '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\">' +
            '\n<html>\n<head>\n<title>Config</title>\n</head>\n<body>\n<h1>Error</h1>\n</body>\n</html>',
        triggers: "{\n\tERROR\n}",
        ptz: "{\n\tERROR\n}",
        search: "{\n\tERROR\n}",
        jsonLoginFailed: 'Login failed'
    };

    /**
     * Forward declaration of EVWEB2.ajax alias of {@link EVWEB2.util.internal.ajax}, defined for
     * convenience.  The actual assignment of this alias is performed with the definition of the
     * actual implementation.
     * @ignore
     * @type Function
     */
    EVWEB2.ajax = undefined;


    /**
     * Internal Use Only. The URL endpoints for the various web service calls.
     * @ignore
     * @type Object
     */
    EVWEB2.urls = {
        getServerList: 'login.web?output=json',
        getCameraList: 'config.web',
        getViewList: 'view.web',
        login: 'login.web',
        logout: 'logout.web',
        legacyGetFrame: 'pull.web',
        video: 'video.web',
        search: 'search.web',
        searchStatus: 'search.web/status',
        speed: 'playspeed.web',
        step: 'step.web',
        time: 'timestamp.web',
        ptz: 'ptz.web',
        trigger: 'trigger.web',
        metadata: 'metadata.web',
        resourceKey: 'key.web',
        version: 'version.web',
        digitalPtz: 'digitalptz.web',
        service: 'service.web',
        serviceDiscovery: 'service.web/discovery',
        audio: 'audio.web',
        videoexport: 'export.web',
        map: 'map.web',
        status: 'status.web',
        groups: 'groups.web',
        thumbnail: 'thumbnail.web',
        tours: 'tour.web',
        serverUsers: 'server.web/users',
        serverPlugins: 'server.web/plugins',
        health: 'health.web',
        systemInfo: 'server.web',
        videopush: 'videopush.web',
        videopushMessage: 'videopush.web/message',
        devices: 'server.web/devices',
        deviceTypes: 'server.web/devices/types',
        cachedThumbnail: 'video.web/thumbnail',
        camera: 'camera.web',
        configUpdateStatus: 'server.web/events/status',
        users: 'users.web',
        userGroups: 'users.web/groups',
        eventMonitoring: 'eventmonitoring.web',
        eventMonitoringPush: 'eventmonitoring.web/push',
        pushNotification: 'pushnotification.web',
        brokerConfig: 'broker.web/config',
        legacyWebsocketStatus: 'status.web/legacywebsocket',
        legacyWebsocketCamerasOsd: 'camera.web/legacywebsocket',
        auth: 'auth.web',
        authLogout: 'auth.web/logout',
        bookmark: 'bookmark.web',
        bookmarkItems: 'bookmark.web/items',
        bookmarkCases: 'bookmark.web/cases',
        associations: 'associations.web',
        associationsCamera: 'associations.web/camera',
        associationsCameraItem: 'associations.web/camera/item',
        securityIntegrationDevices: 'securityintegrations.web',
        securityIntegrationsDeviceLogin: 'securityintegrations.web/login',
        securityIntegrationsDeviceSensors: 'securityintegrations.web/sensors',
        serverSerialInfo: 'server.web/serial',
        serialDevices: 'serial.web',
        serialData: 'serial.web/data',
        serialStoredData: 'serial.web/data/stored',
        serialProfiles: 'serial.web/profile',
        serialProfileKeywords: 'serial.web/profile/keywords',
        serialProfileLineMasks: 'serial.web/profile/masks',
        serialProfileReplacements: 'serial.web/profile/replacements',
        serialProfileRules: 'serial.web/profile/rules',
        serviceInfo: 'service.web/info',
        serviceConfigToken: 'service.web/token',
        serviceConfigServers: 'service.web/servers',
        serviceConfigServersXdv: 'service.web/servers/xdv',
        serviceConfigRemoteServers: 'service.web/remoteservers',
        serviceConfigRemoteServersListener: 'service.web/remoteservers/listener',
        serviceConfigLogging: 'service.web/logging',
        serviceConfigLoggingFile: 'service.web/logging/file',
        serviceConfigBasic: 'service.web/config',
        serviceConfigUpdates: 'service.web/updates',
        serviceConfigExternalAuth: 'service.web/externalauth',
        serviceConfigAdmin: 'service.web/admin',
        serviceConfigStatus: 'service.web/status',
        serviceConnectivityStatus: 'service.web/status/connectivity',
        serviceServerStatus: 'service.web/status/server',
        serviceSSLConfigType: 'service.web/config/ssl',
        serviceSSLExternalConfig: 'service.web/config/ssl/external',
        serviceSSLAcmeConfig: 'service.web/config/ssl/acme',
        serviceSSLAcmeStatus: 'service.web/config/ssl/acme/status',
        serviceRestoreDefaults: 'service.web/reset',
        events: 'events.web',
        archiveTargets: 'server.web/archive',
        searchVideo: 'video.web/search',
        addresses: 'service.web/addresses',
        analyticRules: 'analytics.web/rules',
        analyticRulePush: 'analytics.web/rules/push',
        searchSnapshot: 'video.web/search/snapshot'
    };


    /**
     * The font styles available.
     * @enum {Number}
     * @readonly
     * @category Util
     */
    EVWEB2.fontStyle = {
        /**
         * Unknown
         */
        unknown: 0,
        /**
         * Normal
         */
        normal: 90,
        /**
         * Italic
         */
        italic: 93,
        /**
         * Slant
         */
        slant: 94
    };

    /**
     * The font colors available.
     * @enum {Number}
     * @readonly
     * @category Util
     */
    EVWEB2.fontColor = {
        /**
         * Unknown
         */
        unknown: -1,
        /**
         * White
         */
        white: 0XFFFFFF,
        /**
         * Aqua
         */
        aqua: 0X00FFFF,
        /**
         * Fushia
         */
        fushia: 0XFF00FF,
        /**
         * Yellow
         */
        yellow: 0XFFFF00,
        /**
         * Silver
         */
        silver: 0XC0C0C0,
        /**
         * Red
         */
        red: 0XFF0000,
        /**
         * Lime
         */
        lime: 0X00FF00,
        /**
         * Blue
         */
        blue: 0X0000FF,
        /**
         * Gray
         */
        gray: 0X808080,
        /**
         * Teal
         */
        teal: 0X008080,
        /**
         * Purple
         */
        purple: 0X800080,
        /**
         * Olive
         */
        olive: 0X808000,
        /**
         * Black
         */
        black: 0X000000,
        /**
         * Maroon
         */
        maroon: 0X800000,
        /**
         * Green
         */
        green: 0X008000,
        /**
         * Navy
         */
        navy: 0X000080
    };

    /**
     * The font weights available.
     * @enum {Number}
     * @readonly
     * @category Util
     */
    EVWEB2.fontWeight = {
        /**
         * Unknown
         */
        unknown: 0,
        /**
         * Light
         */
        light: 90,
        /**
         * Bold
         */
        bold: 92
    };

    /**
     * The font families available.
     * @enum {Number}
     * @readonly
     * @category Util
     */
    EVWEB2.fontFamily = {
        /**
         * Unknown
         */
        unknown: 0,
        /**
         * Default Font
         */
        defaultFont: 70,
        /**
         * Decorative
         */
        decorative: 71,
        /**
         * Roman
         */
        roman: 72,
        /**
         * Script
         */
        script: 73,
        /**
         * Swiss
         */
        swiss: 74,
        /**
         * Modern
         */
        modern: 75,
        /**
         * Teletype
         */
        teletype: 76
    };

    /**
     * Container for font information.  Used primarily by {@link EVWEB2.Association}.
     * @param {String} [font='Sans'] The name of the font.
     * @param {Number} [size=10] The font size.
     * @param {EVWEB2.fontStyle} [style=EVWEB2.fontStyle.normal] The font style used for displaying text.
     * @param {EVWEB2.fontColor} [color=EVWEB2.fontColor.white] The font color used for displaying text.
     * @param {EVWEB2.fontFamily} [family=EVWEB2.fontFamily.defaultFont] The font family used for displaying text.
     * @param {EVWEB2.fontWeight} [weight=EVWEB2.fontWeight.light] The font weight used for displaying text.
     * @param {Boolean} [underline=false] Whether the font should be underlined.
     * @constructor
     * @category Util
     */
    EVWEB2.FontInfo = function(font, size, style, color, family, weight, underline){

        /**
         * The name of the font.
         * @type {String}
         */
        this.font = 'Sans';

        /**
         * The font size.
         * @type {number}
         */
        this.size = 10;

        /**
         * The font style used for displaying text.
         * @type {EVWEB2.fontStyle}
         */
        this.style = EVWEB2.fontStyle.normal;

        /**
         * The font color used for displaying text.
         * @type {EVWEB2.fontColor}
         */
        this.color = EVWEB2.fontColor.white;

        /**
         * The font family used for displaying text.
         * @type {EVWEB2.fontFamily}
         */
        this.family = EVWEB2.fontFamily.defaultFont;

        /**
         * The font weight used for displaying text.
         * @type {EVWEB2.fontWeight}
         */
        this.weight = EVWEB2.fontWeight.light;

        /**
         * Whether the font should be underlined.
         * @type {boolean}
         */
        this.underline = false;

        if(font !== undefined) {
            this.font = font;
        }
        if(size !== undefined) {
            this.size = size;
        }
        if(style !== undefined) {
            this.style = style;
        }
        if(color !== undefined) {
            this.color = color;
        }
        if(family !== undefined) {
            this.family = family;
        }
        if(weight !== undefined) {
            this.weight = weight;
        }
        if(underline !== undefined) {
            this.underline = underline;
        }
    };

}());

/*globals EVWEB2:true*/
(function() {
    /**
     * Passed for all {@link EVWEB2} calls that return a result as the first parameter of every response callback to
     * provide information on the success/failure of a request.
     * @param {Boolean} success Whether the request succeeded
     * @param {String} [errorText] Error text of the response
     * @param {Number} [errorCode] Error code of the response.  (Reserved for future use.)
     * @class
     * @constructor
     * @category Util
     */
    EVWEB2.ResponseStatus = function(success, errorText, errorCode) {
        /**
         * Whether the request succeeded
         * @type Boolean
         */
        this.success = false;

        /**
         * The error text of the response.
         * @type String
         */
        this.errorText = '';

        /**
         * The error code of the response.  (Not currently used)
         * @type Number
         */
        this.errorCode = 0;

        if(typeof success !== 'undefined') {
            this.success = success;
        }
        if(typeof errorText !== 'undefined') {
            this.errorText = errorText;
        }
        if(typeof errorCode !== 'undefined') {
            this.errorCode = errorCode;
        }
    };
}());
/*globals EVWEB2:true*/

(function() {
    "use strict";

    /**
     * Basic container for log items.
     * @param {Date} time The time at which the log item was recorded.
     * @param {Array} args The array of arguments passed to the function.
     * @constructor
     * @category Util
     */
    EVWEB2.LogItem = function(time, args) {
        this.time = time;
        this.args = args;
    };


    /**
     * Logging system.  Wraps console.log, debug, and error, filtering out messages if it is not
     * enabled.
     * @class
     * @category Util
     */
    EVWEB2.Logging = function() {

        /**
         * Whether logging is enabled or not.  If not enabled, the past
         * {@link EVWEB2.Logging.recordsToStore} will be stored, but none will be written out to the
         * console.
         * @type {boolean}
         */
        this.enabled = false;

        /**
         * The maximum number of records to store for each log type.
         * @type {number}
         */
        this.recordsToStore = 50;

        /**
         * Stores the past {@link EVWEB2.Logging.recordsToStore} logs of each type passed into console.
         * @private
         * @type {Object}
         */
        var logs = {};

        /**
         * A list of the supported console methods that are wrapped.  These can be extended to
         * include others, if necessary.
         * @private
         * @type {string[]}
         */
        var consoleMessages = ['log', 'debug', 'error'];


        /**
         * Override callback to be used in place of the default console logging.
         * @private
         * @type {function|undefined}
         */
        var overrideCallback;

        /**
         * Reference to this object for dynamically extending the object.
         * @private
         * @type {EVWEB2.Logging}
         */
        var instance = this;

        /**
         * Primary action of each console wrapper method.  Stores the message in {@logs} and, if
         * enabled, passes the content to the console native method.
         * @private
         * @param {String} method The method called on console. (e.g. 'log', 'debug', etc.)
         * @param {Array} args The arguments passed to the original call.
         */
        var consoleAction = function(method, args) {
            if(logs[method] === undefined) {
                logs[method] = [];
            }
            var logItem = new EVWEB2.LogItem(new Date(), args);
            logs[method].push(logItem);

            var logLength = logs[method].length;
            if(logLength > instance.recordsToStore) {
                logs[method] = logs[method].slice(logLength - instance.recordsToStore);
            }

            if(instance.enabled) {
                if(overrideCallback !== undefined) {
                    overrideCallback(logItem);
                }
                /* eslint-disable no-console */
                else if (console !== undefined && console[method] !== undefined) {
                    console[method].apply(console, args);
                }
                /* eslint-enable no-console */
            }
        };

        /**
         * Generates the anonymous function for binding the console wrapper methods.
         * @private
         * @param {string} method The method called on console. (e.g. 'log', 'debug', etc.)
         * @returns {Function} The anonymous function calling {@link consoleAction}.
         */
        var generateConsoleAction = function(method) {
            return function() {
                consoleAction(method, arguments);
            };
        };

        // Wire up each of the console messages with their wrapper method.
        var i;
        for(i=0; i<consoleMessages.length; i++) {
            var method = consoleMessages[i];
            instance[method] = generateConsoleAction(method);
        }

        /**
         * Applies an override callback to be called in place of the default console methods.  This
         * can be used to integrate the internal API logging into other logging structures.
         * @param {Function} override A function used to override the default logging methods.  This
         * callback is called with an {@link EVWEB2.LogItem} for each enabled logging statement.
         */
        this.applyOverride = function(override) {
            if(overrideCallback !== undefined) {
                EVWEB2.logger.main.debug('Overriding existing logging callback.', overrideCallback, override);
            }
            overrideCallback = override;
        };

        /**
         * Removes an existing override callback, returning the logger to using the default console
         * methods.
         */
        this.removeOverride = function() {
            if(overrideCallback === undefined) {
                EVWEB2.logger.main.debug('Removing logging callback with none applied.');
            }
            overrideCallback = undefined;
        };

        /**
         * Retrieves the stored logs for the provided method.
         * @param {String} method The method called on console. (e.g. 'log', 'debug', etc.)
         * @param {Number} [numRecords=EVWEB2.logger.recordsToStore] The maximum number of records
         * to return.
         * @returns {Array} Array of log items sorted by the time each was applied.
         */
        this.storedLogs = function(method, numRecords) {
            if(logs[method] === undefined) {
                return [];
            }
            if(numRecords === undefined) {
                numRecords = instance.recordsToStore;
            }
            if(numRecords > instance.recordsToStore) {
                EVWEB2.logger.main.debug('More records requested than max stored.', numRecords, instance.recordsToStore);
                numRecords = instance.recordsToStore;
            }
            var sliceIndex = logs[method].length - numRecords;
            if(sliceIndex < 0) {
                sliceIndex = 0;
            }
            return logs[method].slice(sliceIndex);
        };

    };

    /**
     * The primary logger instance for EVWEB2.
     * @type {EVWEB2.Logging}
     * @category Util
     */
    EVWEB2.logger = {
        main: new EVWEB2.Logging()
    };

    /**
     * Helper reference for associating with the primary logging instance.  This is a mapping of
     * {@link EVWEB2.logger.main.log}.
     * @type {function}
     * @category Util
     */
    EVWEB2.log = EVWEB2.logger.main.log;
}());

/*globals EVWEB2:true*/
(function() {
    /**
     * A collection of utility functions used by the API.
     * @type {Object}
     * @category Util
     */
    EVWEB2.util = {};

    /**
     * The Date2IETF function is a helper function for communicating with the search system.  The search system
     * uses all times in IETF RFC 3339 format, so to aid in communicating with the search API, this function will
     * take the native JavaScript Date object and convert it into an IETF RFC 3339 compliant string format.  If the
     * passed in parameter is not a valid Date Object, an empty string will be returned.
     * @param {Date} dateObj Date object that is the source for the converted IETF compliant string.
     * @param {Boolean} useMs Whether or not to include milliseconds in the IETF format.
     * @return {String} The date in the IETF format, or an empty string if the object is not the valid Date
     * @category Util
     */
    EVWEB2.util.Date2IETF = function (dateObj, useMs) {
        useMs = useMs || false;

        if(typeof dateObj === 'undefined' || dateObj === null || typeof dateObj.getHours === 'undefined') {
            return "";
        }

        var ietf = dateObj.getUTCFullYear() + '-';
        var month = dateObj.getUTCMonth() + 1;
        if(month < 10) {
            ietf += '0';
        }
        ietf += month + '-';

        var date = dateObj.getUTCDate();
        if(date < 10) {
            ietf += '0';
        }
        ietf += date + 'T';

        var hours = dateObj.getUTCHours();
        if(hours < 10) {
            ietf += '0';
        }
        ietf += hours + ':';

        var minutes = dateObj.getUTCMinutes();
        if(minutes < 10) {
            ietf += '0';
        }
        ietf += minutes + ':';

        var seconds = dateObj.getUTCSeconds();
        if (seconds < 10) {
            ietf += '0';
        }
        ietf += seconds;

        if(useMs) {
            var ms = dateObj.getUTCMilliseconds();
            if (ms > 0) {
                ietf += '.';
                if (ms < 100) {
                    ietf += '0';
                }

                if (ms < 10) {
                    ietf += '0';
                }

                ietf += ms;
            }
        }

        ietf += 'Z';
        return ietf;
    };

    /**
     * The IETF2Date function is a reverse of the {@link EVWEB2.util.Date2IETF} function that translates the IETF
     * formatted string into a native JavaScript Date object.  With a passed in IETF RFC 3339 date-time string, this
     * will split and parse the string into a proper Date object that can be used with time tracking of the search
     * feed.
     * @param {String} ietf String in IETF format to be converted to a Date object
     * @return {Date} A date object with the date-time from the given IETF date-time string or null if the string is
     * invalid
     * @category Util
     */
    EVWEB2.util.IETF2Date = function (ietf) {
        var date = new Date(0);

        if(typeof ietf !== 'string') {
            return null;
        }

        var ietfSplit = ietf.split('T');
        if(ietfSplit.length !== 2) {
            return null;
        }
        var dateData = ietfSplit[0].split('-');
        if (dateData.length !== 3) {
            return null;
        }

        date.setUTCFullYear(dateData[0]);
        date.setUTCMonth(parseInt(dateData[1],10) - 1);
        date.setUTCDate(dateData[2]);

        var timeData = ietfSplit[1].split(':');
        if (timeData.length !== 3) {
            return null;
        }

        date.setUTCHours(timeData[0]);
        date.setUTCMinutes(timeData[1]);

        var secData = timeData[2].split(/[.Z]/);
        date.setUTCSeconds(secData[0]);

        if (secData[1].length > 1) {
            date.setUTCMilliseconds(secData[1]);
        }

        return date;
    };

    /**
     * @typedef {Number[]} RGBA
     * An RGBA color stored as
     * <pre>[red, green, blue, alpha]</pre>
     * The rgb components as represented as 8-bit unsigned integers, the alpha component is stored as a floating-point
     * number in the range [0,1].
     */
    /**
     * Arranges separate RGB and alpha components of a color into a composite {@link RGBA} declaration.
     * @param {Number} rgb The RGB component of the color.
     * @param {Number} alpha The alpha component of the color.
     * @return {RGBA} The color declaration.
     * @category Util
     */
    EVWEB2.util.RGBA = function(rgb, alpha) {
    /*eslint-disable no-bitwise*/
        return [
            rgb & 0xff0000 >> 16,
            rgb & 0xff00 >> 8,
            rgb & 0xff,
            alpha / 100
        ];
    };
    /*eslint-enable no-bitwise*/

    /**
     * Event handler for the load event for the image used by {@link EVWEB2.util.attachCamera}.  Continues to update
     * the image with the next frame after each successive load.
     * @private
     * @param {Event} e jQuery event object
     * @category Util
     */
    var onCameraImgLoad = function(e) {
        var target = $(e.target);

        var params = target.attr('title');
        params = params.split(';');
        if (target.attr('alt') === '-1') {
            target.src = e.data.camera.getFrame(parseInt(params[0],10), parseInt(params[1],10), parseInt(params[2],10));
        }
        else {
            target.src = e.data.camera.getFrame(parseInt(params[0],10), parseInt(params[1],10), parseInt(params[2],10),
                target.attr('alt'));
        }
    };

    /**
     *	The attachCamera function is designed to give a simple way of turning a document element into a feed
     *	display.  It will start a looping request-display system on the object, replacing it with the image for
     *	the desired Camera feed.  Once the image has been received and loaded, another image is requested,
     *	and this continues looping until stopped.  The speed of the display for the feed "video" is dependent on
     *	a number of factors, including the connection speed between the user and the web service, the connection
     *	between the web service web server and the exacqVision server, or the JPEG decompression speed of the
     *	user's computer.  To provide a simple and varying update speed, the onLoad system is used on the image,
     *	rather than a Timer linked event.
     *	@param {String|Object} element Either a jQuery selector or nodeset of the element to attach the camera to.
     *	@param {EVWEB2.Camera} camera Camera instance to from which to retrieve the feed.
     *  @param {Number} height The height of the image
     *  @param {Number} width The width of the image
     *  @param {Number} quality The quality of the image (between 1 and 10)
     *  @category Util
     */
    EVWEB2.util.attachCamera = function (element, camera, height, width, quality) {
        element = $(element);
        var target = $(element);
        if(!target.is('img')) {
            var img = $('<img/>');
            img.attr('id', 'C' + camera.id);
            target.append(img);
            target = img;
        }
        target.attr('title', width.toString() + ';' + height.toString() + ';' + quality.toString());
        target.on('load', {camera: camera}, onCameraImgLoad);
        target.attr('src', camera.getFrame(width, height, quality));
        target.attr('alt', '-1');
    };

    /**
     * Generates a unique stream ID.
     * @return {String} The generated stream ID.
     * @category Util
     */
    EVWEB2.util.generateStreamId = function() {
        var r = Math.floor(Math.random()*0xffffffff);
        return r.toString(16);
    };

    /**
     * Converts legacy plugin, device, interface and context IDs into a camera ID.
     * @param {Number} pluginId The plugin ID for the camera.
     * @param {Number} interfaceId The interface ID for the camera
     * @param {Number} deviceId The device ID for the camera.
     * @param {Number} [contextId=0] The context ID for the camera.
     * @return {String} The camera ID.
     * @category Util
     */
    EVWEB2.util.pidToCameraId = function(pluginId, interfaceId, deviceId, contextId) {
        if(typeof contextId === 'undefined') {
            contextId = 0;
        }
        /* eslint-disable no-bitwise */
        var cameraId = contextId << 28 | pluginId | (deviceId << 8) | interfaceId;
        /* eslint-enable no-bitwise */
        return cameraId;
    };

    /**
     * Utility for performing an XSS POST request by creating and submitting an &lt;iframe&gt; on the page.  Note:
     * when using this method, there is no way to retrieve the response.
     * @param {String} url The URL for the POST request.
     * @param {Object} parameters An object of name value pairs to be passed as parameters to the web service.
     * @deprecated This method is deprecated in favor of {@link EVWEB2.util.internal.XSSPost}.
     * @internal
     * @ignore
     * @category Util
     */
    EVWEB2.util.XSSPost = function(url, parameters) {
        EVWEB2.util.internal.XSSPost(url, parameters);
    };

    /**
     * Updates a jQuery AJAX request settings object with XSS-specific options.
     * @param {Object} request jQuery AJAX request settings object
     * @param {EVWEB2.Service} [service] The service of the resource key to add.  When set, the resource key property
     * will be applied to the request.
     * @returns {Object} The updated request
     * @deprecated This method is deprecated in favor of {@link EVWEB2.util.internal.updateRequestForXss}.
     * @internal
     * @ignore
     * @category Util
     */
    EVWEB2.util.updateRequestForXss = function(request, service) {
        return EVWEB2.util.internal.updateRequestForXss(request, service);
    };

    /**
     * Polls the service by sending version.web requests to determine when the service has restarted.
     * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
     * {@link EVWEB2.ResponseStatus} instance and a copy of the {@link EVWEB2.Service} instance.
     * @param {EVWEB2.Service} [service=null] The service instance.
     * @param {Number} pollingInterval The interval duration for polling attempts for determining when the service has
     * restarted.
     * @param {Number} pollingMaxRetries The number of poll attempts before returning an error on service restart.
     * @param {Number} pollingConfirmationsRequired The number of successful subsequent polls before returning a
     * success on service restart.
     * @deprecated This method is deprecated in favor of {@link EVWEB2.util.internal.notifyOnServiceRestart}.
     * @internal
     * @ignore
     * @category Util
     */
    EVWEB2.util.notifyOnServiceRestart = function(callback, service, pollingInterval, pollingMaxRetries,
                                          pollingConfirmationsRequired) {

        return EVWEB2.util.internal.notifyOnServiceRestart(callback, service, pollingInterval, pollingMaxRetries,
                                                        pollingConfirmationsRequired);
    };

    /**
     * Internal helper utility for processing a server response to generate a user permissions object.
     * This is a legacy method that processes permissions at the user level.
     * @param {Object} serverData The server response data
     * @returns {EVWEB2.UserPermissions} The user permissions
     * @deprecated This method is deprecated in favor of {@link EVWEB2.util.internal.processServerPermissions}.
     * @internal
     * @ignore
     * @category Util
     */
    EVWEB2.util.processServerPermissions = function(serverData) {
        return EVWEB2.util.internal.processServerPermissions(serverData);
    };

    /**
     * Parse the IP address from an RTSP host URL.
     * NOTE: Can only parse IPv4 addresses.
     * @param {String} host the RTSP URL
     * @returns {String} The IP address or null if a valid IP address was not found.
     * @deprecated This method is deprecated in favor of {@link EVWEB2.util.internal.parseRtspIpAddress}.
     * @internal
     * @ignore
     * @category Util
     */
    EVWEB2.util.parseRtspIpAddress = function(host) {
        return EVWEB2.util.internal.parseRtspIpAddress(host);
    };

    /**
     * Retrieves the error text from a failed XHR response object, if possible.
     * @param {Object} xhr The failed request.
     * @returns {String} The error text.
     * @internal
     * @ignore
     * @category Util
     */
    EVWEB2.util.getErrorText = function(xhr) {
        var errorText = 'An error occurred.';
        try {
            if(xhr.responseText === undefined) {
                return errorText;
            }
            var response = JSON.parse(xhr.responseText);
            if(response.errorText.length === 0) {
                return errorText;
            }
            return response.errorText;
        }
        catch(e) {
            return errorText;
        }
    };

    /**
     * Retrieves the error code from a failed XHR response object, if possible.
     * @param {Object} xhr The failed request.
     * @returns {Number|undefined} The error code if present.
     * @internal
     * @ignore
     * @category Util
     */
    EVWEB2.util.getErrorCode = function(xhr) {
        try {
            if(xhr.responseText === undefined) {
                return;
            }
            var response = JSON.parse(xhr.responseText);
            if(response.errorCode !== undefined) {
                return response.errorCode;
            }
        }
        catch(e) {
            return undefined;
        }
    };
}());

/*globals EVWEB2:true*/
(function() {

    "use strict";

    /**
     * @class
     * A collection of utility functions used by the API.
     * @type {Object}
     * @internal
     * @ignore
     */
    EVWEB2.util.internal = {};

    /**
     * Utility for performing an XSS POST request by creating and submitting an &lt;iframe&gt; on the page.  Note:
     * when using this method, there is no way to retrieve the response.
     * @param {String} url The URL for the POST request.
     * @param {Object} parameters An object of name value pairs to be passed as parameters to the web service.
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.XSSPost = function(url, parameters) {
        var iframe = $('<iframe style="display: none;"><html><body></body></html></iframe>');
        $('body').append(iframe);
        var form = $('<form></form>');
        form.attr('action', url);
        form.attr('method', 'post');
        var key;
        var formHasFileInput = false;
        var inputsToRevert = [];
        for(key in parameters) {
            if(parameters.hasOwnProperty(key)) {
                var input;
                if(parameters[key] instanceof $ ) {
                    formHasFileInput = parameters[key].attr('type') === 'file';
                    input = parameters[key];
                    inputsToRevert.push({
                        input: input,
                        parent: input.parent()
                    });
                }
                else {
                    input = $('<input type="hidden"/>');
                    input.attr('value', parameters[key]);
                }
                input.attr('name', key);
                form.append(input);
            }
        }
        if(formHasFileInput) {
            form.attr('enctype', 'multipart/form-data');
        }

        var revertMovedInputs = function(movedInputs) {
            $.each(movedInputs, function(index, element) {
                element.parent.append(element.input);
            });
        };

        if(iframe.contents().find('body').length !== 0) {
            iframe.contents().find('body').append(form);
            form.submit();
            iframe.on('load readystatechange', function() {
                form.on('submit', function() {
                    revertMovedInputs(inputsToRevert);
                    iframe.remove();
                });
            });
        }
        else {
            // IE doesn't make the iframe's body available until after the iframe is loaded.
            var onIeIframeLoad = function() {
                iframe.off('load readystatechange', onIeIframeLoad);
                iframe.contents().find('body').append(form);
                form.submit();
                revertMovedInputs(inputsToRevert);
                iframe.remove();
            };

            iframe.on('load readystatechange', onIeIframeLoad);
        }
    };

    /**
     * Updates a jQuery AJAX request settings object with XSS-specific options.
     * @param {Object} request jQuery AJAX request settings object
     * @param {EVWEB2.Service} [service] The service of the resource key to add.  When set, the resource key property
     * will be applied to the request.
     * @return {Object} The updated request
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.updateRequestForXss = function(request, service) {
        request.dataType = 'jsonp';
        request.timeout = EVWEB2.config.jsonpRequestTimeout;
        if(request.type !== undefined && request.type !== 'GET') {
            if(request.data === undefined) {
                request.data = {};
            }
            request.data.verb = request.type;
        }

        if(service !== undefined) {
            if(request.data === undefined) {
                request.data = {};
            }
            request.data.key = service.resourceKey;
        }
        return request;
    };

    /**
     * Cached value of whether CORS is supported for this instance.  This value is set and
     * referenced by {@link EVWEB2.util.internal.corsSupported}.
     * @type {undefined|Boolean}
     * @internal
     * @ignore
     */
    var corsSupported;

    /**
     * Utility method to determine whether CORS support is enabled for this browser.
     * @returns {Boolean} Whether CORS is supported
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.corsSupported = function() {
        if(corsSupported === undefined) {
            corsSupported = 'withCredentials' in new XMLHttpRequest();
        }
        return corsSupported;
    };

    /**
     * Wrapper method for $.ajax, which applies any existing authorization token to the request,
     * as well as call {@link EVWEB2.util.internal.updateRequestForXss} to apply any necessary
     * XSS transformations.  As a convenience, this function is aliased as {@link EVWEB2.ajax}
     * @param {Object} settings The settings object for $.ajax.
     * @param {EVWEB2.Service} service The service instance associated with this request.
     * @param {Boolean} [nonCorsForcePost=false] Whether to force a POST for non-CORS XSS POST
     * requests using {@link EVWEB2.util.internal.XSSPost}
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.ajax = function(settings, service, nonCorsForcePost) {
        if(service.config.authToken !== null && service.config.secureAuthTokenMethod === true) {
            // Remove auth param from payload
            if(settings.data !== undefined) {
                settings.data.auth = undefined;
            }
            // Add in the HTTP Auth Bearer headers
            if (settings.headers === undefined) {
                settings.headers = {};
            }
            settings.headers['X-Service-Authorization'] = 'Bearer ' + service.config.authToken;

            // Add in the withCredentials property to xhrFields
            if(settings.xhrFields === undefined) {
                settings.xhrFields = {};
            }
            settings.xhrFields["withCredentials"] = true;
        }
        if(EVWEB2.util.internal.corsSupported() && service.supportsCors()) {
            if (service.auth.token !== '' &&
                (service.auth.type !== EVWEB2.serviceAuthTypes.unknown
                || service.auth.type !== EVWEB2.serviceAuthTypes.none)) {

                // Add in the HTTP Auth Bearer headers
                if (settings.headers === undefined) {
                    settings.headers = {};
                }
                settings.headers['Authorization'] = 'Bearer ' + service.auth.token;

                // Add in the withCredentials property to xhrFields
                if(settings.xhrFields === undefined) {
                    settings.xhrFields = {};
                }
                settings.xhrFields["withCredentials"] = true;
            }
        }
        else {
            if(nonCorsForcePost === undefined) {
                nonCorsForcePost = false;
            }
            // Update the request for XSS requests
            if (service.isXss()) {
                if(settings.type === 'POST' && nonCorsForcePost) {
                    // Force a XSS Post and call the success callback
                    EVWEB2.util.internal.XSSPost(settings.url, settings.data);
                    var response = {
                        success: true,
                        xssPost: true
                    };
                    if(settings.success !== undefined) {
                        settings.success(response);
                    }
                    return;
                }

                // Update the request to use JSONP
                EVWEB2.util.internal.updateRequestForXss(settings, service);
            }
        }
        $.ajax(settings);
    };

    /**
     * Alias for EVWEB2.util.internal.ajax
     * @type {EVWEB2.util.internal.ajax|*}
     * @internal
     * @ignore
     */
    EVWEB2.ajax = EVWEB2.util.internal.ajax;

    /**
     * Polls the service by sending version.web requests to determine when the service has restarted.
     * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
     * {@link EVWEB2.ResponseStatus} instance, a copy of the {@link EVWEB2.Service} instance, and a Boolean.
     * flag indicating if the service restart was confirmed.
     * @param {EVWEB2.Service} [service=null] The service instance.
     * @param {Number} pollingInterval The interval duration for polling attempts for determining when the service has
     * restarted.
     * @param {Number} pollingMaxRetries The number of poll attempts before returning an error on service restart.
     * @param {Number} pollingConfirmationsRequired The number of successful subsequent polls before returning a
     * success on service restart.
     * @internal
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.notifyOnServiceRestart = function(callback, service, pollingInterval, pollingMaxRetries,
                                          pollingConfirmationsRequired) {

        var confirmedRetries = 0;
        var retries = 0;

        var pollVersion;

        var onVersionSuccess = function() {
            confirmedRetries++;
            if(confirmedRetries >= pollingConfirmationsRequired) {
                // Send a successful response.
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, service, true);
            }
            else {
                // Poll the version again.
                pollVersion();
            }
        };

        var onVersionError = function() {
            confirmedRetries = 0;
            if(retries >= pollingMaxRetries) {
                // Send an error response
                var errorText = 'An error occurred when restarting the web service.';
                var errorResponse = new EVWEB2.ResponseStatus(false, errorText);
                callback(errorResponse, undefined, false);
                return;
            }
            retries++;

            // Poll the version again
            pollVersion();
        };

        pollVersion = function() {
            setTimeout(function() {
                var settings = {
                    success: onVersionSuccess,
                    error: onVersionError,
                    url: service.url() + EVWEB2.urls.version
                };

                if(service.isXss()) {
                    settings.data = {
                        output: 'json'
                    };
                }
                EVWEB2.ajax(settings, service);

            }, pollingInterval);
        };

        // Start polling the version.
        pollVersion();
    };

    /**
     * Internal helper utility for processing a group's permissions bitmask values to generate a user group permissions object.
     * @param {Object} bitmaskValues The permissions bitmask values received from the web service.
     * @returns {EVWEB2.UserGroupPermissions} The user group permissions object.
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.processUserGroupPermissions = function(bitmaskValues) {
        /* eslint-disable no-bitwise */
        var permissions = [];
        var userPermissionsArr = [
            EVWEB2.userPermissions.livePermissions,
            EVWEB2.userPermissions.searchPermissions
        ];

        var userPermissionsBitmask = [
            EVWEB2.permissionsBitmask.livePermissions,
            EVWEB2.permissionsBitmask.searchPermissions
        ];

        var userMask = bitmaskValues.user;
        $.each(userPermissionsBitmask, function(index, element) {
            $.each(element, function(key, value) {
                if(((value | userMask) === userMask) && userPermissionsArr[index].hasOwnProperty(key)) {
                    permissions.push(userPermissionsArr[index][key]);
                }
            });
        });

        var adminPermissionsArr = [EVWEB2.userPermissions.configPermissions];
        var adminPermissionsBitmask = [EVWEB2.permissionsBitmask.configPermissions];
        var adminMask = bitmaskValues.admin;
        $.each(adminPermissionsBitmask, function(index, element) {
            $.each(element, function(key, value) {
                if(((value | adminMask) === adminMask) && adminPermissionsArr[index].hasOwnProperty(key)) {
                    permissions.push(adminPermissionsArr[index][key]);
                }
            });
        });
        var groupPermissionsArr = [EVWEB2.userPermissions.groupPermissions];
        var groupPermissionsBitmask = [EVWEB2.permissionsBitmask.groupPermissions];
        var groupMask = bitmaskValues.group;
        $.each(groupPermissionsBitmask, function(index, element) {
            $.each(element, function(key, value) {
                if(((value | groupMask) === groupMask) && groupPermissionsArr[index].hasOwnProperty(key)) {
                    permissions.push(groupPermissionsArr[index][key]);
                }
            });
        });
        /* eslint-enable no-bitwise */

        return new EVWEB2.UserGroupPermissions(permissions);
    };

    /**
     * Internal helper utility for processing a server response to generate a user permissions object.
     * This is a legacy method that processes permissions at the user level.
     * @param {Object} serverData The server response data
     * @returns {EVWEB2.UserPermissions} The user permissions
     * @deprecated This method is deprecated in favor of {@link EVWEB2.util.internal.processUserGroupPermissions} which generates
     * a user group permissions object.
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.processServerPermissions = function(serverData) {
        var userPermissionsInfo = serverData.user_permissions;
        var livePermissions;
        var searchPermissions;
        var accessLevel = EVWEB2.accessLevelType.unknown;

        if(userPermissionsInfo !== undefined) {
            // Update the user permissions for Live
            livePermissions = new EVWEB2.LiveUserPermissions(userPermissionsInfo.live,
                userPermissionsInfo.live_groups, userPermissionsInfo.live_maps, userPermissionsInfo.live_views,
                userPermissionsInfo.quick_replay, userPermissionsInfo.ptz, userPermissionsInfo.two_way_audio,
                userPermissionsInfo.event_monitor, userPermissionsInfo.live_save_image,
                userPermissionsInfo.live_print_image, userPermissionsInfo.live_cameras, userPermissionsInfo.video_push);

            // Update the user permissions for Search
            searchPermissions = new EVWEB2.SearchUserPermissions(userPermissionsInfo.search,
                userPermissionsInfo.search_groups, userPermissionsInfo.search_maps, userPermissionsInfo.search_views,
                userPermissionsInfo.search_events, userPermissionsInfo.save_image, userPermissionsInfo.print_image,
                userPermissionsInfo.burn_disc, userPermissionsInfo.export_video, userPermissionsInfo.smart_search,
                userPermissionsInfo.search_cases, userPermissionsInfo.search_cameras);

            accessLevel = userPermissionsInfo.accessLevel;
        }
        // Update the config permissions for the user
        var adminAccessInfo = serverData.admin_access_permissions;
        var configPermissions;
        if(adminAccessInfo !== undefined) {
            configPermissions = new EVWEB2.ConfigUserPermissions(adminAccessInfo.users, adminAccessInfo.views);
        }
        return new EVWEB2.UserPermissions(livePermissions, searchPermissions, configPermissions, accessLevel);
    };

    /**
     * Parse the IP address from an RTSP host URL.
     * NOTE: Can only parse IPv4 addresses.
     * @param {String} host the RTSP URL
     * @returns {String} The IP address or null if a valid IP address was not found.
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.parseRtspIpAddress = function(host) {
        if(typeof host !== 'string') {
            return null;
        }
        // rtsp://<ip-address>:port/path#<key>=<value>&<key>=<value>
        // http://<ip-address>:port/path#<key>=<value>&<key>=<value>

        // from regex cookbook
        var ipv4Re = /(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)/;
        var matches = host.match(ipv4Re);
        if (matches !== null && matches.length){
            return matches[0];
        }

        var simpleHostRe = /(?:rtsp|http|https):\/\/([0-9a-zA-Z\.]+)(:[0-9]+)?/;
        matches = host.match(simpleHostRe);
        if (matches !== null && matches.length > 1){
            return matches[1];
        }


        return null;
    };

    /**
     * Utility function to generate the group permissions object.
     * @param {EVWEB2.UserPermissions} [permissions=null] The user permissions object
     * @return {EVWEB2.UserGroupPermissions} The group permissions
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.generateGroupPermissions = function(permissions) {
        var permissionsArr = [
            permissions.livePermissions,
            permissions.searchPermissions,
            permissions.configPermissions
        ];
        var userPermissionsArr = [
            EVWEB2.userPermissions.livePermissions,
            EVWEB2.userPermissions.searchPermissions,
            EVWEB2.userPermissions.configPermissions
        ];
        var groupPermissions = [];

        $.each(permissionsArr, function(index, element) {
            if(element === null) {
                return;
            }
            $.each(element, function(key, value) {
                if(value && userPermissionsArr[index].hasOwnProperty(key)) {
                    groupPermissions.push(userPermissionsArr[index][key]);
                }
            });
        });
        return new EVWEB2.UserGroupPermissions(groupPermissions);
    };

    /**
     * Utility function to generate the user permissions object.
     * @param {EVWEB2.UserGroupPermissions} groupPermissions The group permissions object
     * @param {EVWEB2.accessLevelType} [accessLevel=EVWEB2.accessLevelType.unknown] The access level of the group
     * @return {EVWEB2.UserPermissions} The user permissions
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.generateUserPermissions = function(groupPermissions, accessLevel) {
        var permissions = groupPermissions.permissions;
        var userPermissionsArr = [
            EVWEB2.userPermissions.livePermissions,
            EVWEB2.userPermissions.searchPermissions,
            EVWEB2.userPermissions.configPermissions
        ];

        var i;
        var livePermissions = new EVWEB2.LiveUserPermissions();
        var searchPermissions = new EVWEB2.SearchUserPermissions();
        var configPermissions = new EVWEB2.ConfigUserPermissions();

        var keys = [livePermissions, searchPermissions, configPermissions, undefined];

        for(i=0; i < permissions.length; i++) {
            var enumVal = permissions[i];
            $.each(userPermissionsArr, function(index, element) {
                $.each(element, function(key, value) {
                    if(enumVal === value) {
                        keys[index][key] = true;
                    }
                });
            });
        }

        return new EVWEB2.UserPermissions(livePermissions, searchPermissions, configPermissions, accessLevel);
    };

    /**
     * Internal helper utility for generating a user group's permissions bitmask values.
     * @param {EVWEB2.UserGroupPermissions} groupPermissions The user group permissions.
     * @returns {Object} The bitmask values.
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.generatePermissionsBitmask = function(groupPermissions) {
        var permissions = groupPermissions.permissions;
        /* eslint-disable no-bitwise */
        var bitmask = {
            user: 0,
            admin: 0,
            group: 0
        };

        var userPermissionsArr = [
            EVWEB2.userPermissions.livePermissions,
            EVWEB2.userPermissions.searchPermissions
        ];

        var userPermissionsBitmask = [
            EVWEB2.permissionsBitmask.livePermissions,
            EVWEB2.permissionsBitmask.searchPermissions
        ];

        var adminPermissionsArr = [EVWEB2.userPermissions.configPermissions];
        var adminPermissionsBitmask = [EVWEB2.permissionsBitmask.configPermissions];

        var groupPermissionsArr = [EVWEB2.userPermissions.groupPermissions];
        var groupPermissionsBitmask = [EVWEB2.permissionsBitmask.groupPermissions];

        var i;
        for(i=0; i < permissions.length; i++) {
            $.each(userPermissionsArr, function (index, element) {
                $.each(element, function (key, value) {
                    if (value === permissions[i] && userPermissionsBitmask[index].hasOwnProperty(key)) {
                        bitmask.user = bitmask.user | userPermissionsBitmask[index][key];
                    }
                });
            });

            $.each(adminPermissionsArr, function (index, element) {
                $.each(element, function (key, value) {
                    if (value === permissions[i] && adminPermissionsBitmask[index].hasOwnProperty(key)) {
                        bitmask.admin = bitmask.admin | adminPermissionsBitmask[index][key];
                    }
                });
            });

            $.each(groupPermissionsArr, function (index, element) {
                $.each(element, function (key, value) {
                    if (value === permissions[i] && groupPermissionsBitmask[index].hasOwnProperty(key)) {
                        bitmask.group = bitmask.group | groupPermissionsBitmask[index][key];
                    }
                });
            });
        }
        /* eslint-enable no-bitwise */
        return bitmask;
    };

    /**
     * Processes a response server item from a login.web call and generates an EVWEB2.ServerDetailInfo instance.
     * @param {Object} serverResponse A server entry from a login.web call.
     * @return {EVWEB2.ServerDetailInfo} The server details
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.processServerDetails = function(serverResponse) {
        var serverInfo;
        if(typeof serverResponse.address !== 'undefined') {
            // Additional server information is available
            serverInfo = new EVWEB2.ServerDetailInfo(serverResponse.address, serverResponse.port,
                serverResponse.model, serverResponse.serial, serverResponse.version,
                serverResponse.daysRecordedVideo);
        }
        return serverInfo;
    };

    /**
     * Processes a response server item from a login.web call and generates an EVWEB2.ServerLicenseInfo instance.
     * @param {Object} serverResponse A server entry from a login.web call.
     * @return {EVWEB2.ServerLicenseInfo} The server license info
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.processServerLicense = function(serverResponse) {
        var licenseInfo;
        var license = serverResponse.licenseInfo;
        if(typeof license !== 'undefined') {
            // Additional server information is available
            var expirationDate = EVWEB2.util.IETF2Date(license.expirationDate);
            licenseInfo = new EVWEB2.ServerLicenseInfo(license.macAddress, expirationDate, license.expired,
                license.restricted, license.enterprise, license.maxAnalogCameras, license.maxIpCameras,
                license.maxBoards, license.licenseType, license.licenseKey);
        }
        return licenseInfo;
    };

    /**
     * Utility method that processes a camera osd information and generates an EVWEB2.CameraOsdInfo instance.
     * @param {Object} osd The osd info for a camera.
     * @return {EVWEB2.CameraOsdInfo} The camera OSD info
     * @internal
     * @ignore
     */
    EVWEB2.util.internal.formatOsdInfo = function(osd) {
        var osdInfo = new EVWEB2.CameraOsdInfo();

        osdInfo.position = osd.position;
        /* eslint-disable no-bitwise */
        osdInfo.name = Boolean(osd.display & EVWEB2.osdDisplay.name);
        osdInfo.time = Boolean(osd.display & EVWEB2.osdDisplay.time);
        osdInfo.date = Boolean(osd.display & EVWEB2.osdDisplay.date);
        osdInfo.timezone = Boolean(osd.display & EVWEB2.osdDisplay.timezone);
        /* eslint-enable no-bitwise */
        osdInfo.font = osd.fontName;
        osdInfo.fontSize = osd.fontSize;
        osdInfo.fontColor = osd.evFontColor;
        osdInfo.fontStyle = osd.evFontStyle;
        osdInfo.fontFamily = osd.evFontFamily;
        osdInfo.fontWeight = osd.evFontWeight;
        osdInfo.backgroundEnabled = osd.backgroundEnabled;
        osdInfo.backgroundColor = osd.backgroundColor;
        osdInfo.backgroundAlpha = osd.backgroundAlpha;

        return osdInfo;
    };

}());

/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * @class
     * Container object for a service version.
     * @param {Number} [major=0] The major component of a version.
     * @param {Number} [minor=0] The minor component of a version.
     * @param {Number} [build=0] The build component of a version.
     * @param {Number} [qfe=0] The QFE component of a version.
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceVersion = function(major, minor, build, qfe) {
        /**
         * The major component of a version
         * @type {number}
         */
        this.major = 0;

        /**
         * The minor component of a version
         * @type {number}
         */
        this.minor = 0;

        /**
         * The build component of a version
         * @type {number}
         */
        this.build = 0;

        /**
         * The QFE component of a version
         * @type {number}
         */
        this.qfe = 0;

        if(major !== undefined) {
            this.major = major;
        }
        if(minor !== undefined) {
            this.minor = minor;
        }
        if(build !== undefined) {
            this.build = build;
        }
        if(qfe !== undefined) {
            this.qfe = qfe;
        }

        /**
         * Converts the version to a string of the format MAJOR.MINOR.BUILD.QFE.
         * @returns {string} The version.
         */
        this.toString = function() {
            return this.major.toString() + '.' +
                (this.major >= 19 && this.minor < 10 ?
                    '0' + this.minor.toString() + '.'  :  + this.minor.toString() + '.') +
                this.build.toString() + '.' +
                this.qfe.toString();
        };

        /**
         * Compares whether the provided version is the same as this version
         * @param {EVWEB2.ServiceVersion} version The version to compare against.
         * @returns {boolean} Whether the versions are the same.
         */
        this.equals = function(version) {
            return this.major === version.major
                && this.minor === version.minor
                && this.build === version.build
                && this.qfe === version.qfe;
        };

        /**
         * Compares whether this version is less than the provided version.  Note: this does not
         * take into account equality.  If the versions are equal, the source version is not
         * less than the provided version and will return false.
         * @param {EVWEB2.ServiceVersion} version The version to compare against.
         * @returns {boolean} Whether this version is less than the provided version.
         */
        this.lessThan = function(version) {
            if(this.major < version.major) {
                return true;
            }
            if(this.major !== version.major) {
                return false;
            }

            if(this.minor < version.minor) {
                return true;
            }
            if(this.minor !== version.minor) {
                return false;
            }

            if(this.build < version.build) {
                return true;
            }
            if(this.build !== version.build) {
                return false;
            }

            return this.qfe < version.qfe;
        };

        /**
         * Compares whether this version is greater than the provided version.  Note: this does not
         * take into account equality.  If the versions are equal, the source version is not
         * greater than the provided version and will return false.
         * @param {EVWEB2.ServiceVersion} version The version to compare against.
         * @returns {boolean} Whether this version is greater than the provided version.
         */
        this.greaterThan = function(version) {
            if(this.major > version.major) {
                return true;
            }
            if(this.major !== version.major) {
                return false;
            }

            if(this.minor > version.minor) {
                return true;
            }
            if(this.minor !== version.minor) {
                return false;
            }

            if(this.build > version.build) {
                return true;
            }
            if(this.build !== version.build) {
                return false;
            }

            return this.qfe > version.qfe;
        };

        /**
         * Parses a string of the format MAJOR.MINOR.BUILD.QFE and populates the object with those values.
         * @param {String} versionString The version string to parse.
         * @return {boolean} Whether the parsing was successful.
         */
        this.populateFromString = function(versionString) {
            var stringValues = versionString.split('.');
            var values = $.map(stringValues, function(value) {
                var parsedValue = parseInt(value, 10);

                if(!isNaN(parsedValue)) {
                    return parsedValue;
                }
            });
            if(values.length !== 4) {
                return false;
            }
            this.major = values[0];
            this.minor = values[1];
            this.build = values[2];
            this.qfe = values[3];

            return true;
        };

    };

    /**
     * The service JPEG forwarding settings acts as a container for all JPEG forwarding-related information associated
     * with a service.
     *
     * JPEG forwarding is the process of requesting a native JPEG frame, if available, instead of a resized JPEG frame.
     * Using the native frame results in a larger file size, but reduces server load and decreases request processing
     * time.
     *
     * @param {Boolean} [enabled=false] Whether to enable JPEG forwarding
     * @param {Number} [sizeThreshold=100] The threshold percentage of the requested size before a camera should use
     * the native JPEG frame.
     * @param {Number} [qualityThreshold=100] The threshold percentage of the requested quality before the camera
     * should use the native JPEG frame.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceJpegForwardingSettings = function(enabled, sizeThreshold, qualityThreshold) {
        /**
         * Whether to enable JPEG forwarding (use of the native JPEG frame, if available, instead of a resized JPEG
         * frame) for all cameras on this service connection.  If enabled,
         * {@link EVWEB2.ServiceJpegForwardingSettings.sizeThreshold} and
         * {@link EVWEB2.ServiceJpegForwardingSettings.qualityThreshold} will be used to calculate whether a requested
         * frame should be the native JPEG frame.
         *
         * Note: This setting will apply even if requested aspect ratio is different than the native aspect ratio.  In
         * these situations, the black banding will not be applied.
         *
         * @type Boolean
         */
        this.enabled = false;

        /**
         * The threshold percentage of the requested size before a camera should use the native JPEG frame, if
         * available, instead of a scaled value.  This setting is used in tandem with
         * {@link EVWEB2.ServiceJpegForwardingSettings.qualityThreshold}, such that both must be applied before a
         * native JPEG frame is retrieved.
         *
         * For example, if a camera's native resolution is 640x480 with a forwarding threshold of 70, any requests that
         * are larger than 448x336 (640 * (70/100))x(480 * (70/100)) will be returned as the native frame.
         *
         * Note: This property is not used if {@link EVWEB2.ServiceJpegForwardingSettings.enabled} is set to false.
         *
         * @type Number
         */
        this.sizeThreshold = 100;

        /**
         * The threshold percentage of the requested quality before the camera should use the native JPEG frame, if
         * available, instead of a scaled value.  This setting is used in tandem with
         * {@link EVWEB2.ServiceJpegForwardingSettings.sizeThreshold}, such that both must be applied before a native
         * JPEG frame is retrieved.
         *
         * For example, if a camera's native quality is 5 with a forwarding quality threshold of 70, any requests that
         * have a quality above 3 (Math.floor(5 * (70/100))) will be returned as the native frame.
         *
         * Note: This property is not used if {@link EVWEB2.ServiceJpegForwardingSettings.enabled} is set to false.
         *
         * @type Number
         */
        this.qualityThreshold = 100;

        //Assign the constructor values
        if(typeof enabled !== 'undefined') {
            this.enabled = enabled;
        }
        if(typeof sizeThreshold !== 'undefined') {
            this.sizeThreshold = sizeThreshold;
        }
        if(typeof qualityThreshold !== 'undefined') {
            this.qualityThreshold = qualityThreshold;
        }

        /**
         * Determines whether a set of transcoding parameters are within the threshold to apply jpeg forwarding for a
         * particular camera.
         * @param {EVWEB2.Camera} camera The camera.
         * @param {Number} width The target transcode width.
         * @param {Number} height The target transcode height.
         * @param {Number} quality The target transcode quality (1-10).
         * @return {Boolean} Whether jpeg forwarding should be applied if these parameters are used to request a frame.
         */
        this.shouldForward = function(camera, width, height, quality) {
            if (camera.formats.indexOf(EVWEB2.cameraFormats.jpeg) === -1) {
                return false;
            }

            var sizeRatio = this.sizeThreshold / 100;
            return camera.quality * (this.qualityThreshold / 100) < quality &&
                (camera.resolution.width * sizeRatio < width || camera.resolution.height * sizeRatio < height);
        }
    };

    /**
     * The ConfigUpdateStatus object is a container for config update status information received from the web service.
     * @param {String} [sessionId=''] The session Id of the server.
     * @param {Date} [lastUpdated=new Date()] The timestamp of the last config update on the server.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ConfigUpdateStatus = function (sessionId, lastUpdated) {
        /**
         * The session Id of the server.
         * @type {String}
         */
        this.sessionId = '';

        /**
         * The timestamp of the last config update on the server.
         * @type {String}
         */
        this.lastUpdated = new Date();

        //Assign the constructor values
        if(sessionId !== undefined) {
            this.sessionId = sessionId;
        }

        if(lastUpdated !== undefined) {
            this.lastUpdated = lastUpdated;
        }
    };

    /**
     * Listing of web service versions associated with specific features.  This is
     * used primarily for feature checking when a fallback is available.
     * @type {{cors: EVWEB2.ServiceVersion}}
     * @private
     * @ignore
     */
    var serviceFeatureVersions = {
        cors: new EVWEB2.ServiceVersion(7, 6, 0)
    };

    /**
     * The service object is a container for a web service backend.
     * @param {String} [hostUrl=''] Web service base URL used if different than current URL.
     * @param {String} [subdirectory=''] Web service subdirectory on the current URL.
     * @param {String} [name='Unset'] Name of the server.
     * @param {String} [videoPushClientGuid] The VideoPush client GUID generated for this client.  This value is
     * created by the first call to {@link EVWEB2.VideoPush.updateClient} and should be saved and re-used for all
     * later instantiations of this client.  Note: The method {@link EVWEB2.VideoPush.setVideoPushClientGuid} is
     * provided to provide the same functionality after service construction.  This method does not need to be called
     * if specifying the GUID in this constructor or if the GUID is created in this session.
     * @param {String} [videoPushClientId] The VideoPush client ID generated for this client.  This value is
     * created by the first call to {@link EVWEB2.VideoPush.updateClient} and should be saved and re-used for all
     * later instantiations of this client.  Note: The method {@link EVWEB2.VideoPush.setVideoPushClientGuid} is
     * provided to provide the same functionality after service construction.  This method does not need to be called
     * if specifying the ID in this constructor or if the ID is created in this session.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.Service = function (hostUrl, subdirectory, name, videoPushClientGuid, videoPushClientId) {
        /**
         * Name of the service
         * @type String
         */
        this.name = 'Unset';

        /**
         * Host base URL
         * @type String
         */
        this.hostUrl = '';

        /**
         * Effective host URL. Set by {@link EVWEB2.Service.setUrl}.
         * @type String
         */
        this.effectiveUrl = '';

        /**
         * Host base subdirectory
         * @type String
         */
        this.subdirectory = '';

        /**
         * Internal Use Only. Ignores XSS settings and makes standard AJAX requests instead of JSONP.
         * @ignore
         * @type Boolean
         */
        this.ignoreXss = false;

        /**
         * Internal Use Only. The resource key for passthrough communication to prevent CSRF request.
         * @ignore
         * @type String
         */
        this.resourceKey = '';

        /**
         * Whether CSRF protection is enabled for the service.
         * @ignore
         * @type Boolean
         */
        this.csrf = true;

        /**
         * The JPEG forwarding settings for this service.  JPEG forwarding is disabled by default.
         * @type {EVWEB2.ServiceJpegForwardingSettings}
         */
        this.jpegForwarding = new EVWEB2.ServiceJpegForwardingSettings(false, 100, 100);

        /**
         * A reference to the service's {@link EVWEB2.VideoPush} instance.
         * @type {EVWEB2.VideoPush}
         */
        this.videoPush = new EVWEB2.VideoPush(videoPushClientGuid, videoPushClientId);

        /**
         * The push notification instance associated with this service.  This is used to register and
         * unregister clients for receiving push notifications.
         * @type {EVWEB2.PushNotification}
         */
        this.pushNotification = new EVWEB2.PushNotification(this);

        /**
         * The websocket connection associated with this service.
         * @type {EVWEB2.WebSocketHandler}
         * @deprecated Web Socket functionality has been removed from the web API in 9.6.0.  The default value for this
         * will be updated to EVWEB2.LegacyWebSocketHandler, which implements polling to retrieve any status
         * information.
         */
        this.websocket = new EVWEB2.WebSocketHandler(this);

        /**
         * The authorization instance associated with this service.  This is used to determine the
         * type of authentication used, as well as to authenticate for all requests to this service.
         * @type {EVWEB2.ServiceAuth}
         */
        this.auth = new EVWEB2.ServiceAuth(this);

        /**
         * Flag indicating whether the version number has been requested.
         * @private
         * @type {boolean}
         */
        var versionNumberRequested = false;

        /**
         * A reference to the service's configuration options.
         * @type {EVWEB2.ServiceConfig}
         */
        this.config = new EVWEB2.ServiceConfig(this);

        /**
         * Version number
         * @private
         * @type EVWEB2.ServiceVersion
         */
        var versionNumber = null;

        /**
         * Available version number
         * @private
         * @type EVWEB2.ServiceVersion
         */
        var availableVersionNumber = null;

        /**
         * Internal cached list of available input stream format types.  Used exclusively by
         * {@link EVWEB2.Service.audioInputFormatTypes}.
         * @private
         * @type {EVWEB2.audioInputStreamFormatTypes[]}
         */
        var availableAudioInputFormats = [];

        /**
         * The friendly name of the web service.  This is a cached value of the result of
         * a call to {@link EVWEB2.Service.friendlyName}.
         * @private
         * @type {String}
         */
        var friendlyName = '';

        //Assign the constructor values
        if(typeof name !== 'undefined') {
            this.name = name;
        }
        if(typeof hostUrl !== 'undefined' && hostUrl !== '') {
            // Verify and correct that the hostname ends in a slash
            if (hostUrl.substr(hostUrl.length-1) !== "/") {
                hostUrl += "/";
            }
            // Verify and correct that the hostname begins with a http declaration
            if (hostUrl.match(/^http[s]{0,1}:\/\//) === null) {
                hostUrl = "http://" + hostUrl;
            }

            this.hostUrl = hostUrl;
        }

        if(typeof subdirectory !== 'undefined' && subdirectory !== '') {
            if(this.hostUrl === '' && subdirectory.substr(0,1) !== '/') {
                subdirectory = '/' + subdirectory;
            }
            else if(this.hostUrl !== '' && subdirectory.substr(0,1) === '/') {
                subdirectory = subdirectory.substr(1);
            }
            // Verify and correct that the subdirectory ends in a slash
            if(subdirectory.length > 0 && subdirectory.substr(subdirectory.length -1) !== '/') {
                subdirectory += '/';
            }

            this.subdirectory = subdirectory;
        }

        /**
         * Sets the VideoPush client GUID and ID for this service instance.  These values are created by the first call to
         * {@link EVWEB2.VideoPush.updateClient} and should be saved and re-used for all later instantiations of this
         * client.  Note: This value can also be set via the {@link EVWEB2.Service} constructor and this function is
         * provided to provide the same functionality after service construction.  This method does not need to be
         * called if specifying the GUID in this constructor or if the GUID is created in this session.
         * @param {String} guid The generated VideoPush client GUID
         * @param {String} id The generated VideoPush client ID
         */
        this.setVideoPushClientGuid = function(guid, id) {
            this.videoPush = new EVWEB2.VideoPush(guid, id);
        };

        /**
         * Returns whether contacting the server is done via XSS or not.
         * @return Boolean
         */
        this.isXss = function() {
            return !this.ignoreXss && this.hostUrl !== '';
        };

        /**
         * Generates the full URL to be used when contacting the server.
         * @return String The full URL for the server.
         */
        this.url = function() {
            if (this.effectiveUrl !== '') {
                return this.effectiveUrl + this.subdirectory;
            }
            return this.hostUrl + this.subdirectory;
        };

        /**
         * EVWEB2.Service.setUrl allows a caller to override the network address originally provided in the
         * constructor. Future calls to EVWEB2.Service.url() will return the value set by this function. Outside
         * of object ref comparison, the service can still be uniquely identified by its original {@link this.hostUrl}
         * once an effective address has been set.
         * @param {String} url The effective url.
         */
        this.setUrl = function(url) {
            // Treat the incoming URL exactly as we do in the constructor, such that `service.url()` produces a result
            // massaged in a consistent manner (regardless of whether the underlying URL is the original or one set
            // after construction).
            if (url.substr(url.length - 1) !== '/') {
                url += '/';
            }
            if (url.match(/^http[s]{0,1}:\/\//) === null) {
                url = 'http://' + url;
            }

            this.effectiveUrl = url;
        };

        /**
         * EVWEB2.Service.resetUrl allows a caller to reset any previous network address override. Future
         * calls to EVWEB2.Service.url() will return the original host URL provided in the constructor.
         */
        this.resetUrl = function() {
            this.effectiveUrl = '';
        };

        /**
         * Retrieves the version number from the web service.  This can be used to determine supported features.
         * @param {Function} callback Callback function to be executed when the call completes. The function gets
         * passed a {@link EVWEB2.ResponseStatus} instance with the details of the response, the resulting version
         * number string, a {@link EVWEB2.ServiceVersion} instance of the version, and a {@link EVWEB2.ServiceVersion}
         * instance indicating the most recent available update version.
         * Note: If the most recent available update version can't be determined, this value will be "0.0.0.0".
         */
        this.version = function(callback) {

            var onVersionSuccess = function(data/*, textStatus, xhr*/) {
                versionNumber = new EVWEB2.ServiceVersion();
                availableVersionNumber = new EVWEB2.ServiceVersion();
                
                var dataVersionNumber = data;
                var dataAvailableVersionNumber;
                if(typeof data !== 'string') {
                    dataVersionNumber = data.version;
                    dataAvailableVersionNumber = data.availableVersion;
                }

                if(!versionNumber.populateFromString(dataVersionNumber)) {
                    versionNumber = null;
                    availableVersionNumber = null;
                    var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred processing the version.');
                    callback(errorResponse);
                    return;
                }

                if(dataAvailableVersionNumber === undefined || !availableVersionNumber.populateFromString(dataAvailableVersionNumber)) {
                    availableVersionNumber = new EVWEB2.ServiceVersion();
                }
                
                //Return the version number
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, versionNumber.toString(), versionNumber, availableVersionNumber);
            };

            var onVersionError = function(xhr/*, textStatus, errorThrown*/) {
                if(xhr.status === 404 || (xhr.status === 0 && xhr.statusText === 'timeout')) {
                    // Web service v2 does not expose version.web.  Assume all 404 version calls
                    // are a 2.0 service.
                    var versionResponse = {
                        version: '2.0.0.0'
                    };
                    onVersionSuccess(versionResponse);
                    return;
                }

                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };


            //If the version number has already been retrieved, return the cached version.
            if((versionNumber !== null) && (availableVersionNumber !== null)) {
                onVersionSuccess({
                    version: versionNumber.toString(),
                    success: true,
                    availableVersion: availableVersionNumber.toString()
                });
                return;
            }

            var settings = {
                success: onVersionSuccess,
                error: onVersionError,
                url: this.url() + EVWEB2.urls.version,
                data: {
                    output: 'json'
                }
            };

            versionNumberRequested = true;
            EVWEB2.ajax(settings, this);
        };

        /**
         * Determines whether or not the service supports CORS requests, which were added in 7.6.
         * Since we have no way to know until we have the version (which, in itself requires a request
         * that may not be CORS), we must return false initially and then request the version.  Afterwards,
         * we can definitively respond.
         * @return {Boolean} Whether CORS support is currently available for communication with the web service.
         */
        this.supportsCors = function() {
            if(versionNumber !== null) {
                return !versionNumber.lessThan(serviceFeatureVersions.cors);
            }
            if(!versionNumberRequested) {
                // Request the version to populate it for future requests.
                this.version($.noop);
            }
            return false;
        };

        /**
         * Internal Use Only. Sets the resource key for passthrough communication to prevent CSRF requests.
         * @ignore
         * @type String
         */
        this.setResourceKey = function (key) {
            this.resourceKey = key;
        };

        /**
         * Internal Use Only. Retrieves a resource key for passthrough communication to prevent CSRF requests.  Upon
         * retrieving the key, sets the {@link EVWEB2.Service.resourceKey} to the new value.
         * @ignore
         * @deprecated This endpoint has been deprecated and will always return a dummy key value.
         * @param {Function} callback Callback function to be executed when the call completes. The function gets
         * passed a {@link EVWEB2.ResponseStatus} instance with the details of the response and the resulting resource
         * key.
         */
        this.getResourceKey = function(callback) {
            var service = this;

            /**
             * Callback function for resource key request error
             * @ignore
             */
            var onGetResourceKeyError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            /**
             * Callback function for resource key request success
             * @ignore
             * @param data
             */
            var onGetResourceKeySuccess = function(data/*, textStatus, xhr*/) {
                var key = '';
                if(typeof data === 'string') {
                    key = data.replace(/^key=/,'');
                }
                else {
                    key = data.key;
                }
                if(typeof key === 'undefined' || key === '-1') {
                    onGetResourceKeyError();
                    return;
                }
                service.resourceKey = key;
                //Return the server list
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, service.resourceKey);
            };

            var settings = {
                success: onGetResourceKeySuccess,
                error: onGetResourceKeyError,
                url: this.url() + EVWEB2.urls.resourceKey
            };

            if(this.isXss()) {
                settings.data = {
                    output: 'json'
                };
            }
            EVWEB2.ajax(settings, this);
        };

        /**
         * The getServers function is the initial function for interaction with the exacqVision web service.  It
         * is used to request for the available servers on the backend web server for the web service.  This
         * list is based on the servers provided upon installation of the web service.
         *
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         *  {@link EVWEB2.Server} instances attached to the web service.
         */
        this.getServers = function (callback) {
            var service = this;
            var onGetServersError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                if(typeof xhr !== 'undefined' && xhr.status === 0 && xhr.statusText === 'timeout') {
                    errorResponse.errorText = "XSS request timeout.";
                }
                callback(errorResponse);
            };

            var onGetServersSuccess = function(data/*, textStatus, xhr*/) {
                if(data === EVWEB2.errors.servers) {
                    //Call the error callback
                    onGetServersError();
                    return;
                }

                // v2.0 web services don't return a proper JSON object, as no callback wraps the response.  For these
                // responses, attempt to manually parse the JSON.
                if(typeof data === 'string') {
                    try {
                        data = JSON.parse(data);
                    }
                    catch(err) {
                        onGetServersError();
                        return;
                    }
                }

                var resultList = data.list;

                var serverList = $.map(resultList, function(element) {
                    var serverId = element.id;

                    if(typeof serverId !== 'undefined') {
                        serverId = serverId.toString();
                    }

                    var serverInfo = EVWEB2.util.internal.processServerDetails(element);
                    var licenseInfo = EVWEB2.util.internal.processServerLicense(element);

                    var customGroupPermissions;
                    var passthroughGroup;

                    if (element.group !== undefined && element.group !== null) {
                        var group = element.group;

                        var passthroughPermissions = EVWEB2.util.internal.processUserGroupPermissions(group.permissions);

                        customGroupPermissions = new EVWEB2.CustomGroupPermissions(group.cameras, group.audios, group.serials, group.softTriggers);
                        passthroughGroup = new EVWEB2.UserGroup(group.name, group.role, passthroughPermissions, group.priorities, group.guid, customGroupPermissions);

                    }
                    else {
                        passthroughGroup = EVWEB2.util.processServerPermissions(element);
                    }

                    return new EVWEB2.Server(service, element.name, serverId, element.login, element.restricted,
                                             undefined, undefined, undefined, serverInfo, licenseInfo, undefined, passthroughGroup,
                                             element.managedFeatures, element.canAutoLogin);

                });

                if(typeof data.CSRF !== 'undefined') {
                    service.csrf = data.CSRF;
                }
                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the server list
                callback(successResponse, serverList);
            };

            var settings = {
                success: onGetServersSuccess,
                error: onGetServersError,
                url: this.url() + EVWEB2.urls.getServerList,
                data: {
                    output: 'json'
                }
            };

            EVWEB2.ajax(settings, this);
        };

        /**
         * Recursively parses the folder object returned from the web service into an array of {@link EVWEB2.ViewFolder}
         * instances.
         * @private
         * @param {Object} folderObj The folder object returned from the web service.
         * @param {String} folderName The name of the folder.
         * @param {String} parentId The parent folder's ID.
         * @return {EVWEB2.ViewFolder[]} The view folders
         */
        var parseFolders = function (folderObj, folderName, parentId) {
            var folders = [];
            if(typeof parentId === 'undefined') {
                parentId = folderObj.id;
            }
            folders.push(new EVWEB2.ViewFolder(folderObj.id, folderName, parentId));
            if (folderObj.folders !== null) {
                var name;
                for (name in folderObj.folders) {
                    if(folderObj.folders.hasOwnProperty(name)) {
                        var subFolders = parseFolders(folderObj.folders[name], name, folderObj.id);
                        folders = folders.concat(subFolders);
                    }
                }
            }
            return folders;
        };

        /**
         * Parses a view layout info response into a {@link EVWEB2.Layout} instance.
         * @private
         * @param {Object} layoutInfoResponse The response object to process.
         * @return {EVWEB2.Layout} The layout
         */
        var processViewLayoutResponse = function(layoutInfoResponse) {
            var layout;
            if(typeof layoutInfoResponse !== 'undefined') {
                var slots = $.map(layoutInfoResponse.slots, function(element) {
                    return new EVWEB2.LayoutSlot(element.y, element.x, element.width, element.height);
                });
                layout = new EVWEB2.Layout(layoutInfoResponse.name, layoutInfoResponse.width,
                    layoutInfoResponse.height, layoutInfoResponse.length, slots, undefined,
                    layoutInfoResponse.widescreen);
            }
            return layout;
        };

        /**
         * Generates a grep function for finding a server associated with a view response.
         * @private
         * @param {String} serverId The server ID associated.
         * @return {Function} The grep function
         */
        var generateServerGrep = function(serverId) {
            return function(viewResponse) {
                return viewResponse.id === serverId;
            };
        };

        /**
         * Parses a view audio input response into a {@link EVWEB2.ViewAudioInputInfo} instance.
         * @private
         * @param {Object} viewResponse The response object to process.
         * @param {EVWEB2.Server[]} servers The servers associated with the views.
         * @return {EVWEB2.ViewAudioInputInfo} The audio input
         */
        var processViewAudioInputResponse = function(viewResponse, servers) {
            var audioInput;
            if(typeof viewResponse.audioInput !== 'undefined' && viewResponse.audioInput !== null) {
                var audioInputServer = $.grep(servers, function(server) {
                    // Note: This check for session ID is due to an implementation issue
                    // in legacy services (pre-8.2) where the server property of the deprecated
                    // audioInput flag was incorrectly set to the session ID.  Additionally, the
                    // session ID was not set to the proper hex representation.
                    var sessionId = viewResponse.audioInput.server;
                    if(sessionId.substr(0,2) !== '0x') {
                        sessionId = '0x' + parseInt(sessionId, 10).toString(16);
                    }

                    return viewResponse.audioInput.server === server.id ||
                        sessionId === server.sessionId;
                })[0];
                audioInput = new EVWEB2.ViewAudioInputInfo(viewResponse.audioInput.id, audioInputServer);
            }
            return audioInput;
        };

        /**
         * Parses a view response into a {@link EVWEB2.View} instance.
         * @private
         * @param {Object} viewResponse The response object to process.
         * @param {EVWEB2.Server[]} servers The servers associated with the views.
         * @param {EVWEB2.ViewFolder[]} folders The folders associated with the views.
         * @return {EVWEB2.View} The view
         */
        var processViewResponse = function(viewResponse, servers, folders) {
            // Generate View objects
            var layout = processViewLayoutResponse(viewResponse.layout_info);

            // Create the list of ViewSlotItem objects
            var viewItemList = $.map(viewResponse.items, function(element/*, index*/) {
                var server = $.grep(servers, generateServerGrep(element.server))[0];

                var type = null;
                if(element.type === EVWEB2.ViewSlotItemTypes.camera) {
                    type = EVWEB2.Camera;
                }
                else if(element.type === EVWEB2.ViewSlotItemTypes.group) {
                    type = EVWEB2.Map;
                }
                else if(element.type === EVWEB2.ViewSlotItemTypes.audio) {
                    type = EVWEB2.AudioDevice;
                }

                return new EVWEB2.ViewSlotItem(element.id, server, type, element.slot, element.digitalPtzType);
            });

            // Find the view folder for the view
            var viewFolder = $.grep(folders, function(vf) {
                return vf.id === viewResponse.folder;
            })[0];

            var audioInput = processViewAudioInputResponse(viewResponse, servers);

            return new EVWEB2.View(viewResponse.name, viewFolder, viewItemList, viewResponse.layout, layout,
                                    viewResponse.order, audioInput, viewResponse.description, viewResponse.id);
        };

        /**
         * Parses a legacy view response into a {@link EVWEB2.View} instance.  Legacy responses are those that only
         * expose the deprecated "camera" property, not the current "items" property.
         * @private
         * @param {Object} viewResponse The response object to process.
         * @param {EVWEB2.Server[]} servers The servers associated with the views.
         * @param {EVWEB2.ViewFolder[]} folders The folders associated with the views.
         * @return {EVWEB2.View} The view
         */
        var processLegacyViewResponse = function(viewResponse, servers, folders) {
            // Generate View objects
            var layout = processViewLayoutResponse(viewResponse.layout_info);

            // Create the list of ViewCameraInfo objects
            var viewCameraInfoList = [];
            var i;
            for(i=0; i<viewResponse.cameras.length; i++) {
                var viewCameraInfo = null;
                var serverData = viewResponse.cameras[i];
                if(serverData !== null) {
                    var server = $.grep(servers, generateServerGrep(serverData.server))[0];
                    viewCameraInfo = new EVWEB2.ViewCameraInfo(serverData.camera, server, serverData.digitalPtzType);
                }
                viewCameraInfoList.push(viewCameraInfo);
            }

            // Find the view folder for the view
            var viewFolder = $.grep(folders, function(vf) {
                return vf.id === viewResponse.folder;
            })[0];

            var audioInput = processViewAudioInputResponse(viewResponse, servers);

            return new EVWEB2.View(viewResponse.name, viewFolder, viewCameraInfoList, viewResponse.layout, layout,
                                    viewResponse.order, audioInput, viewResponse.description);
        };

        /**
         *  The getViews function retrieves the server side views from the exacqVision servers.
         *  @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *   {@link EVWEB2.ResponseStatus} instance with the details of the response, an array of {@link EVWEB2.View}
         *   instances, and an array of {@link EVWEB2.ViewFolder} instances.
         *  @param {EVWEB2.Server|EVWEB2.Server[]} servers A single {@link EVWEB2.Server} instance or an array of
         *  {@link EVWEB2.Server} instances
         */
        this.getViews = function(callback, servers) {
            if(!$.isArray(servers)) {
                servers = [servers];
            }

            var onGetViewsError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onGetViewsSuccess = function(data/*, textStatus, xhr*/) {
                var folders = parseFolders(data.Folders, "");

                // Generate View objects
                var viewsList = $.map(data.Views, function(element) {
                    if(typeof element.items !== 'undefined') {
                        return processViewResponse(element, servers, folders);
                    }
                    else {
                        return processLegacyViewResponse(element, servers, folders);
                    }
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the server list
                callback(successResponse, viewsList, folders);
            };

            var data = {
                s: $.map(servers, function(element) {
                    return element.sessionId;
                })
            };

            var serversRequiringKey = $.grep(servers, function(element) {
                return element.isPassthroughServer() && element.service.isXss();
            });

            var settings = {
                success: onGetViewsSuccess,
                error: onGetViewsError,
                url: servers[0].service.url() + EVWEB2.urls.getViewList,
                data: data,
                traditional: true
            };

            if(serversRequiringKey.length > 0) {
                if(this.resourceKey === '') {
                    throw new Error("CSRF enforced, passthrough will not work.");
                }
                settings.data.key = this.resourceKey;
            }

            EVWEB2.ajax(settings, this);
        };

        /**
         * Parses a map response into a {@link EVWEB2.Map} instance.
         * @private
         * @param {Object} mapResponse The response object to process.
         * @param {EVWEB2.Server[]} servers The servers associated with the views.
         * @param {Boolean} [legacy=true] legacy determines whether or not to use legacy maps functionality
         * @return {EVWEB2.Map} The map
         */
        var processMapResponse = function(mapResponse, servers, legacy) {
            var itemList = $.map(mapResponse.items, function(element) {
                var captionInfo = new EVWEB2.MapItemCaptionInfo(element.caption, element.color);

                return new EVWEB2.MapItemInfo(element.id, element.server, element.type, element.shape, element.x,
                    element.y, captionInfo, element.rotation, element.flags);
            });
            if(legacy === true) {
                var mapServers = $.grep(servers, function(element) {
                    return element.sessionId.toString() === mapResponse.rootServer.toString();
                });
            } else {
                var mapServers = $.grep(servers, function(element) {
                    for(var i = 0; i < mapResponse.servers.length; i++) {
                        if(element.sessionId.toString() === mapResponse.servers[i].toString()) {
                            return true;
                        }
                    }
                    return false;
                });
            }

            return new EVWEB2.Map(mapServers[0].service, mapResponse.id, mapServers[0], mapResponse.parent, mapResponse.name,
                mapResponse.description, itemList, mapServers);
        };

        /**
         *  The getMaps function retrieves and combines the server side maps from the exacqVision servers.
         *  @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response, an array of {@link EVWEB2.Map}
         *  instances.
         *  @param {EVWEB2.Server|EVWEB2.Server[]} servers A single {@link EVWEB2.Server} instance or an array of
         *  {@link EVWEB2.Server} instances
         *  @param {Boolean} [legacy=true] legacy determines whether or not to use legacy maps functionality
         */
        this.getMaps = function(callback, servers, legacy) {
            var isLegacy = true
            if(typeof legacy === 'boolean') {
                isLegacy = legacy
            }
            if(!$.isArray(servers)) {
                servers = [servers];
            }
            var onGetMapsError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onGetMapsSuccess = function(data/*, textStatus, xhr*/) {
                // Generate Maps objects
                var mapsList = $.map(data.maps, function(element) {
                    if(typeof element.items !== 'undefined') {
                        return processMapResponse(element, servers, isLegacy);
                    }
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the maps list
                callback(successResponse, mapsList);
            };

            var data = {
                s: $.map(servers, function(element) {
                    return element.sessionId;
                }),
                legacy: isLegacy,
                output: 'json'
            };

            var settings = {
                success: onGetMapsSuccess,
                error: onGetMapsError,
                url: this.url() + EVWEB2.urls.map,
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, this);
        };

        /**
         * Parses a group response into a {@link EVWEB2.Group} instance.
         * @private
         * @param {Object} groupResponse The response object to process.
         * @return {EVWEB2.Group} The group
         */
        var processGroupResponse = function(groupResponse/*, servers*/) {
            var itemList = $.map(groupResponse.items, function(element) {
                return new EVWEB2.GroupItemInfo(element.id, element.server, element.type);
            });
            return new EVWEB2.Group(groupResponse.id, groupResponse.name,
                groupResponse.description, groupResponse.icon, itemList);
        };

        /**
        * Retrieves and combines the server side groups from the specified servers.
        *
        * @param {Function} callback Callback function to be executed when the call
        * completes. Callback is passed a {@link EVWEB2.ResponseStatus} instance with
        * the details of the response and an array of {@link EVWEB2.Group} instances.
        * @param {EVWEB2.Server|EVWEB2.Server[]} servers A single {@link EVWEB2.Server}
        * instance or an array of {@link EVWEB2.Server} instances.
        */
        this.getGroups = function (callback, servers) {
            if(!$.isArray(servers)) {
                servers = [servers];
            }
            var onGetGroupsError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onGetGroupsSuccess = function(data/*, textStatus, xhr*/) {
                // Generate Groups objects
                var groupsList = $.map(data.groups, function(element) {
                    if(typeof element.items !== 'undefined') {
                        return processGroupResponse(element);
                    }
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the groups list
                callback(successResponse, groupsList);
            };

            var data = {
                s: $.map(servers, function(element) {
                    return element.sessionId;
                }),
                output: 'json'
            };

            var settings = {
                success: onGetGroupsSuccess,
                error: onGetGroupsError,
                url: this.url() + EVWEB2.urls.groups,
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, this);
        };

        /**
         * Recursively parses the folder object returned from the web service into an array of
         * {@link EVWEB2.TourFolder} instances.
         * @private
         * @param {Object} folderObj The folder object returned from the web service.
         * @param {String} folderName The name of the folder.
         * @param {String} parentId The parent folder's ID.
         * @return {EVWEB2.TourFolder[]} The tour folders
         */
        var parseTourFolders = function (folderObj, folderName, parentId) {
            var folders = [];
            if(typeof parentId === 'undefined') {
                parentId = folderObj.id;
            }
            folders.push(new EVWEB2.TourFolder(folderObj.id, folderName, parentId));
            var i;
            for(i=0; i<folderObj.folders.length; i++) {
                var subFolders = parseTourFolders(folderObj.folders[i], folderObj.folders[i].name, folderObj.id);
                folders = folders.concat(subFolders);
            }
            return folders;
        };

        /**
         *  The getTours function retrieves the server side tours from the exacqVision servers.
         *  @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *   {@link EVWEB2.ResponseStatus} instance with the details of the response, an array of {@link EVWEB2.Tour}
         *   instances, and an array of {@link EVWEB2.TourFolder} instances.
         *  @param {EVWEB2.Server|EVWEB2.Server[]} servers A single {@link EVWEB2.Server} instance or an array of
         *  {@link EVWEB2.Server} instances.
         */
        this.getTours = function(callback, servers) {
            if(!$.isArray(servers)) {
                servers = [servers];
            }

            var instance = this;

            var onGetToursError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onGetToursSuccess = function(data/*, textStatus, xhr*/) {
                var folders = parseTourFolders(data.folders, "");

                // Generate tour objects
                var tours = $.map(data.tours, function(element) {

                    // Create the list of TourItem objects
                    var tourItems = $.map(element.views, function(el/*, index*/) {
                        return new EVWEB2.TourItem(el.index, el.dwell, el.view);
                    });

                    // Find the folder for the tour
                    var folder = $.grep(folders, function(vf) {
                        return vf.id === element.folder_id;
                    })[0];

                    return new EVWEB2.Tour(element.name, folder, tourItems, element.description, instance);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the server list
                callback(successResponse, tours, folders);
            };

            var data = {
                s: $.map(servers, function(element) {
                    return element.sessionId;
                })
            };

            var settings = {
                success: onGetToursSuccess,
                error: onGetToursError,
                url: servers[0].service.url() + EVWEB2.urls.tours,
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, this);
        };

        /**
         * Get the types of audio formats supported for the service
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.audioInputStreamFormatTypes}.
         */
        this.audioInputFormatTypes = function (callback) {
            if(availableAudioInputFormats.length > 0) {
                callback(new EVWEB2.ResponseStatus(true), availableAudioInputFormats);
                return;
            }

            var onAudioInputFormatTypesError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onAudioInputFormatTypesSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                availableAudioInputFormats = data.formats;
                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the server list
                callback(successResponse, availableAudioInputFormats);
            };

            var settings = {
                success: onAudioInputFormatTypesSuccess,
                error: onAudioInputFormatTypesError,
                url: this.url() + EVWEB2.urls.audio
            };

            EVWEB2.ajax(settings, this);
        };

        /**
         * Get the types of video export formats available for the service
         * @param {Function} callback Callback function to be executed when the call
         * completes. Callback is passed a {@link EVWEB2.ResponseStatus} instance and
         * an array of {@link EVWEB2.videoExportFormatTypes} detailing the available
         * video export formats.
         */
        this.videoExportFormatTypes = function (callback) {
            var onVideoExportFormatTypesErrors = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onVideoExportFormatTypesSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.formatTypes);
            };

            var settings = {
                success: onVideoExportFormatTypesSuccess,
                error: onVideoExportFormatTypesErrors,
                url: this.url() + EVWEB2.urls.videoexport,
                data: {
                    output: 'json'
                }
            };

            EVWEB2.ajax(settings, this);
        };

        /**
         * Retrieves the overall status for the provided server.
         * @param {function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.ServerStatus} instances,
         *  which detail the overall status of each server.
         * @param {EVWEB2.Server[]} servers The target servers
         */
        this.getServersStatus = function (callback, servers) {
            var onGetServerStatusError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onGetServerStatusSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var statuses = $.map(data.statuses, function(element) {
                    var server = $.grep(servers, function(serv) {
                        return serv.sessionId.toString() === element.sessionId.toString();
                    })[0];
                    return new EVWEB2.ServerStatus(server, element.loss, element.motion, element.alarm, element.serverStatus);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, statuses);
            };

            var params = {
                s: $.map(servers, function(element) {
                    return element.sessionId;
                })
            };

            var settings = {
                success: onGetServerStatusSuccess,
                error: onGetServerStatusError,
                url: this.url() + EVWEB2.urls.status,
                data: params,
                traditional: true
            };

            EVWEB2.ajax(settings, this);
        };


        /**
         * Get the health of the web service including uptime and basic information about current server connections
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed
         * a {@link EVWEB2.ResponseStatus} instance with the details of the response and a {@link EVWEB2.ServiceHealth}
         * instance.
         */
        this.getHealth = function(callback){
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data /*, textStatus, xhr*/){
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(data.success, data.errorText);
                var servers = [];
                // response signature including servers was deprecated, should always be empty 9.2.0+
                servers = $.map(data.servers, function (elem) {
                    var server =  new EVWEB2.ServerHealth(elem.serverID, elem.serverAddress,
                        elem.liveConnections, elem.searchConnections, elem.passthroughError,
                        elem.users);

                    // Stream info was added in 7.7.5700
                    if(elem.streams !== undefined) {
                        server.streams = new EVWEB2.ServerHealthStreamInfo(server.serverID,
                            elem.streams.compressed, elem.streams.uncompressed);
                    }
                    return server;
                });

                var streamInfo;
                if (data.streams !== undefined) {
                    streamInfo = new EVWEB2.ServiceHealthStreamInfo(data.streams.compressed, data.streams.uncompressed);
                }

                // Version and OS info were added in 7.1.8, so check to ensure they are present when
                // processing the request.
                var versionInfo;
                if(data.version !== undefined) {
                    versionInfo = new EVWEB2.ServiceHealthVersionInfo(data.version.service, data.version.evapi,
                        data.version.webServer);
                }

                var osInfo;
                if(data.os !== undefined) {
                    osInfo = new EVWEB2.ServiceHealthOsInfo(data.os.system, data.os.release, data.os.version,
                        data.os.machine, data.os.processor, data.os.node);
                }

                // Process and System info were added in 7.7.5700, so check to ensure they are present when
                // processing the request
                var processInfo;
                if(data.processes !== undefined) {
                    processInfo = $.map(data.processes, function(element) {
                        return new EVWEB2.ServiceHealthProcessInfo(element.name, element.cpu, element.ram, 
                            element.serverId);
                    });
                }

                var systemInfo;
                if(data.system !== undefined) {
                    systemInfo = new EVWEB2.ServiceHealthSystemInfo(data.system.cores, data.system.memory.total,
                        data.system.memory.available, data.system.cpu);
                }

                // Prepare the full health object
                var serviceHealth = new EVWEB2.ServiceHealth(data.uptime, servers, versionInfo, osInfo,
                    processInfo, systemInfo, streamInfo);
                callback(successResponse, serviceHealth);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: this.url() + EVWEB2.urls.health,
                data: {}
            };
            if(this.config.authToken !== null) {
                settings.data.auth = this.config.authToken;
            }

            EVWEB2.ajax(settings, this);

        };

        /**
         * Get the timestamp of the last config update on each connected server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.ConfigUpdateStatus} instances.
         * @param {EVWEB2.Server|EVWEB2.Server[]} servers A single {@link EVWEB2.Server} instance or an array of
         * {@link EVWEB2.Server} instances
         */

        this.getConfigUpdateStatus = function(callback, servers) {
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onGetConfigUpdateError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetConfigUpdateSuccess = function(data/*, textStatus, xhr*/) {
                var successResponse = new EVWEB2.ResponseStatus(true);
                var configStatuses = $.map(data.statuses, function(element) {
                    var lastUpdated = EVWEB2.util.IETF2Date(element.config.lastUpdated);

                    return new EVWEB2.ConfigUpdateStatus(element.sessionId, lastUpdated);
                });
                callback(successResponse, configStatuses);
            };

            var ids = $.map(servers, function(elem) {
                return elem.sessionId.toString();
            });
            var params = {
                's': ids
            };

            var settings = {
                success: onGetConfigUpdateSuccess,
                error: onGetConfigUpdateError,
                url: this.url() + EVWEB2.urls.configUpdateStatus,
                data: params,
                traditional: true
            };

            EVWEB2.ajax(settings, this);
        };


        /**
         * Retrieves the event monitoring profiles for the provided servers.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.Server.ResponseStatus} instance and an array of {@link EVWEB2.EventMonitorProfile} instances.
         * @param {EVWEB2.Server[]} servers The servers to to retrieve associated event monitoring profiles.
         */
        this.getEventMonitorProfiles = function(callback, servers) {
            if(!$.isArray(servers)) {
                servers = [servers];
            }

            var instance = this;

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                // Generate event monitoring profiles
                var profiles = $.map(data.profiles, function(element) {
                    var profile = new EVWEB2.EventMonitorProfile(instance, element.name, element.type, element.description,
                        element.showEventsList, element.showNewestEvent);

                    profile.events = $.map(element.events, function(event) {
                        var source = event.source;
                        var linkSource = new EVWEB2.EventMonitorLinkSource();
                        if(source !== null) {
                            linkSource = new EVWEB2.EventMonitorLinkSource(source.server, source.id, source.type,
                                source.extra, source.any);
                        }

                        var target = event.target;
                        var linkTarget = new EVWEB2.EventMonitorLinkTarget();
                        if(target !== null) {
                            linkTarget = new EVWEB2.EventMonitorLinkTarget(target.server, target.value, target.type,
                                target.extra, target.folders);
                        }

                        return new EVWEB2.EventMonitorLink(instance, profile, event.guid, linkSource, linkTarget,
                            event.priority, event.confirm, event.timeout, event.message);
                    });
                    return profile;
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the server list
                callback(successResponse, profiles);
            };

            var data = {
                s: $.map(servers, function(element) {
                    return element.sessionId;
                })
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.url() + EVWEB2.urls.eventMonitoring,
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, this);
        };

        /**
         * Creates an event monitoring profile.  Note: a profile must have one (and only one)
         * {@link EVWEB2.EventMonitorLink} assigned since profiles without at least one event link are considered marked
         * for deletion.  If multiple event links are provided in the profile, only the first will be submitted.  All
         * others must be added through {@link EVWEB2.EventMonitorProfile.addLink}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.Server.ResponseStatus} instance and a modified instance of the provided
         * {@link EVWEB2.EventMonitorProfile}.
         * @param {EVWEB2.EventMonitorProfile} profile The event monitor profile to add.
         */
        this.createEventMonitorProfile = function(callback, profile) {
            var instance = this;

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                // Update the event monitoring profile
                var serverProfile = data.profile;
                profile.name = serverProfile.name;
                profile.type = serverProfile.type;
                profile.description = serverProfile.description;
                profile.showEventsList = serverProfile.showEventsList;
                profile.showNewest = serverProfile.showNewestEvent;

                // Update the events
                profile.events = $.map(serverProfile.events, function(event) {
                    var source = event.source;
                    var linkSource = new EVWEB2.EventMonitorLinkSource();
                    if(source !== null) {
                        linkSource = new EVWEB2.EventMonitorLinkSource(source.server, source.id, source.type,
                            source.extra, source.any);
                    }

                    var target = event.target;
                    var linkTarget = new EVWEB2.EventMonitorLinkTarget();
                    if(target !== null) {
                        linkTarget = new EVWEB2.EventMonitorLinkTarget(target.server, target.value, target.type,
                            target.extra, target.folders);
                    }

                    return new EVWEB2.EventMonitorLink(instance, profile, event.guid, linkSource, linkTarget,
                        event.priority, event.confirm, event.timeout, event.message);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, profile);
            };

            var link = profile.events[0];
            if(link === undefined) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No event link specified for profile.');
                callback(errorResponse);
            }

            var params = {
                name: profile.name,
                description: profile.description,
                type: profile.type,
                showEventsList: profile.showEventsList,
                showNewestEvent: profile.showNewest,
                eventConfirm: link.confirm,
                eventMessage: link.message,
                eventTimeout: link.timeout,
                eventPriority: link.priority
            };

            if(link.source !== null) {
                params.eventSourceId = link.source.id;
                params.eventSourceServer = link.source.server;
                params.eventSourceType = link.source.type;
                params.eventSourceAny = link.source.any;
                if (link.source.extraId.length > 0) {
                    params.eventSourceExtra = link.source.extraId;
                }

            }
            else {
                params.eventSourceServer = link.target.server;
                params.eventSourceType = EVWEB2.EventMonitorLinkSourceTypes.None;
            }
            if(link.target !== null) {
                params.eventTargetValue = link.target.value;
                params.eventTargetServer = link.target.server;
                params.eventTargetType = link.target.type;
                params.eventTargetFolders = link.target.folders;
                if (link.target.extraId.length > 0) {
                    params.eventTargetExtra = link.target.extraId;
                }
            }
            else {
                params.eventTargetServer = link.source.server;
                params.eventTargetType = EVWEB2.EventMonitorLinkTargetTypes.None;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.url() + EVWEB2.urls.eventMonitoring,
                type: 'POST',
                data: params
            };

            EVWEB2.ajax(settings, this);
        };

        /**
         * Retreive the list of cases from a list of servers
         * @param {Function} callback Callback function to be executed when the call completes. Callback
         * is passed a {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.Case} instances.
         * @param {EVWEB2.Server[]} servers Array of servers to retrieve cases for.
         */
        this.getCases = function(callback, servers) {
            var instance = this;
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var cases = $.map(data.cases, function(element) {
                    var caseServers = $.grep(servers, function(el) {
                        return $.inArray(el.sessionId.toString(), element.servers) !== -1;
                    });
                    return new EVWEB2.Case(caseServers, element.guid, element.name, element.description,
                        element.bookmarks);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, cases);
            };

            var data = {
                s: $.map(servers, function(element) {
                    return element.sessionId;
                })
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.url() + EVWEB2.urls.bookmarkCases,
                type: 'GET',
                data: data,
                traditional: true
            };

            if(this.isXss()) {
                EVWEB2.util.updateRequestForXss(settings, this);
            }
            EVWEB2.ajax(settings, this);
        };


        /**
         * Create a new case.
         * @param {Function} callback Callback function to be executed when the call completes. Callback
         * is passed a {@link EVWEB2.ResponseStatus} instance and an {@link EVWEB2.Case} instance.
         * @param {EVWEB2.Case} newCase The new case to create.  Note: {@link EVWEB2.Case.guid} is ignored by this
         * method and can be left blank.  The generated case will have a new guid applied.
         */
        this.createCase = function(callback, newCase) {
            var instance = this;

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var caseInfo = data['case'];
                var caseServers = $.grep(newCase.servers, function(el) {
                    return $.inArray(el.sessionId.toString(), caseInfo.servers) !== -1;
                });
                var bookmarkCase = new EVWEB2.Case(caseServers, caseInfo.guid, caseInfo.name, caseInfo.description,
                    caseInfo.bookmarks);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, bookmarkCase);
            };

            var data = {
                s: $.map(newCase.servers, function(element) {
                    return element.sessionId;
                }),
                name: newCase.name
            };

            if(newCase.description !== undefined) {
                data.description = newCase.description;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.url() + EVWEB2.urls.bookmarkCases,
                type: 'POST',
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, this);
        };

        /**
         * Retreive the list of bookmarks from a list of servers
         * @param {Function} callback Callback function to be executed when the call completes. Callback
         * is passed a {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.Bookmark} instances.
         * @param {EVWEB2.Server[]} servers Array of servers to retrieve cases for.
         */
        this.getBookmarks = function(callback, servers) {
            var instance = this;
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var serverMap = {};
                $.each(servers, function(index, element) {
                    serverMap[element.sessionId] = element;
                });

                var bookmarks = $.map(data.bookmarks, function(element) {
                    var items = $.map(element.items, function(el) {
                        return new EVWEB2.BookmarkItem(serverMap[el.server], el.id, el.type);
                    });
                    var start = EVWEB2.util.IETF2Date(element.start);
                    var end = EVWEB2.util.IETF2Date(element.end);

                    return new EVWEB2.Bookmark(element.name, element.guid, start, end, items, element.description,
                        element.size, element['case']);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, bookmarks);
            };

            var data = {
                s: $.map(servers, function(element) {
                    return element.sessionId;
                })
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.url() + EVWEB2.urls.bookmark,
                type: 'GET',
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, this);
        };

        /**
         * Create a new bookmark.
         * @param {Function} callback Callback function to be executed when the call completes. Callback
         * is passed a {@link EVWEB2.ResponseStatus} instance and an {@link EVWEB2.Bookmark} instance.
         * @param {EVWEB2.Bookmark} bookmark The bookmark to create.  Note: {@link EVWEB2.bookmark.guid} is ignored by
         * this method and can be left blank.  The generated bookmark will have a new guid applied.  Note: If this
         * bookmark is assigned to a case, that case must be present on all of the servers referenced by the bookmark
         * items.
         */
        this.createBookmark = function(callback, bookmark) {
            var instance = this;

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var serverMap = {};
                $.each(bookmark.items, function(index, element) {
                    serverMap[element.server.sessionId] = element.server;
                });

                var items = $.map(data.bookmark.items, function(el) {
                    return new EVWEB2.BookmarkItem(serverMap[el.server], el.id, el.type);
                });
                var start = EVWEB2.util.IETF2Date(data.bookmark.start);
                var end = EVWEB2.util.IETF2Date(data.bookmark.end);

                var newBookmark = new EVWEB2.Bookmark(data.bookmark.name, data.bookmark.guid, start, end, items,
                    data.bookmark.description, data.bookmark.size, data.bookmark['case']);


                var remainingBookmarks = bookmark.items.length - 1;
                var addItemFailed = false;
                var onBookmarkItemAdded = function(response) {
                    remainingBookmarks--;
                    if(!response.success) {
                        addItemFailed = true;
                    }
                    if(remainingBookmarks <= 0) {
                        var errorText;
                        if(addItemFailed) {
                            errorText = 'Not all items were added to the bookmark.';
                        }
                        var successResponse = new EVWEB2.ResponseStatus(true, errorText);
                        callback(successResponse, newBookmark);
                    }
                };

                if(remainingBookmarks > 0) {
                    // Add the items.
                    var i;
                    for(i=1; i<bookmark.items.length; i++) {
                        newBookmark.addItem(onBookmarkItemAdded, bookmark.items[i]);
                    }
                }
                else {
                    var successResponse = new EVWEB2.ResponseStatus(true);
                    callback(successResponse, newBookmark);

                }
            };

            if(bookmark.items.length === 0) {
                var errorResponse = new EVWEB2.ResponseStatus(false, "A bookmark must have at least one item.");
                callback(errorResponse);
                return;
            }

            // Make the initial create request with the first item.
            var data = {
                s: bookmark.items[0].server.sessionId,
                name: bookmark.name,
                description: bookmark.description,
                start: EVWEB2.util.Date2IETF(bookmark.start),
                end: EVWEB2.util.Date2IETF(bookmark.end),
                itemId: bookmark.items[0].id,
                itemType: bookmark.items[0].type
            };
            if(bookmark.caseId !== null) {
                data["case"] = bookmark.caseId;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.url() + EVWEB2.urls.bookmark,
                type: 'POST',
                data: data
            };

            EVWEB2.ajax(settings, instance);
        };

        /**
         * Retrieves the configured friendly name from the web service.
         * @param {Function} callback Callback function to be executed when the call completes. The function gets
         * passed a {@link EVWEB2.ResponseStatus} instance with the details of the response and the friendly name
         * of the web service.
         */
        this.friendlyName = function(callback) {

            var onSuccess = function(data/*, textStatus, xhr*/) {
                friendlyName = data.name;

                //Return the version number
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, friendlyName);
            };

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            //If the name has already been retrieved, return the cached name.
            if(friendlyName !== '') {
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, friendlyName);
                return;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: this.url() + EVWEB2.urls.serviceInfo
            };

            EVWEB2.ajax(settings, this);
        };

        /**
         * @callback onGetAddresses
         * @param {EVWEB2.ResponseStatus} response Success state of the response.
         * @param {EVWEB2.ServiceAddresses} addresses The service address configuration.
         * @param {String[]} throttledRelayMACs A list of mac addresses, corresponding to servers that would have
         * video connections throttled if the HTTP interface were to be used over the relay.
         * @ignore
         */
        /**
         * EVWEB2.Service.getAddresses retrieves the set of all network addresses for a web service.
         * Note that while all addresses are returned, a client may not be able to connect through all of
         * them depending on its own network situation.
         * @param {onGetAddresses} cb Function to be executed when the call completes.
         */
        this.getAddresses = function(cb) {
            var onSuccess = function(data/*, textStatus, xhr*/) {
                var internal;
                if (data.addresses.internal) {
                    internal = data.addresses.internal.map(function(addr) {
                        return new EVWEB2.NetworkAddress(addr.protocol, addr.host, addr.port);
                    });
                }

                var detected;
                if (data.addresses.detected) {
                    detected = data.addresses.detected.map(function(addr) {
                        return new EVWEB2.NetworkAddress(addr.protocol, addr.host, addr.port);
                    });
                }

                var external;
                if (data.addresses.external) {
                    external = new EVWEB2.NetworkAddress(
                        data.addresses.external.protocol,
                        data.addresses.external.host,
                        data.addresses.external.port
                    );
                }

                var relay;
                var throttled = [];
                if (data.addresses.relay) {
                    relay = new EVWEB2.NetworkAddress(
                        data.addresses.relay.address.protocol,
                        data.addresses.relay.address.host,
                        data.addresses.relay.address.port
                    );
                    throttled = data.addresses.relay.throttled;
                }

                var addresses = new EVWEB2.ServiceAddresses(
                    internal,
                    detected,
                    external,
                    relay
                );
                cb(new EVWEB2.ResponseStatus(true), addresses, throttled);
            };

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                cb(new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr)));
            };

            EVWEB2.ajax({
                url: this.url() + EVWEB2.urls.addresses,
                success: onSuccess,
                error: onError
            }, this);
        };
    };

    /**
     * EVWEB2.NetworkAddress points to a network endpoint.
     * @param {String} protocol The protocol.
     * @param {String} hostname The hostname.
     * @param {Number} port The port.
     * @class
     * @category Service
     */
    EVWEB2.NetworkAddress = function(protocol, hostname, port) {
        /**
         * The protocol.
         * @type {String}
         */
        this.protocol = protocol || 'http';

        /**
         * The protocol.
         * @type {String}
         */
        this.hostname = hostname || '';

        /**
         * The protocol.
         * @type {String}
         */
        this.port = port || (this.protocol === 'https' ? 443 : 80);
    };

    /**
     * EVWEB2.ServiceAddresses describes the network addresses on which a service can be reached.
     * @param {EVWEB2.NetworkAddress[]} internal The set of configured internal addresses.
     * @param {EVWEB2.NetworkAddress[]} detected The set of detected external addresses.
     * @param {EVWEB2.NetworkAddress} external The configured external address, if set.
     * @param {EVWEB2.NetworkAddress} relay The network relay address, if configured.
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceAddresses = function(internal, detected, external, relay) {
        /**
         * The set of configured internal network addresses.
         * @type {EVWEB2.NetworkAddress[]}
         */
        this.internal = internal || [];

        /**
         * The set of detected external addresses.
         * @type {EVWEB2.NetworkAddress[]}
         */
        this.detected = detected || [];

        /**
         * The externally accessible address, if configured.
         * @type {EVWEB2.NetworkAddress}
         */
        this.external = external || null;

        /**
         * The network relay address, if configured.
         * @type {EVWEB2.NetworkAddress}
         */
        this.relay = relay || null;
    };
}());

/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * Enumeration of HTTP policies enforced while HTTPS is configured.
     * @enum {Number}
     * @readonly
     * @category Service
     */
    EVWEB2.httpPolicy = {
        /**
         * Conduct HTTP traffic as usual.
         */
        none: 0,
        /**
         * Redirect all HTTP traffic to HTTPS.
         */
        redirect: 1,
        /**
         * Do not accept incoming connections on the HTTP port.
         */
        disable: 2
    };

    /**
     * Container for basic SSl/TLS configuration information.
     * @class
     * @param {String} [commonName=''] The common name (CN) the certificate is configured for (if any)
     * @param {String[]} [domains=[]] The list of all domains the certificate is configured for (if any) (CN + SANs)
     * @param {Boolean} [valid=false] Flag indicating if the configuration is valid
     * @param {Date|null} [expiration=null] The date the certificate expires
     * @category Service
     */
    EVWEB2.BasicSSLConfig = function(commonName, domains, valid, expiration) {

        /**
         * The common name configured
         * @type {String}
         */
        this.commonName = '';

        /**
         * The domain names configured (CN + SANs)
         * @type {String[]}
         */
        this.domains = [];

        /**
         * Flag indicating if the SSL configuration/certificate is valid
         * @type {Boolean}
         */
        this.valid = false;

        /**
         * The expiration date of the certificate
         * @type {Date}
         */
        this.expiration = null;

        if(commonName !== undefined) {
            this.commonName = commonName;
        }
        if(domains !== undefined) {
            this.domains = domains;
        }
        if(valid !== undefined) {
            this.valid = valid;
        }
        if(expiration !== undefined) {
            this.expiration = expiration;
        }
    };

    /**
     * The external SSL config object is a container for information related to SSL configurations
     * that use an externally provided private key and certificate (e.g. DigiCert)
     * @class
     * @param {Boolean} enabled Flag indicating whether SSL support is configured and enabled
     * @param {EVWEB2.BasicSSLConfig|null} basicConfig Common SSL configuration. If disabled this may be null.
     * @category Service
     */
    EVWEB2.ExternalSSLConfig = function(enabled, basicConfig) {
        /**
         * Whether SSL/TLS is enabled. If this is false none of the other parameters have
         * any meaning.
         * @type {Boolean}
         */
        this.enabled = enabled;

        /**
         * Common SSL configuration information
         * @type {EVWEB2.BasicSSLConfig|null}
         */
        this.basic = basicConfig;
    };

    /**
     * Definition of the possible SSL config types
     * @enum {number}
     * @readonly
     * @category Service
     */
    EVWEB2.sslConfigType = {
        /**
         * SSL/TLS is not configured by the service
         */
        none: 0,
        /**
         * An externally-provided configuration is enabled
         */
        external: 1,
        /**
         * An ACME server configuration is enabled
         */
        acme: 2
    };

    /**
     * Definition of ACME request status codes
     * @enum {number}
     * @readonly
     * @category Service
     */
    EVWEB2.acmeSSLRequestStatus = {
        /**
         * Request is in-flight and still pending
         */
        pending: 1,
        /**
         * Certificate was issued and configured
         */
        success: 2,
        /**
         * The HTTP challenge submitted to the ACME server failed
         */
        httpChallengeFailed: -1,
        /**
         * Failed to verify the requested domain maps to the service IP
         */
        localDomainVerifyFailed: -2,
        /**
         * Network problem (e.g. unreachable ACME server)
         */
        networkError: -3,
        /**
         * Too many requests made in a row, temporarily rate-limited by ACME server. Try again later
         */
        rateLimited: -4,
        /**
         * ACME account data is corrupted
         */
        accountDataCorrupt: -5,
        /**
         * ACME server has rejected the domain as invalid
         */
        invalidDomain: -6,
        /**
         * An ACME protocol error occurred
         */
        protocolError: -7,
        /**
         * Unknown error. Consult the service logs
         */
        unknownError: -8
    };

    /**
     * Definition of the possible credential status codes
     * @enum {number}
     * @readonly
     * @category Service
     */
    EVWEB2.credStatus = {
        /**
         * Not provided/not checked
         */
        notPresent: 0,
        /**
         * Successfully validated
         */
        success: 1,
        /**
         * Login failed
         */
        loginFailed: 2,
        /**
         * Validation timed out
         */
        timedOut: 3,
        /**
         * Internal error
         */
        internalError: 4
    };

    /**
     * Container for server login status information.
     * @class
     * @param {EVWEB2.credStatus} [passthrough=EVWEB2.credStatus.notPresent] The passthrough login status.
     * @param {EVWEB2.credStatus} [powerUser=EVWEB2.credStatus.notPresent] The power user login status.
     * @category Service
     */
    EVWEB2.LoginStatus = function(passthrough, powerUser) {
        /**
         * The passthrough login status
         * @type {String}
         */
        this.passthrough = EVWEB2.credStatus.notPresent;

        /**
         * The power user login status
         * @type {String}
         */
        this.powerUser = EVWEB2.credStatus.notPresent;

        if(passthrough !== undefined) {
            this.passthrough = passthrough;
        }
        if(powerUser !== undefined) {
            this.powerUser = powerUser;
        }
    };

    /**
     * The ACME SSL config object is a container for information related to SSL configurations that
     * use an ACME server to automatically manage SSL certificates and private keys (e.g. Let's Encrypt
     * is an ACME server).
     * @class
     * @param {Boolean} enabled Flag indicating whether SSL support is configured and enabled
     * @param {EVWEB2.BasicSSLConfig|null} basicConfig Common SSL configuration. If disabled this may be null.
     * @param {Boolean} [autoRenew=false] Flag indicating whether auto-renewal is enabled, if true the
     * service will attempt to renew the certificate before it expires.
     * @param {String} [acmeServer=null] The ACME server used to provision the certificate. If not provided
     * this defaults to the Let's Encrypt production server's.
     * @category Service
     */
    EVWEB2.AcmeSSLConfig = function(enabled, basicConfig, autoRenew, acmeServer) {
        /**
         * Whether SSL/TLS is enabled. If this is false none of the other parameters have
         * any meaning.
         * @type {Boolean}
         */
        this.enabled = enabled;

        /**
         * Common SSL configuration information
         * @type {EVWEB2.BasicSSLConfig|null}
         */
        this.basic = basicConfig;

        /**
         * Flag indicating whether auto-renewal is enabled
         * @type {Boolean}
         */
        this.autoRenew = false;

        /**
         * The ACME server (url) used to provision the certificate
         * @type {String}
         */
        this.acmeServer = null;

        if (autoRenew !== undefined) {
            this.autoRenew = autoRenew;
        }
        if (acmeServer !== undefined) {
            this.acmeServer = acmeServer;
        }
    };

    /**
     * The service server configuration object acts as a container for all configuration information associated with a
     * server on a service.
     * @param {Number} [id=0] The server ID for the server.
     * @param {String} [address=''] The address for the server.
     * @param {Number} [port=0] The port for the server.
     * @param {Number} [timeout=0] The timeout duration for server requests.
     * @param {Boolean} [passthrough=false] Whether the server is configured as a passthrough server.
     * @param {String} [username=''] The username for passthrough connections to the server.
     * @param {String} [password=''] The password for passthrough connections to the server.
     * @param {Boolean} [autopopulate=false] Whether the server is configured to autopopulate on load.
     * @param {Boolean} [powerUser=false] Whether the server has a power user process configured.  Power user processes
     *   are used to enable functionality outside of the current session, for example, push notifications.
     * @param {String} [powerUserUsername=''] The username for the power user process connection to the server.
     * @param {String} [powerUserPassword=''] The password for the power user process connection to the server.
     * @param {String} [name=''] The name of the server if known.
     * @param {Object|null} [status=null] The status of the passthrough/power user logins for the server.
     * @param {EVWEB2.credStatus} [status.passthrough=EVWEB2.credStatus.notPresent] The passthrough login status.
     * @param {EVWEB2.credStatus} [status.powerUser=EVWEB2.credStatus.notPresent] The power user login status.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceServerConfiguration = function(id, address, port, timeout, passthrough, username, password,
                                                 autopopulate, powerUser, powerUserUsername, powerUserPassword, name, status) {
        /**
         * The server ID for the server.
         * @type {Number}
         */
        this.id = 0;

        /**
         * The address for the server.
         * @type {String}
         */
        this.address = '';

        /**
         * The port for the server.
         * @type {Number}
         */
        this.port = 0;

        /**
         * The timeout duration for server requests.
         * @type {Number}
         */
        this.timeout = 0;

        /**
         * Whether the server is configured as a passthrough server.
         * @type {Boolean}
         */
        this.passthrough = false;

        /**
         * The username for passthrough connections to the server.
         * @type {String}
         */
        this.username = '';

        /**
         * The password for passthrough connections to the server.
         * @type {String}
         */
        this.password = '';

        /**
         * Whether the server is configured to autopopulate on load.
         * @type {Boolean}
         * @deprecated This value is no longer processed and can be ignored.
         */
        this.autopopulate = false;

        /**
         * Whether the server has a power user process configured.  Power user processes are used
         * to enable functionality outside of the current session, for example, push notifications.
         * @type {Boolean}
         */
        this.powerUser = false;

        /**
         * The username for the power user process connection to the server.
         * @type {String}
         */
        this.powerUserUsername = '';

        /**
         * The password for the power user process connection to the server.
         * @type {String}
         */
        this.powerUserPassword = '';

        /**
         * The (friendly) name of the server.
         * @type {string}
         */
        this.name = '';

        /**
         * The login statuses of the server.
         * @type {EVWEB2.LoginStatus}
         */
        this.status = null;

        //Assign the constructor values
        if(id !== undefined) {
            this.id = id;
        }
        if(address !== undefined) {
            this.address = address;
        }
        if(port !== undefined) {
            this.port = port;
        }
        if(timeout !== undefined) {
            this.timeout = timeout;
        }
        if(passthrough !== undefined) {
            this.passthrough = passthrough;
        }
        if(username !== undefined) {
            this.username = username;
        }
        if(password !== undefined) {
            this.password = password;
        }
        if(autopopulate !== undefined) {
            this.autopopulate = autopopulate;
        }
        if(powerUser !== undefined) {
            this.powerUser = powerUser;
        }
        if(powerUserUsername !== undefined) {
            this.powerUserUsername = powerUserUsername;
        }
        if(powerUserPassword !== undefined) {
            this.powerUserPassword = powerUserPassword;
        }
        if(name !== undefined) {
            this.name = name;
        }
        if(status !== undefined) {
            this.status = new EVWEB2.LoginStatus(status.passthrough, status.powerUser);
        }
    };

    /**
     * The service remote server configuration object acts as a container for all configuration information associated
     * with a remote server on a service.
     * @param {Number} [id=0] The server ID for the server.
     * @param {String} [identifier=''] The identifier for the server.
     * @param {Number} [timeout=0] The timeout duration for server requests.
     * @param {Boolean} [passthrough=false] Whether the server is configured as a passthrough server.
     * @param {String} [username=''] The username for passthrough connections to the server.
     * @param {String} [password=''] The password for passthrough connections to the server.
     * @param {Boolean} [autopopulate=false] Whether the server is configured to autopopulate on load.
     * @param {Boolean} [powerUser=false] Whether the server has a power user process configured.  Power user processes
     * are used to enable functionality outside of the current session, for example, push notifications.
     * @param {String} [powerUserUsername=''] The username for the power user process connection to the server.
     * @param {String} [powerUserPassword=''] The password for the power user process connection to the server.
     * @param {String} [name=''] The name of the server if known.
     * @class
     * @constructor
     * @internal
     * @category Service
     */
    EVWEB2.ServiceRemoteServerConfiguration = function(id, identifier, timeout, passthrough, username, password,
                                                 autopopulate, powerUser, powerUserUsername, powerUserPassword, name) {
        /**
         * The server ID for the server.
         * @type {Number}
         */
        this.id = 0;

        /**
         * The identifier for the server.
         * @type {String}
         */
        this.identifier = '';

        /**
         * The timeout duration for server requests.
         * @type {Number}
         */
        this.timeout = 0;

        /**
         * Whether the server is configured as a passthrough server.
         * @type {Boolean}
         */
        this.passthrough = false;

        /**
         * The username for passthrough connections to the server.
         * @type {String}
         */
        this.username = '';

        /**
         * The password for passthrough connections to the server.
         * @type {String}
         */
        this.password = '';

        /**
         * Whether the server is configured to autopopulate on load.
         * @type {Boolean}
         */
        this.autopopulate = false;

        /**
         * Whether the server has a power user process configured.  Power user processes are used
         * to enable functionality outside of the current session, for example, push notifications.
         * These processes are never accessed by a client of the web service.
         * @type {Boolean}
         */
        this.powerUser = false;

        /**
         * The username for the power user process connection to the server.
         * @type {String}
         */
        this.powerUserUsername = '';

        /**
         * The password for the power user process connection to the server.
         * @type {String}
         */
        this.powerUserPassword = '';
        
        /**
         * The (friendly) name of the server.
         * @type {string}
         */
        this.name = '';

        //Assign the constructor values
        if(id !== undefined) {
            this.id = id;
        }
        if(identifier !== undefined) {
            this.identifier = identifier;
        }
        if(timeout !== undefined) {
            this.timeout = timeout;
        }
        if(passthrough !== undefined) {
            this.passthrough = passthrough;
        }
        if(username !== undefined) {
            this.username = username;
        }
        if(password !== undefined) {
            this.password = password;
        }
        if(autopopulate !== undefined) {
            this.autopopulate = autopopulate;
        }
        if(powerUser !== undefined) {
            this.powerUser = powerUser;
        }
        if(powerUserUsername !== undefined) {
            this.powerUserUsername = powerUserUsername;
        }
        if(powerUserPassword !== undefined) {
            this.powerUserPassword = powerUserPassword;
        }
        if(name !== undefined) {
            this.name = name;
        }
    };

    /**
     * The service remote server settings configuration object acts as a container for all
     * configuration information associated with handling remote servers on the web service.
     * @param {Boolean} [enabled=false] Whether remote servers support is enabled.
     * @param {Number} [port=35111] The listening port for incoming remote server connections.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceRemoteServerSettingsConfiguration = function(enabled, port) {
        /**
         * Whether remote servers support is enabled.
         * @type {boolean}
         */
        this.enabled = false;

        /**
         * The listening port for incoming remote server connections.
         * @type {number}
         */
        this.port = 35111;
        
        if(enabled !== undefined) {
            this.enabled = enabled;
        }
        if(port !== undefined) {
            this.port = port;
        }
    };    

    /**
     * Definitions for the logging levels for a service configuration
     * @enum {number}
     * @readonly
     * @category Service
     */
    EVWEB2.serviceLoggingLevels = {
        /**
         * Not set
         */
        NOTSET: -1,
        /**
         * Error
         */
        ERROR: 0,
        /**
         * Warning
         */
        WARNING: 1,
        /**
         * Info
         */
        INFO: 2,
        /**
         * Debug
         */
        DEBUG: 3
    };

    /**
     * Definitions for the log file interval types
     * @enum {String}
     * @readonly
     * @category Service
     */
    EVWEB2.serviceLogFileIntervalTypes = {
        /**
         * None
         */
        none : '',
        /**
         * Minute
         */
        minute : 'M',
        /**
         * Hour
         */
        hour : 'H',
        /**
         * Day
         */
        day : 'D',
        /**
         * Week
         */
        week : 'W'
    };

    /**
     * The service log file configuration object acts as a container for all configuration information associated
     * with the log file for the service.
     * @param {Number} [interval=0] The interval age of the log file.
     * @param {EVWEB2.serviceLogFileIntervalTypes} [type=EVWEB2.serviceLogFileIntervalTypes.none] The interval type of
     * the log file age.
     * @param {Number} [count=0] The number of backups to be used for this log file.
     * @param {EVWEB2.serviceLoggingLevels} [level=EVWEB2.serviceLoggingLevels.NOTSET] The logging level of the web
     * service.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceLogFileConfiguration = function(interval, type, count, level) {
        /**
         * The interval age of the log file
         * @type {Number}
         */
        this.interval = 0;

        /**
         * The interval type of the log file age.
         * @type EVWEB2.serviceLogFileIntervalTypes
         */
        this.type = EVWEB2.serviceLogFileIntervalTypes.none;

        /**
         * The number of backups to be used for this log file.
         * @type {Number}
         */
        this.count = 0;

        /**
         * The logging level of the web service.
         * @type {EVWEB2.serviceLoggingLevels|number}
         */
        this.level = EVWEB2.serviceLoggingLevels.NOTSET;

        //Assign the constructor values
        if(interval !== undefined) {
            this.interval = interval;
        }
        if(type !== undefined) {
            this.type = type;
        }
        if(count !== undefined) {
            this.count = count;
        }
        if(level !== undefined) {
            this.level = level;
        }
    };

    /**
     * The port configuration object acts as a container for all port configuration
     * information associated with the web service.
     * @param {Number} [http=80] The listening port for HTTP traffic.
     * @param {Number} [https=443] The listening port for HTTPS traffic.
     * @param {Number} [ws=8082] The listening port for Web Socket traffic.
     * @param {Number} [wss=8083] The listening port for Secure Web Socket traffic.
     * @param {EVWEB2.httpPolicy} [httpPolicy=EVWEB2.httpPolicy.none] The policy to enforce for HTTP traffic when HTTPS
     * is configured.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServicePortsConfiguration = function(http, https, ws, wss, httpPolicy) {
        /**
         * The listening port for HTTP traffic.
         * @type {number}
         */
        this.http = http || 80;

        /**
         * The listening port for HTTPS traffic.
         * @type {number}
         */
        this.https = https || 443;

        /**
         * The listening port for Web Socket traffic.
         * @type {number}
         */
        this.ws = ws || 8082;

        /**
         * The listening port for Secure Web Socket traffic.
         * @type {number}
         */
        this.wss = wss || 8083;

        /**
         * The policy to enforce for HTTP traffic when HTTPS is configured.
         * @type {EVWEB2.httpPolicy}
         */
        this.httpPolicy = httpPolicy || EVWEB2.httpPolicy.none;
    };

    /**
     * The update settings configuration object acts as a container for all
     * update configuration information associated with the web service.
     * @param {String} [url=''] The URL location of the downloads info file.
     * @param {Number} [timeout=0] The timeout duration for requesting the downloads info file.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceUpdateConfiguration = function(url, timeout) {
        /**
         * The URL location of the downloads info file.
         * @type {string}
         */
        this.url = '';

        /**
         * The timeout duration for requesting the downloads info file.
         * @type {number}
         */
        this.timeout = 0;

        if(url !== undefined) {
            this.url = url;
        }
        if(timeout !== undefined) {
            this.timeout = timeout;
        }
    };

    /**
     * The basic service settings configuration object acts as a container for all
     * basic configuration information associated with the web service.
     * @param {String} [name=""] The friendly name of the service.
     * @param {String} [url=""] The external URL for the service.
     * @param {EVWEB2.ServicePortsConfiguration} [ports=null] The ports configuration for the service.
     * @param {Boolean} [csrf=true] Whether to enable CSRF protection for state-changing calls.
     * @param {Number} [loginExpiration=30] The number of days before a saved login expires.
     * @param {Number} [inactivityTimeout=0] The default inactivity timeout to use if not set (disabled=0).
     * @param {Boolean} [autocomplete=false] Whether to allow input elements in web service HTML to autocomplete.
     * @param {Boolean} [relay=false] Whether to enable external relay URL.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceBasicConfiguration = function(name, url, ports, csrf, loginExpiration, inactivityTimeout,
                                                autocomplete, relay) {
        /**
         * The friendly name of the service.
         * @type {string}
         */
        this.name = '';

        /**
         * The external URL for the service.
         * @type {string}
         */
        this.url = '';

        /**
         * The ports configuration for the service.
         * @type {EVWEB2.ServicePortsConfiguration}
         */
        this.ports = null;

        /**
         * Whether to enable CSRF protection for state-changing calls.
         * @type {boolean}
         */
        this.csrf = true;

        /**
         * The number of days before a saved login expires.
         * @type {number}
         */
        this.loginExpiration = 30;

        /**
         * The number of days before a saved login expires.
         * @type {number}
         */
        this.inactivityTimeout = 0;

        /**
         * Whether to allow input elements in web service HTML to autocomplete.
         * @type {Boolean}
         */
        this.autocomplete = autocomplete || false;

        /**
         * Whether to enable external relay URL.
         * @type {Boolean}
         */
        this.relay = relay || false;

        if(name !== undefined) {
            this.name = name;
        }
        if(url !== undefined) {
            this.url = url;
        }
        if(ports !== undefined) {
            this.ports = ports;
        }
        if(csrf !== undefined) {
            this.csrf = csrf;
        }
        if(loginExpiration !== undefined) {
            this.loginExpiration = loginExpiration;
        }
        if(inactivityTimeout !== undefined) {
            this.inactivityTimeout = inactivityTimeout;
        }

    };

    /**
     * An enum defining the types of external authentication available.
     * @enum {number}
     * @readonly
     * @category Service
     */
    EVWEB2.serviceExternalAuthTypes = {
        /**
         * None
         */
        none: 0,
        /**
         * Enterprise Manager
         */
        esm: 1
    };

    /**
     * The service external auth configuration object acts as a container for all configuration information associated
     * with external authentication.
     * @param {EVWEB2.serviceExternalAuthTypes} [type=EVWEB2.ServiceExternalAuthTypes.none] The type of external
     * authentication enabled.
     * @param {Object} [options={}] An object containing the authentication-specific information.
     *    EVWEB2.ServiceExternalAuthTypes.none: No options are required
     *    EVWEB2.ServiceExternalAuthTypes.esm: Requires the following options
     *      * options.url
     *      * options.user
     *      * options.password
     * @param {String} [options.url=''] The URL to the ESM instance providing authentication.
     * @param {String} [options.user=''] The admin username to the ESM instance, providing a full server list and
     *      power user process credentials.
     * @param {String} [options.password=''] The admin password to the ESM instance, providing a full server list
     *      and power user process credentials.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceExternalAuthConfiguration = function(type, options) {
        /**
         * The type of external authentication enabled.
         * @type EVWEB2.serviceExternalAuthTypes
         */
        this.type = EVWEB2.serviceExternalAuthTypes.none;

        /**
         * The url to the ESM instance when using ESM authentication ({@link EVWEB2.serviceExternalAuthTypes.esm}).
         * @type String
         */
        this.url = '';


        /**
         * The admin username to the ESM instance when using ESM authentication
         * ({@link EVWEB2.serviceExternalAuthTypes.esm}), providing a full server list and power user process
         * credentials.
         * @type String
         */
        this.user = '';

        /**
         * The admin password to the ESM instance when using ESM authentication
         * ({@link EVWEB2.serviceExternalAuthTypes.esm}), providing a full server list and power user process
         * credentials.
         * @type String
         */
        this.password = '';

        //Assign the constructor values
        if(type !== undefined) {
            this.type = type;
        }
        if(options !== undefined) {
            // Process the type-specific properties
            if(this.type === EVWEB2.serviceExternalAuthTypes.esm) {
                if(options.url !== undefined) {
                    this.url = options.url;
                }
                if(options.user !== undefined) {
                    this.user = options.user;
                }
                if(options.password !== undefined) {
                    this.password = options.password;
                }
            }
        }
    };

    /**
     * Definition of the config access restriction levels that may be enforced.
     * @enum {Number}
     * @readonly
     * @category Service
     */
    EVWEB2.configAccessLevel = {
        /**
         * Clients from any point in the network may access the config.
         */
        all: 0,
        /**
         * Disallow config access to requests coming over the relay.
         */
        noRelay: 1,
        /**
         * Disallow config access to requests not over the loopback device.
         */
        localhostOnly: 2
    };

    /**
     * The admin configuration object acts as a container for all admin configuration
     * information associated with the web service.
     * @param {String} username The username of the configuration administration account.
     * @param {String} [password=""] The password of the configuration administration account.
     * @param {EVWEB2.configAccessLevel} [accessLevel=EVWEB2.configAccessLevel.noRelay] The level of
     * config access restriction to be applied.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceAdminConfiguration = function(username, password, accessLevel) {
        /**
         * The username of the configuration administration account.
         * @type {String}
         */
        this.username = username;

        /**
         * The password of the configuration administration account.
         * @type {String}
         */
        this.password = '';

        /**
         * The level of config access restriction being enforced.
         *
         * @type {EVWEB2.configAccessLevel}
         */
        this.accessLevel = EVWEB2.configAccessLevel.noRelay;

        /**
         * DEPRECATED. Control access restriction via {@link this.accessLevel} instead.
         * Whether to restrict access to the service configuration to requests originating from localhost.
         * @type {Boolean}
         * @deprecated
         */
        this.localhostRestriction = false;

        if(password !== undefined) {
            this.password = password;
        }
        if (accessLevel !== undefined) {
            if (typeof accessLevel !== 'boolean') {
                this.accessLevel = accessLevel;
                this.localhostRestriction = accessLevel === EVWEB2.configAccessLevel.localhostOnly;
            } else {
                // account for legacy uses of constructor where 3rd param was bool localhostRestriction
                this.localhostRestriction = accessLevel;
                this.accessLevel = accessLevel ?
                    EVWEB2.configAccessLevel.localhostOnly :
                    EVWEB2.configAccessLevel.noRelay;
            }
        }
    };

    /**
     * The service configuration object acts as a wrapper for all service configuration methods.
     * @param {EVWEB2.Service} service The containing service for this configuration.
     * @class
     * @category Service
     */
    EVWEB2.ServiceConfig = function(service) {

        /**
         * The containing service for this configuration.
         * @type {EVWEB2.Service}
         */ 
        this.service = service;

        /**
         * Reference to the service configuration auth token.  If not specified, all configuration
         * methods will fail. This value is modified by {@link EVWEB2.ServiceConfig#getAuthorization|getAuthorization()}
         * and {@link EVWEB2.ServiceConfig#destroyAuthorization|destroyAuthorization()}.
         * @type {String|null}
         */
        this.authToken = null;

        /**
         * Determines which method will be used to transmit the auth token for
         * service config requests. This value is modified by {@link EVWEB2.ServiceConfig#getAuthorization|getAuthorization()}
         * @type {Boolean}
         */
        this.secureAuthTokenMethod = false;

        /**
         * Configuration status information
         * @type {EVWEB2.ServiceStatus}
         */
        this.status = new EVWEB2.ServiceStatus(this);

        /**
         * The interval duration for polling attempts for determining when the service has restarted.
         * @private
         * @type {Number}
         */
        var restartPollingInterval = 3000;

        /**
         * The number of poll attempts before returning an error on service restart.
         * @private
         * @type {Number}
         */
        var restartPollingMaxRetries = 10;

        /**
         * The number of successful subsequent polls before returning a success on service restart.
         * @private
         * @type {Number}
         */
        var restartPollingConfirmationsRequired = 5;

        /**
         * The updated ports values.  This is used to indicate that the web service's listening ports
         * have changed and used by {@link EVWEB2.ServiceConfig.restart} to properly redirect to the new
         * location.
         * @private
         * @type {EVWEB2.ServicePortsConfiguration}
         */
        var updatedPorts = null;


        /**
         * Used to indicate that the web service's SSL configuration has changed and is used by
         * {@link EVWEB2.ServiceConfig.restart} to properly redirect to the new location (particularly
         * when deleting the SSL configuration and switching from https to http}.
         * @private
         * @type {string|undefined}
         */
        var updatedProtocol;

        /**
         * Get authorization code for configuration information.  The result of this call is used by all methods
         * in {@link EVWEB2.ServiceConfig} and must be provided before any other requests are made.  Note: the default
         * request method for this function is POST, which will not work in XSS situations.  While its use is not
         * recommended, the useGetRequest parameter switches the use to a GET request.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and the {@link EVWEB2.ServiceConfig}
         * instance.
         * @param {String} username The administration username for the service
         * @param {String} password The administration password for the service
         */
        this.getAuthorization = function (callback, username, password) {
            var config = this;
    
            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };
    
            var onSuccess = function(data, textStatus, xhr) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                // If the service auth token is returned in the
                // X-Service-Authorization header, then the token should be
                // transmitted via this header in future requests. Otherwise
                // default to the deprecated method of transmitting via the
                // json payload.
                if(xhr.getResponseHeader('X-Service-Authorization') === null) {
                    config.authToken = data.auth;
                    config.secureAuthTokenMethod = false;
                } else {
                    config.authToken = xhr.getResponseHeader('X-Service-Authorization');
                    config.secureAuthTokenMethod = true;
                }
    
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, config);
            };
    
            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigToken,
                type: 'POST',
                dataType: 'json',
                data: {
                    u: username,
                    p: password
                }
            };
            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Destroys the stored authorization code previously retrieved by {@link EVWEB2.ServiceConfig.getAuthorization}.
         * While authorization codes will expire after a set duration, it is recommended that all authorization codes
         * are manually destroyed.  Note: the default request method for this function is POST, which will not work in
         * XSS situations.  While its use is not recommended, the useGetRequest parameter switches the use to a GET
         * request.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and the {@link EVWEB2.ServiceConfig} instance.
         */
        this.destroyAuthorization = function (callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'No authorization to destroy.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                config.authToken = null;

                var successResponse = new EVWEB2.ResponseStatus(true);

                callback(successResponse, config);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigToken,
                type: 'DELETE',
                data: {
                    auth: config.authToken
                }
            };
            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Retrieves the configuration of all servers configured on the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to 
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.ServiceServerConfiguration} instances.
         */
        this.getServers = function(callback) {
            var config = this;
    
            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };
    
            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var servers = $.map(data.servers, function(element) {
                    return new EVWEB2.ServiceServerConfiguration(element.id, element.address, element.port,
                        element.timeout, element.passthrough, element.user, element.password,
                        false, element.powerUser, element.powerUserUsername, element.powerUserPassword,
                        element.friendlyName, element.status);
                });
    
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, servers);
            };
    
            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigServers,
                type: 'GET',
                data: {
                    auth: config.authToken
                },
                dataType: 'json'
            };
            EVWEB2.ajax(settings, config.service);            
        };        

        /**
         * Adds a server configuration to the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to be
         * applied, the added {@link EVWEB2.ServiceServerConfiguration} instance, and passthrough and power user status.
         * @param {EVWEB2.ServiceServerConfiguration} server The server configuration to add.
         */
        this.addServer = function(callback, server) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                server.id = data.id;

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, server, data.passthroughStatus, data.powerUserStatus);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigServers,
                type: 'POST',
                dataType: 'json',
                data: {
                    auth: config.authToken,
                    address: server.address,
                    port: server.port,
                    passthrough: server.passthrough,
                    user: server.username,
                    password: server.password,
                    timeout: server.timeout,
                    powerUser: server.powerUser,
                    powerUserUsername: server.powerUserUsername,
                    powerUserPassword: server.powerUserPassword
                }
            };
            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Updates a server configuration on the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to be
         * applied, the updated {@link EVWEB2.ServiceServerConfiguration} instance, and passthrough and power user status.
         * @param {EVWEB2.ServiceServerConfiguration} server The server configuration to update.
         */
        this.updateServer = function(callback, server) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, server, data.passthroughStatus, data.powerUserStatus);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigServers,
                type: 'PUT',
                dataType: 'json',
                data: {
                    auth: config.authToken,
                    id: server.id,
                    address: server.address,
                    port: server.port,
                    passthrough: server.passthrough,
                    user: server.username,
                    password: server.password,
                    timeout: server.timeout,
                    powerUser: server.powerUser,
                    powerUserUsername: server.powerUserUsername,
                    powerUserPassword: server.powerUserPassword
                }
            };
            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Removes a server configuration from the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to be
         * applied, and the deleted {@link EVWEB2.ServiceServerConfiguration} instance.
         * @param {EVWEB2.ServiceServerConfiguration} server The server configuration to delete.
         */
        this.deleteServer = function(callback, server) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, server);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigServers,
                type: 'DELETE',
                dataType: 'json',
                data: {
                    auth: config.authToken,
                    id: server.id
                }
            };
            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Import a client's XDV configuration.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to
         * be applied, and a list of {@link EVWEB2.ServiceServerConfiguration} instances detailing the new server
         * configuration.
         * @param {String|Node} xdvData Either the XDV data to import in a base-64 encoded string form or a
         * jQuery nodeset of an file input populated with the selected XDV file.
         * @param {Boolean} [dataIsUrl=false] Whether the xdvData parameter is a URL to the XDV data.
         */
        this.importXdv = function(callback, xdvData, dataIsUrl) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var servers = $.map(data.servers, function(element) {
                    return new EVWEB2.ServiceServerConfiguration(element.id, element.address, element.port,
                        element.timeout, element.passthrough, element.user, element.password,
                        false, element.powerUser, element.powerUserUsername, element.powerUserPassword);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, servers);
            };

            if(dataIsUrl === undefined) {
                dataIsUrl = false;
            }

            var data = {
                auth: config.authToken
            };
            if(dataIsUrl) {
                data.url = xdvData;
            }
            else {
                data.ini = xdvData;
            }

            if(data.ini instanceof $) {
                EVWEB2.util.internal.XSSPost(service.url() + EVWEB2.urls.serviceConfigServersXdv, data);
                if(typeof callback !== 'undefined') {
                    var onGetServersResponse = function(response, servers) {
                        callback(response, true, servers);
                    };

                    service.config.getServers(onGetServersResponse);
                }
            }
            else {
                var settings = {
                    success: onSuccess,
                    error: onError,
                    url: config.service.url() + EVWEB2.urls.serviceConfigServersXdv,
                    type: 'POST',
                    dataType: 'json',
                    data: data
                };
                EVWEB2.ajax(settings, config.service);
            }
        };

        /**
         * Export the XDV file for the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance and the text content of
         * the INI file.  Note: the text content of the INI file will only be returned if
         * downloadName is undefined.
         * @param {String} [downloadName] The file name to specify for the raw binary content.  If
         * this value is set, the XDV content will be returned as a binary file with the
         * Content-Disposition header set to attachment, prompting a file download.
         */
        this.exportXdv = function (callback, downloadName) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.ini);
            };

            var data = {
                auth: config.authToken
            };
            var url = config.service.url() + EVWEB2.urls.serviceConfigServersXdv;

            if(downloadName !== undefined) {
                // Update window.location to prompt the download.
                data.filename = downloadName;
                var query = $.map(data, function(value, key) {
                    return key + '=' + value;
                });
                window.location = url + '?' + query.join('&');
                onSuccess(new EVWEB2.ResponseStatus(true));
            }
            else {
                // Send the normal request
                var settings = {
                    success: onSuccess,
                    error: onError,
                    url: url,
                    type: 'GET',
                    dataType: 'json',
                    data: data
                };
                EVWEB2.ajax(settings, config.service);
            }
        };

        /**
         * Retrieves the configuration of all remote servers configured on the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.ServiceRemoteServerConfiguration}
         * instances.
         */
        this.getRemoteServers = function(callback) {
            var config = this;
    
            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };
    
            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var servers = $.map(data.remoteServers, function(element) {
                    return new EVWEB2.ServiceRemoteServerConfiguration(element.id, element.identifier,
                        element.timeout, element.passthrough, element.user, element.password,
                        false, element.powerUser, element.powerUserUsername, element.powerUserPassword,
                        element.friendlyName);
                });
    
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, servers);
            };
    
            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigRemoteServers,
                type: 'GET',
                dataType: 'json',
                data: {
                    auth: config.authToken
                }
            };
            EVWEB2.ajax(settings, config.service);   
        };

        /**
         * Adds a remote server configuration to the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to be
         * applied, and the added {@link EVWEB2.ServiceRemoteServerConfiguration} instance.
         * @param {EVWEB2.ServiceRemoteServerConfiguration} server The server configuration to add.
         */
        this.addRemoteServer = function(callback, server) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                server.id = data.id;

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, server);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigRemoteServers,
                type: 'POST',
                dataType: 'json',
                data: {
                    auth: config.authToken,
                    identifier: server.identifier,
                    passthrough: server.passthrough,
                    user: server.username,
                    password: server.password,
                    timeout: server.timeout,
                    powerUser: server.powerUser,
                    powerUserUsername: server.powerUserUsername,
                    powerUserPassword: server.powerUserPassword
                }
            };
            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Updates a remote server configuration on the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to be
         * applied, and the updated {@link EVWEB2.ServiceRemoteServerConfiguration} instance.
         * @param {EVWEB2.ServiceRemoteServerConfiguration} server The server configuration to update.
         */
        this.updateRemoteServer = function(callback, server) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, server);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigRemoteServers,
                type: 'PUT',
                dataType: 'json',
                data: {
                    auth: config.authToken,
                    id: server.id,
                    identifier: server.identifier,
                    passthrough: server.passthrough,
                    user: server.username,
                    password: server.password,
                    timeout: server.timeout,
                    powerUser: server.powerUser,
                    powerUserUsername: server.powerUserUsername,
                    powerUserPassword: server.powerUserPassword
                }
            };
            EVWEB2.ajax(settings, config.service);            
        };

        /**
         * Removes a remote server configuration from the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to be
         * applied, and the deleted {@link EVWEB2.ServiceRemoteServerConfiguration} instance.
         * @param {EVWEB2.ServiceRemoteServerConfiguration} server The server configuration to delete.
         */
        this.deleteRemoteServer = function(callback, server) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, server);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigRemoteServers,
                type: 'DELETE',
                dataType: 'json',
                data: {
                    auth: config.authToken,
                    id: server.id
                }
            };
            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Retrieves the settings for handling remote servers in the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an {@link EVWEB2.ServiceRemoteServerSettingsConfiguration}
         * instance.
         */
        this.getRemoteServersSettings = function(callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var settings = new EVWEB2.ServiceRemoteServerSettingsConfiguration(data.enabled, data.port);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, settings);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigRemoteServersListener,
                type: 'GET',
                dataType: 'json',
                data: {
                    auth: config.authToken
                }
            };
            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Applies the settings for handling remote servers in the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to be
         * applied, and the applied {@link EVWEB2.ServiceRemoteServerSettingsConfiguration} instance.
         * @param {EVWEB2.ServiceRemoteServerSettingsConfiguration} settings The remote server settings to apply.
         */
        this.setRemoteServersSettings = function(callback, settings) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, settings);
            };

            var request = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigRemoteServersListener,
                type: 'POST',
                dataType: 'json',
                data: {
                    auth: config.authToken,
                    enabled: settings.enabled,
                    port: settings.port
                }
            };
            EVWEB2.ajax(request, config.service);
        };

        /**
         * Retrieves the logging configuration of the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.ServiceLogFileConfiguration} instances.
         */
        this.getLoggingSettings = function(callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var settings = new EVWEB2.ServiceLogFileConfiguration(data.interval, data.type, data.count, data.level);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, settings);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigLogging,
                type: 'GET',
                dataType: 'json',
                data: {
                    auth: config.authToken
                }
            };
            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Applies the logging configuration for the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to be
         * applied, and the applied {@link EVWEB2.ServiceLogFileConfiguration} instance.
         * @param {EVWEB2.ServiceLogFileConfiguration} settings The logging settings to apply.
         */
        this.setLoggingSettings = function(callback, settings) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, settings);
            };

            var request = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigLogging,
                type: 'POST',
                dataType: 'json',
                data: {
                    auth: config.authToken,
                    level: settings.level,
                    type: settings.type,
                    interval: settings.interval,
                    count: settings.count
                }
            };
            EVWEB2.ajax(request, config.service);
        };

        /**
         * Get the log file for the service
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of lines composing the log file
         * @param {Number} [numberLines] The number of lines to request.  The lines returned will be the most recent
         * lines.
         */
        this.getLog = function (callback, numberLines) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.log);
            };

            var data = {
                auth: config.authToken
            };
            if(numberLines !== undefined) {
                data.lines = numberLines;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigLoggingFile,
                type: 'GET',
                dataType: 'json',
                data: data
            };
            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Generate a URL for downloading the log file in text format.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @return {String} The URL for the log file.
         */
        this.getLogDownloadUrl = function () {
            if(this.authToken === null) {
                return null;
            }

            var url = this.service.url() + EVWEB2.urls.serviceConfigLoggingFile;
            var params = {
                format: 'text',
                download: true,
                auth: this.authToken
            };
            var getStringParams = $.map(params, function(value, key) {
                return key + '=' + value;
            });
            url += '?' + getStringParams.join('&');
            return url;
        };

        /**
         * Callback invoked by
         * {@link EVWEB2.ServiceConfig#getBasicSettings|getBasicSettings()}.
         * @callback EVWEB2.ServiceConfig~onGetBasicSettings
         * @param {EVWEB2.ResponseStatus} status Success state of the response.
         * @param {EVWEB2.ServiceBasicConfiguration} [settings] The retrieved basic settings.
         */
        /**
         * Retrieves the basic configuration settings of the web service.
         *
         * Note: This request requires that the service {@link EVWEB2.ServiceConfig#authToken|auth token} is set by a
         * call to {@link EVWEB2.ServiceConfig#getAuthorization|getAuthorization()}.
         * @param {EVWEB2.ServiceConfig~onGetBasicSettings} callback Callback to be invoked on completion.
         */
        this.getBasicSettings = function(callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var ports = new EVWEB2.ServicePortsConfiguration(data.ports.http, data.ports.https, data.ports.ws,
                    data.ports.wss, data.ports.httpPolicy);

                // Mark the HTTP port as being updated.
                config.markPortsUpdated(ports);

                var settings = new EVWEB2.ServiceBasicConfiguration(data.name, data.url, ports, data.csrf,
                    data.loginExpiration, data.inactivityTimeout, data.autocomplete, data.relay);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, settings);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigBasic,
                type: 'GET',
                dataType: 'json',
                data: {
                    auth: config.authToken
                }
            };
            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Callback invoked by
         * {@link EVWEB2.ServiceConfig#setBasicSettings|setBasicSettings()}.
         * @callback EVWEB2.ServiceConfig~onSetBasicSettings
         * @param {EVWEB2.ResponseStatus} status Success state of the response.
         * @param {Boolean} [restart] Whether a restart is required.
         * @param {EVWEB2.ServiceBasicConfiguration} [settings] The applied settings.
         * @param {Object} [portConflicts] Any port conflicts. Present only when the submitted config contained a
         * configuration with ports that were detected as in-use by other applications on the system.
         * @param {Boolean} portConflicts.http Whether the provided HTTP port could not be set due to conflict.
         * @param {Boolean} portConflicts.https Whether the provided HTTPS port could not be set due to conflict.
         */
        /**
         * Applies the basic configuration settings for the web service.
         *
         * Note: This request requires that the service {@link EVWEB2.ServiceConfig#authToken|auth token} is set by a
         * call to {@link EVWEB2.ServiceConfig#getAuthorization|getAuthorization()}.
         * @param {EVWEB2.ServiceConfig~onSetBasicSettings} callback Callback to be invoked on completion.
         * @param {EVWEB2.ServiceBasicConfiguration} settings The basic settings to apply.
         */
        this.setBasicSettings = function(callback, settings) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var data = JSON.parse(xhr.responseText);
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse, data.restart, settings, data.conflicts);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                // Mark the HTTP port as being updated.
                config.markPortsUpdated(settings.ports);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, settings);
            };

            var request = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigBasic,
                type: 'POST',
                dataType: 'json',
                data: {
                    name: settings.name,
                    url: settings.url,
                    http: settings.ports.http,
                    https: settings.ports.https,
                    ws: settings.ports.ws,
                    wss: settings.ports.wss,
                    csrf: settings.csrf,
                    loginExpiration: settings.loginExpiration,
                    inactivityTimeout: settings.inactivityTimeout,
                    autocomplete: settings.autocomplete,
                    relay: settings.relay,
                    httpPolicy: settings.ports.httpPolicy
                }
            };
            EVWEB2.ajax(request, config.service);
        };

        /**
         * Retrieves the update configuration settings of the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to 
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed an
         * {@link EVWEB2.ResponseStatus} instance and an {@link EVWEB2.ServiceUpdateConfiguration} instance.
         */
        this.getUpdateSettings = function(callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var settings = new EVWEB2.ServiceUpdateConfiguration(data.url, data.timeout);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, settings);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigUpdates,
                type: 'GET',
                dataType: 'json',
                data: {
                    auth: config.authToken
                }
            };
            EVWEB2.ajax(settings, config.service);            
        };
        
        /**
         * Applies the update configuration settings for the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to 
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to be 
         * applied, and the applied {@link EVWEB2.ServiceUpdateConfiguration} instance.
         * @param {EVWEB2.ServiceUpdateConfiguration} settings The update settings to apply.
         */
        this.setUpdateSettings = function(callback, settings) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, settings);
            };

            var request = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigUpdates,
                type: 'POST',
                dataType: 'json',
                data: {
                    auth: config.authToken,
                    url: settings.url,
                    timeout: settings.timeout
                }
            };
            EVWEB2.ajax(request, config.service);                 
        };

        /**
         * Retrieves the external authentication configuration settings of the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to 
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.ServiceExternalAuthConfiguration}
         * instances.
         */
        this.getExternalAuthSettings = function(callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var options = {};
                if(data.type === EVWEB2.serviceExternalAuthTypes.esm) {
                    options.url = data.url;
                    options.user = data.username;
                    options.password = data.password;
                }

                var settings = new EVWEB2.ServiceExternalAuthConfiguration(data.type, options);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, settings);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigExternalAuth,
                type: 'GET',
                dataType: 'json',
                data: {
                    auth: config.authToken
                }
            };
            EVWEB2.ajax(settings, config.service);                
        };
        
        /**
         * Applies the external authentication configuration settings for the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to 
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to be 
         * applied, and the applied {@link EVWEB2.ServiceExternalAuthConfiguration} instance.
         * @param {EVWEB2.ServiceExternalAuthConfiguration} settings The external authentication settings to apply.
         */
        this.setExternalAuthSettings = function(callback, settings) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var options = {};
                if(data.type === EVWEB2.serviceExternalAuthTypes.esm) {
                    options.url = data.url;
                    options.username = data.username;
                }

                // Erase the password so that it is no longer stored.
                settings.password = '';

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, settings);
            };

            var data = {
                auth: config.authToken,
                type: settings.type
            };
            if(settings.type === EVWEB2.serviceExternalAuthTypes.esm) {
                data.url = settings.url;
                data.username = settings.user;
                if(data.password !== '') {
                    data.password = settings.password;
                }
            }

            var request = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigExternalAuth,
                type: 'POST',
                dataType: 'json',
                data: data
            };
            EVWEB2.ajax(request, config.service);
        };
      
        /**
         * Retrieves the admin configuration settings of the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to 
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * Note: This request will not populate {@link EVWEB2.ServiceAdminConfiguration.password}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an {@link EVWEB2.ServiceAdminConfiguration} instance.
         */
        this.getAdminSettings = function(callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var accessLevel = data.accessLevel;
                if (accessLevel === undefined) {
                    // older services will present localhostRestriction, the constructor will handle either
                    accessLevel = data.localhostRestriction;
                }
                var settings = new EVWEB2.ServiceAdminConfiguration(data.username, undefined, accessLevel);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, settings);
            };

            var request = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigAdmin,
                type: 'GET',
                dataType: 'json',
                data: {
                    auth: config.authToken
                }
            };
            EVWEB2.ajax(request, config.service);                
        };
        
        /**
         * Applies the external authentication configuration settings for the web service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to 
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * Note: If {@link EVWEB2.ServiceAdminConfiguration.password} is an empty string (the default value), 
         * the password will not be changed.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether this action requires a restart to be 
         * applied, and the applied {@link EVWEB2.ServiceAdminConfiguration} instance.
         * @param {EVWEB2.ServiceAdminConfiguration} settings The admin settings to apply.
         */
        this.setAdminSettings = function(callback, settings) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                // Erase the password so that it is no longer stored.
                settings.password = '';

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart, settings);
            };

            var data = {
                auth: config.authToken,
                username: settings.username,
                // deprecated, but older services will still be looking for it
                localhostRestriction: settings.localhostRestriction,
                accessLevel: settings.accessLevel
            };
            if(settings.password !== '') {
                data.password = settings.password;
            }

            var request = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceConfigAdmin,
                type: 'POST',
                dataType: 'json',
                data: data
            };
            EVWEB2.ajax(request, config.service);
        };

        /**
         * Marks the HTTP port as being updated externally to allow for {@link EVWEB2.Service.restart}
         * to properly redirect.  This method is provided exclusively for deprecated methods, in particular,
         * {@link EVWEB2.Service.setConfiguration}.
         * @param {EVWEB2.ServicePortsConfiguration} ports The updated ports configuration.
         * @private
         */
        this.markPortsUpdated = function(ports) {
            updatedPorts = ports;
        };

        /**
         * Restart the web service.  This is generally performed after updating the configuration, as the changes will
         * not be applied until the web service is restarted.  Note: Restarting the web service is not an instantaneous
         * process--after calling this method, the web service will be unreachable for a small amount of time.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, a copy of the {@link EVWEB2.Service} instance, and a Boolean
         * flag indicating if the service restart was confirmed.
         * @param {Boolean} [confirm=True] Flag to confirm the restart was successful. If set to false this
         * function will not attempt to verify the service is back up and running.
         */
        this.restart = function(callback, confirm) {
            var config = this;

            if (confirm === undefined) {
                confirm = true;
            }

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                if(data.xssPost) {
                    if(typeof callback !== 'undefined') {
                        // TODO: This should poll, like the default behavior, after a short timeout instead of
                        // immediately returning.
                        // Send a successful response.
                        var successResponse = new EVWEB2.ResponseStatus(true);
                        callback(successResponse, service, false);
                    }
                    return;
                }

                // If the port has changed, update the URL as necessary.
                var location = window.location;
                if(updatedPorts !== null) {
                    var protocolHttp = location.protocol === 'http:' || updatedProtocol === 'http';
                    var defaultPort = protocolHttp ? 80 : 443;
                    var newPort = protocolHttp ? updatedPorts.http : updatedPorts.https;

                    var newUrl = service.hostUrl;
                    if(newUrl === '') {
                        newUrl = location.protocol + '//' + location.hostname;
                        if(location.port !== '' && location.port !== defaultPort.toString()) {
                            newUrl += ':' + location.port;
                        }
                        newUrl += '/';
                    }

                    newUrl = newUrl.replace(/(:\d+)?[\/]?$/, '');
                    if(newPort !== defaultPort) {
                        newUrl += ':' + newPort;
                    }
                    // Add back the trailing slash
                    newUrl += '/';

                    config.service.hostUrl = newUrl;
                }

                if (location.protocol === 'https:' && updatedProtocol !== undefined && updatedProtocol !== 'https') {
                    // if user is already using https and never calls get/set/delete ssl then updatedProtocol is
                    // undefined and we keep the current protocol
                    // otherwise if the user has made a change to the SSL configuration it is tracked in get/set/delete
                    // and if we have fallen into here then they are currently using https and after a restart
                    // https will no longer be valid
                    config.service.hostUrl = config.service.hostUrl.replace('https', 'http');

                    // immediately return. We cannot confirm in this instance, it will be blocked
                    // in browsers with a Mixed-Content error.
                    confirm = false;
                }

                if (confirm) {
                    // Start polling to see when the service is back up
                    EVWEB2.util.notifyOnServiceRestart(callback, config.service, restartPollingInterval,
                        restartPollingMaxRetries, restartPollingConfirmationsRequired);

                } else {
                    var response = new EVWEB2.ResponseStatus(true);
                    callback(response, config.service, false);
                }
            };

            var params = {
                auth: config.authToken,
                action: 'restart'
            };

            var settings = {
                url: config.service.url() + EVWEB2.urls.service,
                success: onSuccess,
                error: onError,
                type: 'POST',
                data: params
            };
            EVWEB2.ajax(settings, config.service, true);
        };
        
        /**
         * Checks if updates are available for the service.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to 
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance and an array of
         * {@link EVWEB2.ServiceUpdate} instances.
         * @param {String} updatesFileUrl The URL of the updates file
         */
        this.checkForUpdates = function (callback, updatesFileUrl) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }    
            
            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };
    
            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
    
                var updatesList = $.map(data.update_info, function(element) {
                    var isRecommended = element.update_type === "Recommended";
                    return new EVWEB2.ServiceUpdate(service, element.version, element.link, isRecommended,
                                                            element.total_file_size);
                });
    
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, updatesList);
            };
    
            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.service,
                data: {
                    auth: config.authToken,
                    action: 'updatecheck',
                    updates_file: updatesFileUrl
                }
            };
    
            EVWEB2.ajax(settings, config.service);            
        };


        /**
         * Retrieves the list of discovered servers.
         * Note: This request requires that {@link EVWEB2.ServiceConfig.auth} is set by a call to
         * {@link EVWEB2.ServiceConfig.getAuthorization}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.DiscoveryServer} instances.
         */
        this.getDiscoveredServers = function(callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                // Generate the discovery server instances
                var servers = $.map(data.servers, function(element) {
                    return new EVWEB2.DiscoveryServer(element.address, element.port, element.name, element.macAddress,
                        element.model, element.serial);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the server list
                callback(successResponse, servers);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceDiscovery,
                data: {
                    auth: config.authToken
                }
            };

            EVWEB2.ajax(settings, config.service);
        };


        /**
         * Retrieve the type of SSL configuration (if any) currently configured.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance, and an {@link EVWEB2.sslConfigType}
         * instance.
         */
        this.getSSLConfigType = function(callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,
                    EVWEB2.util.getErrorText(xhr), EVWEB2.util.getErrorCode(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText, data.errorCode);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.type);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceSSLConfigType,
                data: {
                    auth: config.authToken
                }
            };

            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Retrieve the active External SSL configuration (if currently configured).
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance, and an {EVWEB2.ExternalSSLConfig}
         * instance.
         */
        this.getExternalSSLConfig = function(callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,
                    EVWEB2.util.getErrorText(xhr), EVWEB2.util.getErrorCode(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText, data.errorCode);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                var expiration = EVWEB2.util.IETF2Date(data.sslConfig.expires);

                var enabled = data.sslConfig.enabled;
                var basicConfig = null;
                if (enabled) {
                    basicConfig = new EVWEB2.BasicSSLConfig(data.sslConfig.commonName,
                        data.sslConfig.domains, data.sslConfig.valid, expiration);

                    // mark ssl as a valid protocol
                    updatedProtocol = 'https';
                }
                var externalConfig = new EVWEB2.ExternalSSLConfig(enabled, basicConfig);
                callback(successResponse, externalConfig);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceSSLExternalConfig,
                data: {
                    auth: config.authToken
                }
            };

            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Retrieve the active ACME SSL configuration (if currently configured).
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance, and an {EVWEB2.AcmeSSLConfig}
         * instance.
         */
        this.getAcmeSSLConfig = function(callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,
                    EVWEB2.util.getErrorText(xhr), EVWEB2.util.getErrorCode(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText, data.errorCode);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                var expiration = EVWEB2.util.IETF2Date(data.sslConfig.expires);
                var enabled = data.sslConfig.enabled;
                var basicConfig = null;
                if (enabled) {
                    basicConfig = new EVWEB2.BasicSSLConfig(data.sslConfig.commonName,
                        data.sslConfig.domains, data.sslConfig.valid, expiration);

                    // mark ssl as a valid protocol
                    updatedProtocol = 'https';
                }

                var acmeConfig = new EVWEB2.AcmeSSLConfig(enabled, basicConfig, data.autoRenew, data.acmeServer);
                callback(successResponse, acmeConfig);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceSSLAcmeConfig,
                data: {
                    auth: config.authToken
                }
            };

            EVWEB2.ajax(settings, config.service);

        };

        /**
         * Import a private key and certificate obtained from an external CA and configure the service's
         * web server to use them.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is
         * passed a {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether a restart is required
         * for the change to be applied
         * @param {String} privateKey The private key to import as a base-64 encoded string
         * @param {String} certificate key The certificate to import as a base-64 encoded string
         * @param {String} [certificateChain=undefined] Any additional intermediate certificate authorities encoded
         * as a base-64 string. Separate chain files are obsolete and any intermediate CA is
         * usually part of the certificate itself.
         */
        this.configureExtSSL = function(callback, privateKey, certificate, certificateChain) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,
                    EVWEB2.util.getErrorText(xhr), EVWEB2.util.getErrorCode(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText, data.errorCode);
                    callback(errorResponse);
                    return;
                }

                // mark ssl as a valid protocol
                updatedProtocol = 'https';
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.restart);
            };

            var data = {
                auth: config.authToken,
                privateKey: privateKey,
                certificate: certificate
            };

            if (certificateChain !== undefined) {
                data.chain = certificateChain;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceSSLExternalConfig,
                type: 'POST',
                data: data
            };

            EVWEB2.ajax(settings, config.service);
        };

        /**
         * Configure the service's web server to obtain a certificate automatically from an ACME server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is
         * passed a {@link EVWEB2.ResponseStatus} instance, and a {String} token to check the status of the
         * request.
         * @param {String} [domain=undefined] The domain name to request a certificate for. This will be
         * the Common Name (CN) of the certificate. If left undefined the service will attempt to use the
         * service external URL.
         * @param {Boolean} [autoRenew=true] Flag indicating if the certificate should be automatically renewed.
         * @param {String[]} [sans=[]] A list of X.509 Subject Alternative Names (SANS) to request in addition
         * to the CN (Common Name).
         * @param {String} [acmeServer=undefined] The ACME server to request a certificate from, this defaults
         * to the production Let's Encrypt Server.
         * @param {String} [privateKey=undefined] The private key to use with the certificate (one will be
         * generated if not provided) as a base-64 encoded string containing the key data.
         */
        this.configureAcmeSSL = function(callback, domain, autoRenew, sans, acmeServer, privateKey) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,
                    EVWEB2.util.getErrorText(xhr), EVWEB2.util.getErrorCode(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText, data.errorCode);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.token);
            };

            var data = {
                auth: config.authToken,
                autoRenew: autoRenew !== undefined ? autoRenew : true
            };

            if (domain !== undefined) {
                data.domain = domain;
            }
            if (acmeServer !== undefined) {
                data.acmeServer = acmeServer;
            }

            if (privateKey !== undefined) {
                data.privateKey = privateKey;
            }

            if (sans !== undefined) {
                data.sans = sans;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceSSLAcmeConfig,
                type: 'POST',
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, config.service);

        };

        /**
         * Poll the status of an ongoing request to issue a certificate from an ACME server. This may need
         * to be called multiple times until the status is no longer pending.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance, a boolean indicating whether a
         * restart is required for the change to be applied, and a {EVWEB2.acmeSSLRequestStatus} instance.
         * @param {String} token The token provided by the configure call to check the status of requesting
         * a certificate from the ACME server.
         */
        this.checkAcmeSSLStatus = function(callback, token) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,
                    EVWEB2.util.getErrorText(xhr), EVWEB2.util.getErrorCode(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText, data.errorCode);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                var restart = data.restart !== undefined ? data.restart : false;
                if (data.status === EVWEB2.acmeSSLRequestStatus.success) {
                    // mark ssl as a valid protocol
                    updatedProtocol = 'https';
                }
                callback(successResponse, restart, data.status);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceSSLAcmeStatus,
                data: {
                    auth: config.authToken,
                    token: token
                }
            };

            EVWEB2.ajax(settings, config.service);

        };


        /**
         * Delete the currently configured SSL configuration including any certificates and private keys.
         * This will also disable SSL if it is currently enabled and configured setting the configuration
         * to {@link sslConfigType.none}
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance and a boolean indicating whether a
         * restart is required for the change to be applied.
         */
        this.deleteSSLConfig = function(callback) {
            var config = this;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,
                    EVWEB2.util.getErrorText(xhr), EVWEB2.util.getErrorCode(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText, data.errorCode);
                    callback(errorResponse);
                    return;
                }

                // mark ssl as no longer valid
                updatedProtocol = 'http';

                var successResponse = new EVWEB2.ResponseStatus(true);
                var restart = data.restart !== undefined ? data.restart : false;
                callback(successResponse, restart);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: config.service.url() + EVWEB2.urls.serviceSSLConfigType,
                type: 'DELETE',
                data: {
                    auth: config.authToken
                }
            };

            EVWEB2.ajax(settings, config.service);

        };

        /**
         * Restore the web service to the factory default settings.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance and a boolean indicating whether a restart is
         * required.
         * @param {Boolean} [excludePorts=false] Whether or not the configured ports should be kept.
         */
        this.restoreDefaults = function(callback, excludePorts) {
            excludePorts = excludePorts || false;

            if (!this.authToken) {
                callback(new EVWEB2.ResponseStatus(false, 'No authorization.'));
            }

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var data = JSON.parse(xhr.responseText);
                var status = new EVWEB2.ResponseStatus(false, 'An error occured.');
                callback(status, data.restart, data.conflicts);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var status = new EVWEB2.ResponseStatus(true);
                updatedProtocol = 'http';
                callback(status, data.restart);
            };

            var settings = {
                url: this.service.url() + EVWEB2.urls.serviceRestoreDefaults,
                type: 'POST',
                error: onError,
                success: onSuccess,
                data: {
                    auth: config.authToken,
                    excludePorts: excludePorts
                }
            };

            EVWEB2.ajax(settings, this.service);
        };
    };
}());

/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * Definitions for the type of passthrough errors
     * @enum {number}
     * @readonly
     * @deprecated This enum is deprecated and will be removed in future versions.
     * @category Service
     */
    EVWEB2.serverPassthroughErrors = {
        /**
         * None
         */
        none: 0,
        /**
         * Login error
         */
        loginError: 1,
        /**
         * Connection Error
         */
        connectError: 2
    };

    /**
     * Container object with health information for individual servers.
     * @param {Number} [serverID=-1] The server id of the server.
     * @param {Number} [numCompressed=0] The total number of compressed streams being processed.
     * @param {Number} [numUncompressed=0] The total number of uncompressed (transcoded) streams being processed.
     * @class
     * @constructor
     * @deprecated This object is deprecated and will be removed in future versions.
     * @category Service
     */
    EVWEB2.ServerHealthStreamInfo = function(serverID, numCompressed, numUncompressed) {
        /**
         * The server id of the server.
         * @type {number}
         */
        this.serverID = -1;

        /**
         * The total number of compressed streams being processed.
         * @type {number}
         */
        this.numCompressed = 0;

        /**
         * The total number of uncompressed (transcoded) streams being processed.
         * @type {number}
         */
        this.numUncompressed = 0;
        
        if(serverID !== undefined) {
            this.serverID = serverID;
        }
        if(numCompressed !== undefined) {
            this.numCompressed = numCompressed;
        }
        if(numUncompressed !== undefined) {
            this.numUncompressed = numUncompressed;
        }
    };    

    /**
     * Container object for streams being processed by the web service.
     * @param {Number} [numCompressed=0] The total number of compressed streams being processed.
     * @param {Number} [numUncompressed=0] The total number of uncompressed (transcoded) streams being processed.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceHealthStreamInfo = function(numCompressed, numUncompressed) {

        /**
         * The total number of compressed streams being processed.
         * @type {number}
         */
        this.numCompressed = 0;

        /**
         * The total number of uncompressed (transcoded) streams being processed.
         * @type {number}
         */
        this.numUncompressed = 0;
        
        if(numCompressed !== undefined) {
            this.numCompressed = numCompressed;
        }
        if(numUncompressed !== undefined) {
            this.numUncompressed = numUncompressed;
        }
    };    
    
    /**
     * Container object with health information for individual servers.
     * @param {Number} [serverID=-1] The server id of the server.
     * @param {String} [serverAddress=''] The address/hostname of the server.
     * @param {Number} [liveConnections=0] The current number of server connections related to live video.
     * @param {Number} [searchConnections=0] The current number of server connections related to video search.
     * @param {EVWEB2.serverPassthroughErrors} [passthroughError=EVWEB2.serverPassthroughErrors.none] The error code 
     * set if any passthrough errors are present, 0 if there are no passthrough errors or the server is not setup to 
     * use passthrough credentials.
     * @param {String[]} [users=[]] The list of users currently accessing this server.
     * @param {EVWEB2.ServerHealthStreamInfo} [streams=null] The active video stream information for the server.
     * @class
     * @constructor
     * @deprecated This object is deprecated and will be removed in future versions.
     * @category Service
     */
    EVWEB2.ServerHealth = function(serverID, serverAddress, liveConnections, searchConnections, passthroughError, 
                                   users, streams){
        /**
         * The unique server ID used by the web service.
         * @type {number}
         */
        this.serverID = -1;

        /**
         * The IP address or hostname (if available) of the server.
         * @type {string}
         */
        this.serverAddress = '';

        /**
         * The current number of server connections open by the web service related to live video.
         * @type {number}
         */
        this.liveConnections = 0;

        /**
         * The current number of server connections open by the web service related to video search.
         * @type {number}
         */
        this.searchConnections = 0;

        /**
         * One of the enum values defined by {@link EVWEB2.serverPassthroughErrors} indicating
         * the status of any errors related to passthrough connections.
         * @type {EVWEB2.serverPassthroughErrors}
         */
        this.passthroughError = EVWEB2.serverPassthroughErrors.none;

        /**
         * The list of users currently accessing this server.
         * @type {String[]}
         */
        this.users = [];

        /**
         * The active video stream information for the server.
         * @type {EVWEB2.ServerHealthStreamInfo}
         */
        this.streams = null;
        
        //Assign the constructor values
        if(serverID !== undefined) {
            this.serverID = serverID;
        }
        if(serverAddress !== undefined) {
            this.serverAddress = serverAddress;
        }
        if(liveConnections !== undefined) {
            this.liveConnections = liveConnections;
        }
        if(searchConnections !== undefined) {
            this.searchConnections = searchConnections;
        }
        if(passthroughError !== undefined) {
            this.passthroughError = passthroughError;
        }
        if(users !== undefined) {
            this.users = users;
        }
        if(streams !== undefined) {
            this.streams = streams;
        }
    };

    /**
     * A container object for service version information, including more info than the basic
     * {@link EVWEB2.Service.version} call.
     * @param {String} [version=''] The version number of the service.  This value is identical to
     * that returned by {@link EVWEB2.Service.version}.
     * @param {String} [evapiVersion=''] The version of evAPI used by the web service.
     * @param {String} [webServerVersion=''] The version of the web server used by the web service.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceHealthVersionInfo = function (version, evapiVersion, webServerVersion) {
        /**
         * The version number of the service.  This value is identical to that returned by
         * {@link EVWEB2.Service.version}.
         * @type {String}
         */
        this.version = '';

        /**
         * The version of evAPI used by the web service.
         * @type {String}
         */
        this.evapiVersion = '';

        /**
         * The version of the web server used by the web service.
         * @type {String}
         */
        this.webServerVersion = '';

        //Assign the constructor values
        if(version !== undefined) {
            this.version = version;
        }

        if(evapiVersion !== undefined) {
            this.evapiVersion = evapiVersion;
        }

        if(webServerVersion !== undefined) {
            this.webServerVersion = webServerVersion;
        }
    };

   /**
    * A container object for service OS information, including more info than the basic
    * {@link EVWEB2.Service.version} call.
    * @param {String} [system=''] The name of the host OS.
    * @param {String} [release=''] The release number of the host OS.
    * @param {String} [version=''] The version number of the host OS.
    * @param {String} [machine=''] The machine type of the host machine.
    * @param {String} [processor=''] The processor type of the host machine.
    * @param {String} [node=''] The host machine's network name.
    * @class
    * @constructor
    * @category Service
    */
    EVWEB2.ServiceHealthOsInfo = function (system, release, version, machine, processor, node) {
        /**
         * The name of the host OS.
         * @type {String}
         */
        this.system = '';

        /**
         * The release number of the host OS.
         * @type {String}
         */
        this.release = '';

        /**
         * The version number of the host OS.
         * @type {String}
         */
        this.version = '';

        /**
         * The machine type of the host machine.
         * @type {String}
         */
        this.machine = '';

        /**
         * The processor type of the host machine.
         * @type {String}
         */
        this.processor = '';

        /**
         * The host machine's network name.
         * @type {String}
         */
        this.node = '';


        //Assign the constructor values
        if(system !== undefined) {
            this.system = system;
        }
        if(release !== undefined) {
            this.release = release;
        }
        if(version !== undefined) {
            this.version = version;
        }
        if(machine !== undefined) {
            this.machine = machine;
        }
        if(processor !== undefined) {
            this.processor = processor;
        }
        if(node !== undefined) {
            this.node = node;
        }
    };

    /**
     * A container object for service process information.
     * @param {String} [name=''] The name of the process.
     * @param {number} [cpu=0] The percentage of CPU consumed by the process.
     * @param {number} [ram=0] The amount of RAM consumed by the process, in bytes.
     * @param {number} [serverId=null] The associated server ID, if any.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceHealthProcessInfo = function (name, cpu, ram, serverId) {
        /**
         * The name of the process.
         * @type {string}
         */
        this.name = '';

        /**
         * The percentage of CPU consumed by the process.
         * @type {number}
         */
        this.cpu = 0;

        /**
         * The amount of RAM consumed by the process, in bytes.
         * @type {number}
         */
        this.ram = 0;

        /**
         * The associated server ID, if any.
         * @type {number}
         * @deprecated This value is deprecated and will no longer be supported in future versions.
         */
        this.serverId = null;
        
        if(name !== undefined) {
            this.name = name;
        }
        if(cpu !== undefined) {
            this.cpu = cpu;
        }
        if(ram !== undefined) {
            this.ram = ram;
        }
        if(serverId !== undefined) {
            this.serverId = serverId;
        }
    };

    /**
     * A container object for service system information.
     * @param {number} [cores=0] The total number of CPU cores in the system.
     * @param {number} [totalMemory=0] The total physical service memory in bytes
     * @param {number} [availableMemory=0] The available service memory in bytes
     * @param {number} [cpu=0] The total CPU usage of the system as a percentage.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceHealthSystemInfo = function (cores, totalMemory, availableMemory, cpu) {
        /**
         * The total number of CPU cores in the system.
         * @type {number}
         */
        this.cores = 0;

        /**
         * The total amount of memory in the system, in bytes.
         * @type {number}
         */
        this.totalMemory = 0;
        
        /**
         * The available memory in the system, in bytes.
         * @type {number}
         */
        this.availableMemory = 0;
        
        /**
         * The total CPU usage of the system as a percentage.
         * @type {number}
         */
        this.cpu = 0;
        
        if(cores !== undefined) {
            this.cores = cores;
        }
        if(totalMemory !== undefined) {
            this.totalMemory = totalMemory;
        }
        if(availableMemory !== undefined) {
            this.availableMemory = availableMemory;
        }
        if(cpu !== undefined) {
            this.cpu = cpu;
        }
    };    
    
    /**
     * The Service Health object is a container for basic health information about the web service.
     * @param {Number} [uptime=0] How long the web service has been running in seconds
     * @param {EVWEB2.ServerHealth[]} [servers=[]] Array of {@link EVWEB2.ServerHealth} instances
     * @param {EVWEB2.ServiceHealthVersionInfo} [versionInfo=null] Version information associated
     * with the web service.
     * @param {EVWEB2.ServiceHealthOsInfo} [osInfo=null] OS information associated with the web
     * service.
     * @param {EVWEB2.ServiceHealthProcessInfo[]} [processInfo=[]] Process-specific information
     * associated with the web service.
     * @param {EVWEB2.ServiceHealthSystemInfo} [systemInfo=null] System information associated
     * with the web service.
     * @param {EVWEB2.ServiceHealthStreamInfo} [streamInfo=null] Currently processed video stream information
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceHealth = function (uptime, servers, versionInfo, osInfo, processInfo, systemInfo, streamInfo) {
        /**
         * The web service uptime in seconds.
         * @type {number}
         */
        this.uptime = 0;

        /**
         * Array of {@link EVWEB2.ServerHealth} instances for each server the web service is
         * connected to.
         * @type {EVWEB2.ServerHealth[]}
         * @deprecated This value is deprecated and will be removed in future versions. Part of this information will
         * be exposed in a new streams property when it is introduced.
         */
        this.servers = [];

        /**
         * Version information associated with the web service.
         * @type {EVWEB2.ServiceHealthVersionInfo}
         */
        this.versionInfo = null;

        /**
         * OS information associated with the web service.
         * @type {EVWEB2.ServiceHealthOsInfo}
         */
        this.osInfo = null;

        /**
         * Process-specific information associated with the web service.
         * @type {EVWEB2.ServiceHealthProcessInfo[]}
         */
        this.processInfo = [];

        /**
         * System information associated with the web service.
         * @type {EVWEB2.ServiceHealthSystemInfo}
         */
        this.systemInfo = null;

        /**
         * Stream information associated with the web service.
         * @type {EVWEB2.ServiceHealthStreamInfo}
         */
        this.streamInfo = null;

        //Assign the constructor values
        if(uptime !== undefined) {
            this.uptime = uptime;
        }
        if(servers !== undefined) {
            this.servers = servers;
        }
        if(versionInfo !== undefined) {
            this.versionInfo = versionInfo;
        }
        if(osInfo !== undefined) {
            this.osInfo = osInfo;
        }
        if(processInfo !== undefined) {
            this.processInfo = processInfo;
        }
        if(systemInfo !== undefined) {
            this.systemInfo = systemInfo;
        }
        if(streamInfo !== undefined) {
            this.streamInfo = streamInfo;
        }
    };
  
    
}());

/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * Definitions for the type of relay errors
     * @enum {number}
     * @readonly
     * @category Service
     */
    EVWEB2.relayErrors = {
        /**
         * None
         */
        none: 0,
        /**
         * Internal
         */
        internal: 1,
        /**
         * Connection
         */
        connect: 2,
        /**
         * Get Address
         */
        getAddr: 3,
        /**
         * Request
         */
        request: 4,
        /**
         * License
         */
        license: 5,
        /**
         * Login
         */
        login: 6,
        /**
         * Proxy
         */
        proxy: 7
    };


    /**
     * Container class for IP addresses
     * @param {String} address The INET/INET6 address
     * @param {String} [macAddress=''] The hardware/MAC address of the IP (if known)
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceIPAddress = function(address, macAddress) {
        /**
         * The INET/INET6 IP Address
         * @type {string}
         */
        this.address = address;

        /**
         * The hardware/MAC address of the IP
         * @type {string}
         */
        this.mac = '';
        
        // assign the constructor values
        if(macAddress !== undefined) {
            this.mac = macAddress;
        }
    };


    /**
     * Container for information related to the current network configuration of the service.
     * @param {EVWEB2.ServiceIPAddress[]} [internalIp=[]] The IP addresses detected by the service.
     * @param {EVWEB2.ServiceIPAddress} [externalIp=null] The external IP address reported by the service.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceNetworkConfig = function(internalIp, externalIp) {

        /**
         * The IP addresses detected by the service
         * @type {EVWEB2.ServiceIPAddress[]}
         */
        this.internalIp = [];

        /**
         * The IP address reported by the service
         * @type {EVWEB2.ServiceIPAddress}
         */
        this.externalIp = null;
        
        // assign the constructor values
        if(internalIp !== undefined) {
            this.internalIp = internalIp;
        }
        if(externalIp !== undefined) {
            this.externalIp = externalIp;
        }
        
    };


    /**
     * Container object for relay connection status.
     * @param {EVWEB2.relayErrors} [error=EVWEB2.relayErrors.none] A (non-none) error value iff relay is enabled but failed to start.
     * @param {String} [address=''] The public relay address (FQDN) iff relay is enabled and started successfully.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceRelayInfo = function(error, address) {
        /**
         * A (non-none) error value iff relay is enabled but failed to start.
         * @type {EVWEB2.relayErrors}
         */
        this.error = EVWEB2.relayErrors.none;

        /**
         * The public relay address (FQDN) iff relay is enabled and started successfully.
         * @type {String}
         */
        this.address = '';

        if(error !== undefined) {
            this.error = error;
        }
        if(address !== undefined) {
            this.address = address;
        }
    };    


    /**
     * Container for service connectivity status.
     * @param {EVWEB2.ServiceNetworkConfig} networkConfig The network configuration as reported by the service
     * @param {Boolean} [outbound=false] Flag set if outbound connections to the internet can be made by the
     * service. This effects the service's ability to use push notifications, download updates, etc.
     * @param {Boolean} [http=false] Flag set if the configured HTTP port can be reached externally.
     * @param {Boolean} [https=false] Flag set if the configured SSL (HTTPS) port can be reached externally.
     * NOTE: This will always be false if SSL/HTTPS is not configured.
     * @param {Boolean} [ws=false] Flag set if the configured websocket port can be reached externally.
     * @param {Boolean} [wss=false] Flag set if the configured secure websocket (SSL/WSS) port can be reached
     *     externally. NOTE: This will always be false if secure websockets are not configured.
     * @param {EVWEB2.ServiceRelayInfo} [relayInfo=null] Current status of relay connection
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceConnectivity = function(networkConfig, outbound, http, https, ws, wss, relayInfo) {
        /**
         * The network config of the service
         * @type {EVWEB2.ServiceNetworkConfig}
         */
        this.networkConfig = networkConfig;

        /**
         * Whether the service can make outbound connections.
         * @type {boolean}
         */
        this.outbound = false;

        /**
         * Whether the configured HTTP port can be reached externally.
         * @type {boolean}
         */
        this.http = false;

        /**
         * Whether the configured HTTPS port can be reached externally.
         * @type {boolean}
         */
        this.https = false;

        /**
         * Whether the configured websocket port can be reached externally.
         * @type {boolean}
         */
        this.ws = false;

        /**
         * Whether the configured secure websocket port can be reached externally.
         * @type {boolean}
         */
        this.wss = false;

        /**
         * Relay information associated with the web service.
         * @type {EVWEB2.ServiceRelayInfo}
         */
        this.relayInfo = null;

        
        // assign the constructor values
        if(outbound !== undefined) {
            this.outbound = outbound;
        }
        if(http !== undefined) {
            this.http = http;
        }
        if(https !== undefined) {
            this.https = https;
        }
        if(ws !== undefined) {
            this.ws = ws;
        }
        if(wss !== undefined) {
            this.wss = wss;
        }
        if(relayInfo !== undefined) {
            this.relayInfo = relayInfo;
        }
    };
    

    /**
     * Container for information related to the SSL configuration status of the service.
     * @param {Boolean} [https=false] Flag set if SSL is configured and working locally for HTTP
     * @param {Boolean} [wss=false] Flag set if SSL is configured and working locally for websockets
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceSSLStatus = function(https, wss) {
        
        /**
         * Whether the service detects HTTPS is configured and working correctly
         * @type {boolean}
         */
        this.https = false;

        /**
         * Whether the service detects secure websockets are configured and working correctly
         * @type {boolean}
         */
        this.wss = false;

        // assign the constructor values
        if(https !== undefined) {
            this.https = https;
        }
        if(wss !== undefined) {
            this.wss = wss;
        }
    };


    /**
     * Container for push notification related status of the service.
     * @param {Boolean} [certificates=false] Flag whether push notification credentials are properly loaded.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServicePushNotificationStatus = function(certificates) {

        /**
         * Whether push notification credentials are properly loaded
         * @type {boolean}
         */
        this.certificates = false;
        
        // assign the constructor values
        if(certificates !== undefined) {
            this.certificates = certificates;
        }
    };


    /**
     * Container for status related to service updates.
     * @param {Boolean} [reachable=false] Flag set if the configured updates URL is reachable by the service.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceUpdatesStatus = function(reachable) {
        
        /**
         * Whether the updates url is reachable by the service 
         * @type {boolean}
         */
        this.reachable = false;

        // assign the constructor values
        if(reachable !== undefined) {
            this.reachable = reachable;
        }
        
    };

    /**
     * Container for service status information.
     * @param {EVWEB2.ServiceSSLStatus} ssl Status information related to SSL.
     * @param {EVWEB2.ServicePushNotificationStatus} pushNotifications Status information related to push notifications.
     * @param {EVWEB2.ServiceUpdatesStatus} updates Status information related to service updates.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceConfigStatus = function(ssl, pushNotifications, updates) {

        /**
         * Status information related to SSL
         * @type {EVWEB2.ServiceSSLStatus}
         */
        this.ssl = ssl;

        /**
         * Status information related to push notifications
         * @type {EVWEB2.ServicePushNotificationStatus}
         */
        this.pushNotifications = pushNotifications;

        /**
         * Status information related to service updates
         * @type {EVWEB2.ServiceUpdatesStatus}
         */
        this.updates = updates;
    };
    
    
    /**
     * Container class for status related to one of the configured servers.
     * @param {Number} serverId The server ID
     * @param {Boolean} [reachable=false] Flag set if the server is reachable by the web service (or in the case of
     * remote servers if that server is able to connect/reach the service)
     * @param {Boolean} [passthrough=false] Whether the passthrough user account is valid. NOTE: If the server does not
     * have a passthrough user configured this value will always be false.
     * @param {Boolean} [powerUser=false] Whether the power user account is valid. NOTE: If the server does not have a
     * power user configured this value will always be false.
     * @param {Boolean} [remote=false] Flag set if this is a remote server.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServerConfigStatus = function(serverId, reachable, passthrough, powerUser, remote) {
        
        /**
         * The server ID status information is for
         * @type {Number}
         */
        this.id = serverId;

        /**
         * Whether the server is reachable by the web service. If this is a remote server this flag 
         * is set if the remote server can connect to the service.
         * @type {boolean}
         */
        this.reachable = false;

        /**
         * Whether the passthrough user account is valid. NOTE: If the server does not have a
         * passthrough user configured this value will always be false.
         * @type {boolean}
         */
        this.passthrough = false;
        
        /**
         * Whether the power user account is valid. NOTE: If the server does not have a
         * power user configured this value will always be false.
         * @type {boolean}
         */
        this.powerUser = false;

        /**
         * Whether this is a remote server or not
         * @type {boolean}
         */
        this.remote = false;
        
        
        // assign the constructor values
        if(reachable !== undefined) {
            this.reachable = reachable;
        }
        if(passthrough !== undefined) {
            this.passthrough = passthrough;
        }
        if(powerUser !== undefined) {
            this.powerUser = powerUser;
        }
        if(remote !== undefined) {
            this.remote = remote;
        }
    };
    
    
    /**
     * The ServiceStatus acts as a container for information related to the current status of the service.
     * @param {EVWEB2.ServiceConfig} config The service configuration instance
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.ServiceStatus = function(config) {

        /**
         * The containing service configuration for this status.
         * @type {EVWEB2.ServiceConfig}
         */
        this.config = config;
        
        
        /**
         * Check the connectivity of the service including outbound connections and the ability
         * to reach the various configured service ports.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, an {@link EVWEB2.ServiceConnectivity} instance, and a Date object
         * corresponding to the last time the connectivity test was run by the service.
         * @param {Boolean} [force=false]  Force the connectivity test to run preventing the use of any cached
         * results (if any).
         */
        this.checkConnectivity = function(callback, force) {
            var config = this.config;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var internalIps = $.map(data.internalIp, function(value) {
                    return new EVWEB2.ServiceIPAddress(value.address, value.mac);
                });
                var externalIp = new EVWEB2.ServiceIPAddress(data.externalIp);
                var networkConfig = new EVWEB2.ServiceNetworkConfig(internalIps, externalIp);

                var relayInfo;
                if(data.relay !== undefined) {
                    relayInfo = new EVWEB2.ServiceRelayInfo(data.relay.error, data.relay.address);
                } else {
                    relayInfo = null;
                }
                
                var connectivity = new EVWEB2.ServiceConnectivity(networkConfig,
                    data.connectivity.outbound,
                    data.connectivity.http,
                    data.connectivity.https,
                    data.connectivity.ws,
                    data.connectivity.wss,
                    relayInfo);

                var timestamp = EVWEB2.util.IETF2Date(data.lastUpdated);
                    
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, connectivity, timestamp);
            };

            var url = config.service.url() + EVWEB2.urls.serviceConnectivityStatus;
            
            var data = {
                auth: config.authToken
            };
            
            if (force === true) {
                data.force = true;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: url,
                type: 'GET',
                dataType: 'json',
                data: data
            };
            
            EVWEB2.ajax(settings, config.service);
        };


        /**
         * Request the status of the service configuration.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, and an {@link EVWEB2.ServiceConfigStatus} instance.
         */
        this.getConfigStatus = function(callback) {
            var config = this.config;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var sslStatus = new EVWEB2.ServiceSSLStatus(data.ssl.http, data.ssl.ws);
                var pushStatus = new EVWEB2.ServicePushNotificationStatus(data.pushNotifications.certificates);
                var updatesStatus = new EVWEB2.ServiceUpdatesStatus(data.updates);
                var configStatus = new EVWEB2.ServiceConfigStatus(sslStatus, pushStatus, updatesStatus);
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, configStatus);
            };

            var url = config.service.url() + EVWEB2.urls.serviceConfigStatus;

            var data = {
                auth: config.authToken
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: url,
                type: 'GET',
                dataType: 'json',
                data: data
            };

            EVWEB2.ajax(settings, config.service);
        };


        /**
         * Request the status of the service configuration.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance, and {@link EVWEB2.ServerConfigStatus[]} instances.
         */
        this.getServerStatus = function(callback) {
            var config = this.config;

            if(config.authToken === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No authorization.');
                callback(errorResponse);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                var statuses = $.map(data.servers, function(value) {
                    return new EVWEB2.ServerConfigStatus(value.id, value.reachable, value.passthrough, value.poweruser);
                });

                var remoteStatuses = $.map(data.remoteServers, function(value){
                    return new EVWEB2.ServerConfigStatus(value.id, value.connected,
                        value.passthrough, value.poweruser, true);
                });
                
                var all = $.merge(statuses, remoteStatuses);
                callback(successResponse, all);
            };

            var url = config.service.url() + EVWEB2.urls.serviceServerStatus;

            var data = {
                auth: config.authToken
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: url,
                type: 'GET',
                dataType: 'json',
                data: data
            };

            EVWEB2.ajax(settings, config.service);
        };

    };
    
}());

/*globals EVWEB2:true*/
(function() {
    /**
     * Definitions for the possible download update status types available.
     * @enum {Number}
     * @readonly
     * @category Service
     */
    EVWEB2.downloadUpdateStatusTypes = {
        /**
         * Not started
         */
        notStarted: 0,
        /**
         * Downloading
         */
        downloading: 1,
        /**
         * Completed
         */
        completed: 2,
        /**
         * Error
         */
        error: 3
    };

    /**
     * The ServiceUpdateDownloadStatus object represents information about the status of an update download.
     * This is generated as a response to {@link EVWEB2.ServiceUpdate.downloadUpdateStatus}.
     * @param {EVWEB2.downloadUpdateStatusTypes} [status=EVWEB2.downloadUpdateStatusTypes.notStarted]
     * The status of the update download.
     * @param {Number} [currentFileSize=0] The file size of the update currently being downloaded, in bytes.
     * @param {Number} [totalFileSize=0] The total file size of the update, in bytes.
     * @param {EVWEB2.ServiceUpdate} [update=null] The update instance this status is associated with
     * @class
     * @category Service
     */
    EVWEB2.ServiceUpdateDownloadStatus = function(status, currentFileSize, totalFileSize, update) {
        /**
         * The status of the update download.
         * @type EVWEB2.downloadUpdateStatusTypes
         */
        this.status = EVWEB2.downloadUpdateStatusTypes.notStarted;

        /**
         * The current file size of the update, in bytes.
         * @type Number
         */
        this.currentFileSize = 0;

        /**
         * The total file size of the download, in bytes.
         * @type Number
         */
        this.totalFileSize = 0;

        /**
         * The update instance this status is associated with
         * @type EVWEB2.ServiceUpdate
         */
        this.update = null;

        //Assign the constructor values
        if(typeof status !== 'undefined') {
                this.status = status;
        }
        if(typeof currentFileSize !== 'undefined') {
            this.currentFileSize = currentFileSize;
        }
        if(typeof totalFileSize !== 'undefined') {
            this.totalFileSize = totalFileSize;
        }
        if(typeof update !== 'undefined') {
            this.update = update;
        }
    };

    /**
     * The ServiceUpdate object represents information about an available service update.  This
     * is generated as a response to {@link EVWEB2.Service.checkForUpdates}.
     * @param {EVWEB2.Service} [service=null] The service associated with this update
     * check.
     * @param {String} [version=''] The version of this update.
     * @param {String} [updateUrl=''] The URL to the update installer.
     * @param {Boolean} [recommended=false] Boolean flag for whether the type of update is recommended or not.
     * @param {Number} [totalFileSize=0] The total file size of the download, in bytes.
     * @class
     * @category Service
     */
    EVWEB2.ServiceUpdate = function(service, version, updateUrl, recommended, totalFileSize) {
        /**
         * The service associated with the update instance.
         * @type EVWEB2.Service
         */
        this.service = null;

        /**
         * The version of the update.
         * @type String
         */
        this.version = '';

        /**
         * The URL of the update.
         * @type String
         */
        this.updateUrl = '';

        /**
         * Boolean flag for whether the type of update is recommended or not.
         * @type Boolean
         */
        this.recommended = false;

        /**
         * The total file size of the download, in bytes.
         * @type Number
         */
        this.totalFileSize = 0;

        //Assign the constructor values
        if(typeof service !== 'undefined') {
            this.service = service;
        }
        if(typeof version !== 'undefined') {
            this.version = version;
        }
        if(typeof updateUrl !== 'undefined') {
            this.updateUrl = updateUrl;
        }
        if(typeof recommended !== 'undefined') {
            this.recommended = recommended;
        }
        if(typeof totalFileSize !== 'undefined') {
            this.totalFileSize = totalFileSize;
        }

        /**
         * Instructs the service to start downloading the specified update.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance.
         * @param {String} authToken The authorization token retrieved using
         * {@link EVWEB2.Service.config.getAuthorization}
         * @param {Boolean} [useGetRequest=false] Boolean as to whether to force the use of a GET request instead of
         * the default POST request (not recommended).
         */
        this.downloadUpdate = function(callback, authToken, useGetRequest) {
            if(typeof useGetRequest === 'undefined') {
                useGetRequest = false;
            }
            var onDownloadUpdateError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onDownloadUpdateSuccess = function (data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };

            if(!useGetRequest && this.service.isXss()) {
                var errorText = 'This call can not be performed via POST in XSS situations.';
                var errorResponse = new EVWEB2.ResponseStatus(false, errorText);
                callback(errorResponse);
                return;
            }

            var settings = {
                success: onDownloadUpdateSuccess,
                error: onDownloadUpdateError,
                url: this.service.url() + EVWEB2.urls.service,
                type: useGetRequest ? 'GET' : 'POST',
                data: {
                    auth: authToken,
                    action: 'downloadupdate',
                    version: this.version
                }
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Queries for the current status of downloading the update.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance and a
         * {@link EVWEB2.ServiceUpdateDownloadStatus} instance.
         * @param {String} authToken The authorization token retrieved using
         * {@link EVWEB2.Service.config.getAuthorization}
         */
        this.downloadUpdateStatus = function(callback, authToken) {

            var serviceUpdate = this;

            var onDownloadUpdateStatusSuccess = function (data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                var downloadUpdateStatus = new EVWEB2.ServiceUpdateDownloadStatus(data.status, data.current_file_size,
                                                        data.total_file_size, serviceUpdate);

                callback(successResponse, downloadUpdateStatus);
            };

            var onDownloadUpdateStatusError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var settings = {
                success: onDownloadUpdateStatusSuccess,
                error: onDownloadUpdateStatusError,
                url: this.service.url() + EVWEB2.urls.service,
                data: {
                    auth: authToken,
                    action: 'downloadupdatestatus',
                    version: this.version
                }
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
        * Applies the update to the service.  If the update installer has been downloaded
        * (i.e. {@link EVWEB2.ServiceUpdate.downloadUpdate} has been called and has finished)
        * the web service will immediately stop and begin to install the update.
        * @param {Function} callback Callback function to be executed when the call completes.
        * Callback is passed a {@link EVWEB2.ResponseStatus} instance.
        * @param {String} authToken The authorization token retrieved using
        * {@link EVWEB2.Service.config.getAuthorization}
        * @param {Boolean} [useGetRequest=false] Boolean as to whether to force the use of a GET request instead of
        * the default POST request (not recommended).
        */
        this.applyUpdate = function(callback, authToken, useGetRequest) {
            if(typeof useGetRequest === 'undefined') {
                useGetRequest = false;
            }

            var onApplyUpdateError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onApplyUpdateSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var restartPollingConfirmationsRequired = 10;
                var restartPollingMaxRetries = 120;
                var restartPollingInterval = 3000;

                // Start polling to see when the service is back up
                EVWEB2.util.notifyOnServiceRestart(callback, service, restartPollingInterval, restartPollingMaxRetries,
                                                                restartPollingConfirmationsRequired);
            };

            if(!useGetRequest && this.service.isXss()) {
                var errorText = 'This call can not be performed via POST in XSS situations.';
                var errorResponse = new EVWEB2.ResponseStatus(false, errorText);
                callback(errorResponse);
                return;
            }

            var settings = {
                success: onApplyUpdateSuccess,
                error: onApplyUpdateError,
                url: this.service.url() + EVWEB2.urls.service,
                type: useGetRequest ? 'GET' : 'POST',
                data: {
                    auth: authToken,
                    action: 'update',
                    version: this.version
                }
            };

            EVWEB2.ajax(settings, this.service);
        };
    };
}());

/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * Definitions for the possible download update status types available.
     * @enum {string}
     * @readonly
     * @category Service
     */
    EVWEB2.serviceAuthTypes = {
        /**
         * Unknown
         */
        unknown: '',
        /**
         * None
         */
        none: 'none',
        /**
         * Enterprise Manager
         */
        esm: 'esm'
    };

    /**
     * The ServiceAuth object contains information and methods around authentication in the web service.
     * If enabled, an authentication token must be retrieved before any calls to the service can be
     * made.
     * @param {EVWEB2.Service} [service=null] The service associated with this auth instance.
     * @param {EVWEB2.serviceAuthTypes} [type=EVWEB2.serviceAuthTypes.unknown] The type of the authentication used
     * by the web service.
     * @param {Object} [info={}] Additional info associated with this authentication type.  Generally, this
     * provides a URL for the endpoint of authentication.
     * @param {String} [token=''] The authorization token for use in all requests.
     * @param {Date} [expirationDate=null] The date at which the token expires.
     * @class
     * @category Service
     */
    EVWEB2.ServiceAuth = function(service, type, info, token, expirationDate) {
        /**
         * The service associated with the update instance.
         * @type EVWEB2.Service
         */
        this.service = null;

        /**
         * The type of the authentication used by the web service.
         * @type EVWEB2.serviceAuthTypes
         */
        this.type = EVWEB2.serviceAuthTypes.unknown;

        /**
         * Additional info associated with this authentication type.  Generally, this provides
         * a URL for the endpoint of authentication.
         * @type {Object}
         */
        this.info = {};

        /**
         * The authorization token for use in all requests.
         * @type String
         */
        this.token = '';

        /**
         * The date at which the token expires.
         * @type Date
         */
        this.expirationDate = null;

        //Assign the constructor values
        if(service !== undefined) {
            this.service = service;
        }
        if(type !== undefined) {
            this.type = type;
        }
        if(info !== undefined) {
            this.info = info;
        }
        if(token !== undefined) {
            this.token = token;
        }
        if(expirationDate !== undefined) {
            this.expirationDate = expirationDate;
        }

        var instance = this;
        // Load the auth data from the cookie (if the token is not already set)
        if(document !== undefined && document.cookie !== undefined) {
            var cookies = document.cookie.split(';');
            $.each(cookies, function(index, element) {
                var cookiePair = $.trim(element).split('=');
                if(cookiePair[0] === 'token') {
                    instance.token = cookiePair[1];
                }
            });
        }

        /**
         * Retrieves the type of authentication used by this service.  The result of this call
         * is stored on the object, so the network request is only made at types when
         * {@link EVWEB2.ServiceAuth.type} is equal to {@link EVWEB2.serviceAuthTypes.unknown}.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance, the authorization type, and
         * an object of additional auth-type specific info.
         * Note: This value is stored in the object and is only passed to the callback for
         * convenience.
         */
        this.getType = function(callback) {
            var instance = this;

            if(instance.type !== EVWEB2.serviceAuthTypes.unknown) {
                var response = new EVWEB2.ResponseStatus(true);
                callback(response, instance.type, instance.info);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                instance.type = data.type;
                instance.info = data.info;

                var response = new EVWEB2.ResponseStatus(true);
                callback(response, instance.type, instance.info);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.service.url() + EVWEB2.urls.auth,
                type: 'GET',
                data: {
                    output: 'json'
                }
            };

            EVWEB2.ajax(settings, instance.service);
        };

        /**
         * Authenticates with the web service and stores the requested token for use in all
         * future calls.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance, the retrieved token, and
         * the expiration date.  Note: These values are stored in the object and are only passed
         * to the callback for convenience.
         * @param {String} username The username for authentication.
         * @param {String} password The password for authentication.
         */
        this.authenticate = function(callback, username, password) {
            var instance = this;

            var now = new Date();
            if(instance.token !== '' && instance.expirationDate !== null && instance.expirationDate > now) {
                var response = new EVWEB2.ResponseStatus(true);
                callback(response, instance.token, instance.expirationDate);
                return;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                instance.token = data.token;
                instance.expirationDate = EVWEB2.util.IETF2Date(data.expiration);

                var response = new EVWEB2.ResponseStatus(true);
                callback(response, instance.token, instance.expirationDate);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.service.url() + EVWEB2.urls.auth,
                type: 'POST',
                data: {
                    username: username,
                    password: password
                }
            };

            EVWEB2.ajax(settings, instance.service);
        };

        /**
         * Logs out of the current authentication and invalidates the token.
         * @param {Function} [callback] Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance.
         */
        this.logout = function(callback) {
            var instance = this;
            var onError = function(/*xhr, textStatus, errorThrown*/) {
                if(callback !== undefined) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                    callback(errorResponse);
                }
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    if(callback !== undefined) {
                        callback(errorResponse);
                    }
                    return;
                }

                instance.token = '';
                instance.expirationDate = null;
                instance.info = {};

                if(callback !== undefined) {
                    var response = new EVWEB2.ResponseStatus(true);
                    callback(response);
                }
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.service.url() + EVWEB2.urls.authLogout,
                type: 'POST'
            };

            EVWEB2.ajax(settings, instance.service);
        };

        /**
         * Helper method to determine if the authentication is currently valid (i.e.
         * the authentication is present and has not expired).
         * @returns {boolean} Whether the authentication is valid.
         */
        this.isAuthenticated = function() {
            if(this.token === '') {
                return false;
            }
            // There is no way to get the expiration date from a token that's
            // retrieved via a cookie, so expiration will be null with a set
            // token.  In this scenario, assume it's valid.
            return this.expirationDate === null || this.expirationDate > new Date();
        };
    };
}());
/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * A container for a discovered server.  This is a server that has been detected on the local network
     * of the web service.
     * @param {String} address The address of the discovered server.
     * @param {Number} port The port number of the discovered server.
     * @param {String} [name=""] The name of the discovered server.
     * @param {String} [macAddress=""] The MAC address of the discovered server.
     * @param {String} [model=""] The model of the discovered server.
     * @param {String} [serial=""] The serial of the discovered server.
     * @class
     * @category Service
     */
    EVWEB2.DiscoveryServer = function(address, port, name, macAddress, model, serial) {

        /**
         * The address of the discovered server.
         * @type {String}
         */
        this.address = address;

        /**
         * The port number of the discovered server.
         * @type {Number}
         */
        this.port = port;

        /**
         * The name of the discovered server.
         * @type {String}
         */
        this.name = '';

        /**
         * The MAC address of the discovered server.
         * @type {String}
         */
        this.macAddress = '';

        /**
         * The model of the discovered server.
         * @type {String}
         */
        this.model = '';

        /**
         * The serial of the discovered server.
         * @type {String}
         */
        this.serial = '';

        if(name !== undefined) {
            this.name = name;
        }
        if(macAddress !== undefined) {
            this.macAddress = macAddress;
        }
        if(model !== undefined) {
            this.model = model;
        }
        if(serial !== undefined) {
            this.serial = serial;
        }
    };
}());
/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * Definitions for the types of licenses available to servers
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.serverLicenseTypes = {
        /**
         * Unknown
         */
        unknown: -3,
        /**
         * Bad
         */
        bad: -2,
        /**
         * Unlicensed
         */
        unlicensed: -1,
        /**
         * Evaluation
         */
        evaluation: 0,
        /**
         * Licensed
         */
        licensed: 1,
        /**
         * Trial
         */
        trial: 2,
        /**
         * Restricted
         */
        restricted: 3,
        /**
         * Enterprise
         */
        enterprise: 4,
        /**
         * Enterprise-extended
         */
        enterpriseEx: 5
    };

    /**
     * The types of user access levels.
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.accessLevelType = {
        /**
         * Unknown
         */
        unknown: -2,
        /**
         * Delete
         */
        deleteType: -1,  //'delete' is a reserved keyword
        /**
         * None (User belongs to a group)
         */
        none: 3,
        /**
         * Power User
         */
        powerUser: 4,
        /**
         * Full Admin
         */
        fullAdmin: 5,
        /**
         * User Admin
         */
        userAdmin: 6,
        /**
         * Live-only
         */
        liveOnly: 10,
        /**
         * Search-only
         */
        searchOnly: 11,
        /**
         * Live and Search
         */
        liveAndSearch: 12
    };

    /**
     * Definitions for the types of features that can be managed externally on a server.
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.serverManagementFeatures = {
        /**
         * Users
         */
        users: 1,
        /**
         * Failover
         */
        failover: 2
    };

    /**
     * The live permissions for a group.
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.userPermissionsLive = {
        /**
         * Base
         */
        base: 0,
        /**
         * Groups
         */
        groups: 1,
        /**
         * Maps
         */
        maps: 2,
        /**
         * Views
         */
        views: 3,
        /**
         * Quick Replay
         */
        quickReplay: 4,
        /**
         * PTZ
         */
        ptz: 5,
        /**
         * Two-way Audio
         */
        twoWayAudio: 6,
        /**
         * Event Monitoring
         */
        eventMonitor: 7,
        /**
         * Save Image
         */
        saveImage: 8,
        /**
         * Print Image
         */
        printImage: 9,
        /**
         * Cameras
         */
        cameras: 10,
        /**
         * Video Push
         */
        videoPush: 11
    };

    /**
     * The search permissions for a group.
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.userPermissionsSearch = {
        /**
         * Base
         */
        base: 12,
        /**
         * Groups
         */
        groups: 13,
        /**
         * Maps
         */
        maps: 14,
        /**
         * Views
         */
        views: 15,
        /**
         * Events
         */
        events: 16,
        /**
         * Save Image
         */
        saveImage: 17,
        /**
         * Print Image
         */
        printImage: 18,
        /**
         * Burn Disc
         */
        burnDisc: 19,
        /**
         * Export Video
         */
        exportVideo: 20,
        /**
         * Smart Search
         */
        smartSearch: 21,
        /**
         * Cases
         */
        cases: 22,
        /**
         * Cameras
         */
        cameras: 23
    };

    /**
     * The config permissions for a group.
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.userPermissionsConfig = {
        /**
         * User Admin (User can edit other users names, passwords, etc.)
         */
        userAdmin: 24,
        /**
         * View Admin (User can create and see views.)
         */
        viewAdmin: 25,
        /**
         * Case Admin (User can create and see cases.)
         */
        caseAdmin: 26,
        /**
         * User View Admin
         */
        userViewAdmin: 27
    };

    /**
     * The group permissions for a group.
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.userPermissionsGroup = {
        /**
         * Group Video (User is able to see all video.)
         */
        groupVideo: 28,
        /**
         * Group Audio (User can access all audio.)
         */
        groupAudio: 29,
        /**
         * Group Serial (User can access all serial profiles.)
         */
        groupSerial: 30,
        /**
         * Group Soft Trigger (User can control soft triggers.)
         */
        groupSoftTrigger: 31
    };

    /**
     * The available permissions for a group.
     * @type {object}
     * @readonly
     * @category Server
     */
    EVWEB2.userPermissions = {
        /**
         * The live permissions for a group.
         * @type {EVWEB2.userPermissionsLive}
         */
        livePermissions: EVWEB2.userPermissionsLive,

        /**
         * The search permissions for a group.
         * @type {EVWEB2.userPermissionsSearch}
         */
        searchPermissions: EVWEB2.userPermissionsSearch,

        /**
         * The configuration permissions for a group.
         * @type {EVWEB2.userPermissionsConfig}
         */
        configPermissions: EVWEB2.userPermissionsConfig,
        /**
         * The group permissions for a group.
         * @enum {number}
         */
        groupPermissions: EVWEB2.userPermissionsGroup
    };

    /**
     * Bit mask values for user group permissions
     * @type {Object.<string, enum>}
     * @readonly
     * @category Server
     */
    EVWEB2.permissionsBitmask = {
        livePermissions: {
            base: 0x00001,
            groups: 0x00002,
            maps: 0x00004,
            views: 0x00008,
            quickReplay: 0x00010,
            ptz: 0x00020,
            twoWayAudio: 0x00040,
            eventMonitor: 0x00080,
            saveImage: 0x80000,
            printImage: 0x100000,
            cameras: 0x200000,
            videoPush: 0x800000
        },
        searchPermissions: {
            base: 0x00100,
            groups: 0x00200,
            maps: 0x00400,
            views: 0x00800,
            events: 0x01000,
            saveImage: 0x02000,
            printImage: 0x04000,
            burnDisc: 0x08000,
            exportVideo: 0x10000,
            smartSearch: 0x20000,
            cases: 0x40000,
            cameras: 0x400000
        },
        configPermissions: {
            userAdmin: 0x1,              // User can edit other users names, passwords, etc.
            viewAdmin: 0x2,              // User can create and see views.
            caseAdmin: 0x4,              // User can create and see cases.
            userViewAdmin: 0x8
        },
        groupPermissions: {
            groupVideo: 0x1,              // User is able to see all video.
            groupAudio: 0x2,              // User can access all audio.
            groupSerial: 0x4,             // User can access all serial profiles.
            groupSoftTrigger: 0x8         // User can control soft triggers.
        }
    };

    /**
     * Enumeration for errors encountered during server login.
     * @enum {Number}
     * @readonly
     * @category Server
     */
    EVWEB2.serverLoginError = {
        /**
         * Unknown (internal) server error.
         */
        unknown: 0,

        /**
         * Supplied credentials were invalid.
         */
        invalidCredentials: 1,

        /**
         * The number of restricted server connections has been exceeded.
         */
        restrictedLimitReached: 2
    };

    /**
     * The ServerLicenseInfo object represents the license information on the specified server.
     * @param {String} [macAddress=''] The MAC address of the server assigned to this license.
     * @param {Date} [expiration=null] The expiration date for the license.
     * @param {Boolean} [isExpired=true] Whether the server license is expired.
     * @param {Boolean} [isRestricted=false] Whether the server license is restricted.
     * @param {Boolean} [isEnterprise=false] Whether the server license is enterprise.
     * @param {Number} [maxAnalogCameras=0] Number of analog cameras connected to the server.
     * @param {Number} [maxIpCameras=0] Number of ip cameras connected to the server.
     * @param {Number} [maxBoards=0] Number of boards associated with the server.
     * @param {EVWEB2.serverLicenseTypes} [licenseType=EVWEB2.serverLicenseTypes.unknown] The type of license
     * associated with the server.
     * @param {String} [licenseKey=""] The license key associated with the server.
     * @class
     * @category Server
     */
    EVWEB2.ServerLicenseInfo = function(macAddress, expiration, isExpired, isRestricted, isEnterprise, maxAnalogCameras,
                                        maxIpCameras, maxBoards, licenseType, licenseKey) {
        /**
         * Whether the server license is expired.
         * @type Boolean
         */
        this.isExpired = true;

        /**
         * Whether the server license is restricted.
         * @type Boolean
         */
        this.isRestricted = false;

        /**
         * Whether the server license is enterprise.
         * @type Boolean
         */
        this.isEnterprise = false;

        /**
         * The expiration date for the license
         * @type Date
         */
        this.expiration = null;

        /**
         * The MAC address of the server assigned to this license.
         * @type String
         */
        this.macAddress = '';

        /**
         * The number of analog cameras connected to the server.
         * @type Number
         */
        this.maxAnalogCameras = 0;

        /**
         * The number of ip cameras connected to the server.
         * @type Number
         */
        this.maxIpCameras = 0;

        /**
         * The number of boards associated with the server.
         * @type Number
         */
        this.maxBoards = 0;

        /**
         * The type of license associated with the server.
         * @type EVWEB2.serverLicenseTypes
         */
        this.licenseType = EVWEB2.serverLicenseTypes.unknown;

        /**
         * The license key associated with the server.
         * @type String
         */
        this.licenseKey = '';

        //Assign the constructor values
        if(macAddress !== undefined) {
            this.macAddress = macAddress;
        }
        if(expiration !== undefined) {
            this.expiration = expiration;
        }
        if(isExpired !== undefined) {
            this.isExpired = isExpired;
        }
        if(isRestricted !== undefined) {
            this.isRestricted = isRestricted;
        }
        if(isEnterprise !== undefined) {
            this.isEnterprise = isEnterprise;
        }
        if(maxAnalogCameras !== undefined) {
            this.maxAnalogCameras = maxAnalogCameras;
        }
        if(maxIpCameras !== undefined) {
            this.maxIpCameras = maxIpCameras;
        }
        if(maxBoards !== undefined) {
            this.maxBoards = maxBoards;
        }
        if(licenseType !== undefined) {
            this.licenseType = licenseType;
        }
        if(licenseKey !== undefined) {
            this.licenseKey = licenseKey;
        }
    };

    /**
     * The ServerDetailInfo object represents detailed information about the specified server.
     * @param {String} [address=''] The web address for this server.
     * @param {Number} [port=0] The port number for this server.
     * @param {String} [modelNo=''] The model number for this server.
     * @param {String} [serialNo=''] The serial number for this server.
     * @param {String} [version=''] The server software version.
     * @param {Number} [daysRecordedVideo=0] The days of recorded video stored on the server.
     * @class
     * @category Server
     */
    EVWEB2.ServerDetailInfo = function(address, port, modelNo, serialNo, version, daysRecordedVideo) {
        /**
         * The web address for this server.
         * @type String
         */
        this.address = '';

        /**
         * The port number for this server.
         * @type Number
         */
        this.port = 0;

        /**
         * The model number for this server.
         * @type String
         */
        this.modelNo = '';

        /**
         * The serial number for this server.
         * @type String
         */
        this.serialNo = '';

        /**
         * The server software version.
         * @type String
         */
        this.version = '';

        /**
         * The days of recorded video stored on the server.
         * @type Number
         */
        this.daysRecordedVideo = 0;

        //Assign the constructor values
        if(address !== undefined) {
            this.address = address;
        }
        if(port !== undefined) {
            this.port = port;
        }
        if(modelNo !== undefined) {
            this.modelNo = modelNo;
        }
        if(serialNo !== undefined) {
            this.serialNo = serialNo;
        }
        if(version !== undefined) {
            this.version = version;
        }
        if(daysRecordedVideo !== undefined) {
            this.daysRecordedVideo = daysRecordedVideo;
        }
    };

    /**
     * The SystemUsageInfo object represents information about each user on the specified system.
     * @param {String} [username=''] The username of the user.
     * @param {EVWEB2.accessLevelType} [level=EVWEB2.accessLevelType.unknown] The access level of the user.
     * @param {String} [address=''] The IP address of the user.
     * @param {Number} [streams=0] The number of active streams viewed by the user.
     * @param {Boolean} [audit=false] Whether the users' client is audited.
     * @param {String} [instanceName=''] The name of the instance.
     * @class
     * @category Server
     */
    EVWEB2.SystemUsageInfo = function(username, level, address, streams, audit, instanceName) {
        /**
         * The username of the user.
         * @type String
         */
        this.username = '';

        /**
         * The access level of the user.
         * @type EVWEB2.accessLevelType
         */
        this.level = EVWEB2.accessLevelType.unknown;

        /**
         * The IP address of the user.
         * @type String
         */
        this.address = '';

        /**
         * The number of active streams viewed by the user.
         * @type Number
         */
        this.streams = 0;

        /**
         * Whether the users' client is audited.
         * @type Boolean
         */
        this.audit = false;

        /**
         * The instance name.
         * @type Boolean
         */
        this.instanceName = '';

        //Assign the constructor values
        if(username !== undefined) {
            this.username = username;
        }
        if(level !== undefined) {
            this.level = level;
        }
        if(address !== undefined) {
            this.address = address;
        }
        if(streams !== undefined) {
            this.streams = streams;
        }
        if(audit !== undefined) {
            this.audit = audit;
        }
        if(instanceName !== undefined) {
            this.instanceName = instanceName;
        }
    };

    /**
     * The SystemPluginInfo object represents information of each plugin/library on the specified system.
     * @param {String} [name=''] The name of the plugin.
     * @param {String} [filename=''] The file name of the plugin.
     * @param {String} [version=''] The version number of the plugin.
     * @param {Boolean} [status=false] Whether there was an error in accessing the plugin.
     * @param {Number} [errorCode=-1] Error code of the response. Set to 0 if status is true.
     * @class
     * @category Server
     */
    EVWEB2.SystemPluginInfo = function(name, filename, version, status, errorCode) {
        /**
         * The plugin name.
         * @type String
         */
        this.name = '';

        /**
         * The plugin file name.
         * @type String
         */
        this.filename = '';

        /**
         * The plugin version number.
         * @type String
         */
        this.version = '';

        /**
         * The plugin status.
         * @type Boolean
         */
        this.status = false;

        /**
         * The error response.
         * @type Number
         */
        this.errorCode = -1;

        //Assign the constructor values
        if(name !== undefined) {
            this.name = name;
        }
        if(filename !== undefined) {
            this.filename = filename;
        }
        if(version !== undefined) {
            this.version = version;
        }
        if(errorCode !== undefined) {
            this.errorCode = errorCode;
        }
        if(status !== undefined) {
            this.status = status;
            if(this.status) {
                this.errorCode = 0;
            }
        }
    };



    /**
     * The server object is a container for each server attached to the web service backend.
     * It is initially populated from the information retrieved in the {@link EVWEB2.Service.getServers} function
     * and can be used for finding the desired server and further requesting for a login through
     * {@link EVWEB2.Server.login} or requesting the camera feed list through {@link EVWEB2.Server.getCameras}.
     *
     * @param {EVWEB2.Service} [service=null] The service instance for this server.
     * @param {String} [name='Unset'] Name of the server.
     * @param {String} [id=''] ID of the server according to the web service.
     * @param {Boolean} [loginRequired=false] Whether login is required (true = requires login) or passthrough.
     * @param {Boolean} [isRestricted=false] Whether this server is a restricted server or not.
     * @param {String} [sessionId=''] Session Id to be used with this server, used primarily for searches.
     * @param {Number} [gmtOffset=0] Server's GMT offset (timezone).
     * @param {Boolean} [osd=false] Whether the server has OSD enabled for its cameras.
     * @param {EVWEB2.ServerDetailInfo} [detailInfo=null] Additional details about the server configuration.
     * Note: Some of these values are only populated after logging in to the server.
     * @param {EVWEB2.ServerLicenseInfo} [licenseInfo=null] The licensing information about the server. Note: These
     * values are only populated after logging in to the server.
     * @param {EVWEB2.UserGroup|EVWEB2.UserPermissions} [userGroup=null] The group information of the currently logged
     * in user. This parameter is overloaded and also supports the deprecated behavior of passing the permissions object
     * {@link EVWEB2.UserPermissions} of the currently logged in user.
     * @param {EVWEB2.UserGroup|EVWEB2.UserPermissions} [passthroughGroup=null] The group information of the
     * passthrough user. This parameter is overloaded and also supports the deprecated behavior of passing the
     * permissions object {@link EVWEB2.UserPermissions} of the passthrough user.
     * @param {EVWEB2.serverManagementFeatures[]} [managedFeatures=[]] The list of features that are managed by an
     * external service.  Any managed features are not able to be modified by the web service.  For example,
     * if EVWEB2.serverManagedFeatures.user is set, creating, modifying, and deleting users will fail.
     * @param {Boolean} [canAutoLogin=false] Flag determining if the server has stored credentials for this server.
     * @class
     * @constructor
     * @category Server
     */
    EVWEB2.Server = function (service, name, id, loginRequired, isRestricted, sessionId, gmtOffset, osd, detailInfo,
                              licenseInfo, userGroup, passthroughGroup, managedFeatures, canAutoLogin) {
        /**
         * The service instance for this server
         * @type EVWEB2.Service
         */
        this.service = null;

        /**
         * Name of the server
         * @type String
         */
        this.name = 'Unset';

        /**
         * Server ID according to the web service
         * @type String
         */
        this.id = '';

        /**
         * Session ID according to the web service
         * @type String
         */
        this.sessionId = '';

        /**
         * Whether login is required (true = requires login) or passthrough
         * @type Boolean
         */
        this.loginRequired = false;

        /**
         * Whether this server is a restricted server or not
         * @type Boolean
         */
        this.restricted = false;

        /**
         * GMT offset (timezone)
         * @type Number
         */
        this.gmtOffset = 0;

        /**
         * Whether this server has OSD enabled
         * @type Boolean
         */
        this.osd = false;

        /**
         * Username used to log in to the server
         * @type String
         */
        this.username = '';

        /**
         * Additional details about the server configuration. Note: Some of these values are only populated after
         * logging in to the server.
         * @type EVWEB2.ServerDetailInfo
         */
        this.detailInfo = null;

        /**
         * The licensing information about the server. Note: These values are only populated after logging in to the
         * server.
         * @type EVWEB2.ServerLicenseInfo
         */
        this.licenseInfo = null;

        /**
         * The group information of the currently logged in user.
         * @type EVWEB2.UserGroup
         */
        this.userGroup = null;

        /**
         * The group information of the passthrough user.
         * @type EVWEB2.UserGroup
         */
        this.passthroughGroup = null;

        /**
         * The permissions of the currently logged in user.
         * @deprecated This object is deprecated in favor of {@link EVWEB2.UserGroup} which includes information
         * about a group and all its permissions.
         * @type EVWEB2.UserPermissions
         */
        this.userPermissions = null;

        /**
         * The permissions of the passthrough user.
         * @deprecated This object is deprecated in favor of {@link EVWEB2.UserGroup} which includes information
         * about a group and all its permissions.
         * @type EVWEB2.UserPermissions
         */
        this.passthroughPermissions = null;

        /**
         * Wrapping object for all devices configuration information on the server.
         * @type {EVWEB2.ServerConfig}
         */
        this.configuration = new EVWEB2.ServerConfig(this);


        /**
         * Whether or not the server has stored credentials that can be used to login to this server.
         * Effectively passthrough credentials but servers are spawned on demand instead of persistent.
         * @type {boolean}
         */
        this.canAutoLogin = false;

        /**
         * The list of features that are managed by an external service.  Any managed features are
         * not able to be modified by the web service.  For example, if
         * EVWEB2.serverManagedFeatures.user is set, creating, modifying, and deleting users will
         * fail.
         * @type {EVWEB2.serverManagementFeatures[]}
         */
        this.managedFeatures = [];

        /**
         * A reference to this instance, used by closure-contained utility functions.
         * @type {EVWEB2.Server}
         * @internal
         */
        var instance = this;

        //Assign the constructor values
        if(service !== undefined) {
            this.service = service;
        }
        if(name !== undefined) {
            this.name = name;
        }
        if(id !== undefined) {
            this.id = id;
        }
        if(loginRequired !== undefined) {
            this.loginRequired = loginRequired;
        }
        if(isRestricted !== undefined) {
            this.restricted = isRestricted;
        }
        if(sessionId !== undefined) {
            this.sessionId = sessionId;
        }
        else if(!this.loginRequired) {
            //Session ID defaults to the server ID for passthrough servers.
            this.sessionId = this.id;
        }
        if(gmtOffset !== undefined) {
            this.gmtOffset = gmtOffset;
        }
        if(osd !== undefined) {
            this.osd = osd;
        }
        if(detailInfo !== undefined) {
            this.detailInfo = detailInfo;
        }
        if(licenseInfo !== undefined) {
            this.licenseInfo = licenseInfo;
        }

        if(userGroup !== undefined) {
            if(userGroup instanceof EVWEB2.UserPermissions) {
                this.userPermissions = userGroup;

                var userGroupPermissions = EVWEB2.util.internal.generateGroupPermissions(this.userPermissions);
                this.userGroup = new EVWEB2.UserGroup('', undefined, userGroupPermissions, undefined, '', undefined);
            }
            else if(userGroup instanceof EVWEB2.UserGroup) {
                this.userGroup = userGroup;
                this.userPermissions = EVWEB2.util.internal
                    .generateUserPermissions(this.userGroup.permissions, this.userGroup.accessLevel);
            }
        }
        if(passthroughGroup !== undefined) {
            if(passthroughGroup instanceof EVWEB2.UserPermissions) {
                this.passthroughPermissions = passthroughGroup;

                var passthroughGroupPermissions = EVWEB2.util.internal
                    .generateGroupPermissions(this.passthroughPermissions);
                this.passthroughGroup = new EVWEB2.UserGroup('', undefined, passthroughGroupPermissions,
                                                    undefined, '', undefined);
            }
            else if(passthroughGroup instanceof EVWEB2.UserGroup) {
                this.passthroughGroup = passthroughGroup;
                this.passthroughPermissions = EVWEB2.util.internal
                    .generateUserPermissions(this.passthroughGroup.permissions,
                                                    this.passthroughGroup.accessLevel);
            }
        }
        if(managedFeatures !== undefined) {
            this.managedFeatures = managedFeatures;
        }

        if (canAutoLogin !== undefined) {
            this.canAutoLogin = canAutoLogin;
        }


        /**
         * Returns whether the server connection is connected as a passthrough server or through login and password.
         * @return {Boolean} Whether the server connection is a passthrough
         */
        this.isPassthroughServer = function() {
            return !this.loginRequired && this.id === this.sessionId;
        };

        /**
         * Returns whether the server connection is logged in, regardless of the passthrough setting.
         * @return {Boolean} Whether the server connection is logged in
         */
        this.isLoggedIn = function() {
            return this.id !== this.sessionId && this.sessionId !== '';
        };

        /**
         * @deprecated This method is deprecated in favor of {@link EVWEB2.getCurrentGroupPermissions} which returns the
         * permissions associated with a group.
         * Retrieves the current permissions for the server, whether logged in or passthrough.
         * @return {EVWEB2.UserPermissions} The current permissions
         */
        this.getCurrentPermissions = function() {
            if(this.isLoggedIn()) {
                return this.userPermissions;
            }
            return this.passthroughPermissions;
        };

        /**
         * Maps legacy EVWEB2.userPermissions over to the modern container.
         * @param {EVWEB2.UserPermissions} permissions Legacy permissions.
         * @return {EVWEB2.UserGroupPermissions} The converted modern permissions.
         */
        var mapLegacyPermissions = function(permissions) {
            var mapped = [];
            if (permissions.livePermissions) {
                Object.keys(EVWEB2.userPermissionsLive).forEach(function(perm) {
                    if (permissions.livePermissions[perm]) {
                        mapped.push(EVWEB2.userPermissionsLive[perm]);
                    }
                });
            }
            if (permissions.searchPermissions) {
                Object.keys(EVWEB2.userPermissionsSearch).forEach(function(perm) {
                    if (permissions.searchPermissions[perm]) {
                        mapped.push(EVWEB2.userPermissionsSearch[perm]);
                    }
                });
            }
            if (permissions.configPermissions) {
                Object.keys(EVWEB2.userPermissionsConfig).forEach(function(perm) {
                    if (permissions.configPermissions[perm]) {
                        mapped.push(EVWEB2.userPermissionsConfig[perm]);
                    }
                });
            }
            return new EVWEB2.UserGroupPermissions(mapped);
        }

        /**
         * Retrieves the current permissions associated with a group, whether logged in or passthrough.
         * @return {EVWEB2.UserGroupPermissions} The current group permissions
         */
        this.getCurrentGroupPermissions = function() {
            if(this.isLoggedIn()) {
                return this.userGroup ? this.userGroup.permissions : mapLegacyPermissions(this.userPermissions);
            }
            return this.passthroughGroup.permissions;
        };

        /**
         * Retrieves the current group object, whether logged in or passthrough.
         * @return {EVWEB2.UserGroup} The current group
         */
        this.getCurrentGroup = function() {
            if(this.isLoggedIn()) {
                return this.userGroup;
            }
            return this.passthroughGroup;
        };

        /**
         * Processes the JSON output from a login response, updating the current server instance.
         * @param {Object} data The login response data
         * @param {String} username The username
         */
        var processLoginResponse = function(data, username) {
            // Update the session ID and username
            instance.sessionId = data.sessionId;
            instance.username = username;
            if(data.name !== undefined) {
                instance.name = data.name;
            }

            // Update the detailsInfo
            instance.detailInfo =  new EVWEB2.ServerDetailInfo(data.address, data.port, data.model, data.serial,
                data.version, data.daysRecordedVideo);

            var license = data.licenseInfo;
            if(license !== undefined) {
                // Additional server information is available
                var expirationDate = EVWEB2.util.IETF2Date(license.expirationDate);
                instance.licenseInfo = new EVWEB2.ServerLicenseInfo(license.macAddress, expirationDate, license.expired,
                    license.restricted, license.enterprise, license.maxAnalogCameras, license.maxIpCameras,
                    license.maxBoards, license.licenseType, license.licenseKey);
            }

            var userPermissions;
            var customGroupPermissions;

            if(data.group !== undefined && data.group !== null) {
                var group = data.group;

                userPermissions = EVWEB2.util.internal.processUserGroupPermissions(group.permissions);
                customGroupPermissions = new EVWEB2.CustomGroupPermissions(group.cameras, group.audios, group.serials,
                                            group.softTriggers);
                instance.userGroup = new EVWEB2.UserGroup(group.name, group.role, userPermissions, group.priorities,
                                                    group.guid, customGroupPermissions);

                instance.userPermissions = EVWEB2.util.internal.generateUserPermissions(instance.userGroup.permissions,
                                            instance.userGroup.accessLevel);
            }
            else {
                userPermissions = EVWEB2.util.processServerPermissions(data);
                instance.userPermissions = userPermissions;

                var userGroupPermissions = EVWEB2.util.internal.generateGroupPermissions(instance.userPermissions);
                instance.userGroup = new EVWEB2.UserGroup('', undefined, userGroupPermissions,
                    undefined, '', undefined);
            }
        };

        /**
         * The login function is a handler and parser for the authenticated server session functionality
         * of the exacqVision web service.  This function is to be utilized as a method for accessing the targeted
         * server using credentials-based access (instead of a pre-configured passthrough).  It takes the desired
         * username/password combination and requests the server for an authenticated session.  If the request is
         * granted, a unique session ID is applied to the server instance to allow for further communication
         * with the server
         *
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance with the details of the response, the instance of the
         * {@link EVWEB2.Server}, and, if requested, the login session token.
         * @param {String} username The username credential for logging into the server
         * @param {String} password The password credential for logging into the server
         * @param {Boolean} [saveCredentials=false] Whether to save the credentials and generate a login token.
         */
        this.login = function (callback, username, password, saveCredentials) {

            var server = this;

            if(saveCredentials === undefined) {
                saveCredentials = false;
            }

            // Forward-declaring due to circular dependencies
            var processLegacyResponse30;

            var onLoginServerError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                var responseIsJson = false;
                try {
                    JSON.parse(xhr.responseText);
                    responseIsJson = true;
                }
                catch (e) {
                    responseIsJson = false;
                }

                if(xhr.status === 200 && !responseIsJson) {
                    if(xhr.responseText !== EVWEB2.errors.login && xhr.responseText.search('<body>') === -1) {
                        processLegacyResponse30(xhr.responseText, xhr);
                        return;
                    }
                }
                if(xhr.status === 200 || xhr.status === 403) {
                    errorResponse.errorText = 'Incorrect Username/Password.';
                    errorResponse.errorCode = EVWEB2.serverLoginError.invalidCredentials;
                }
                else if(xhr.status === 409) {
                    errorResponse.errorText = 'Restricted server limit reached.';
                    errorResponse.errorCode = EVWEB2.serverLoginError.restrictedLimitReached;
                }
                else if (xhr.status === 500) {
                    errorResponse.errorText = 'Internal Server Error.';
                }

                callback(errorResponse, server);
            };

            /**
             * Processes legacy responses from 3.0 and prior web services.  The response
             * is in the form of a string of the session ID data, a HTTP error response
             * on the XHR object, or the login page template HTML.
             * @param {String} sessionId The session ID of the response.
             * @param {Object} xhr The XHR object of the request.
             */
            processLegacyResponse30 = function(sessionId, xhr) {
                if(sessionId === EVWEB2.errors.login || sessionId.search('<body>') !== -1) {
                    onLoginServerError(xhr);
                    return;
                }
                server.sessionId = sessionId;
                server.username = username;
                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the server list
                callback(successResponse, server);
            };

            /**
             * Processes legacy responses from 3.2-3.8 web services. The response is an object
             * containing the session ID, but no other information, such as detailInfo is
             * provided.
             * @param {Object} data The response data
             * @param {String} username The username used to login
             */
            var processLegacyResponse32_38 = function(data, username) {
                server.sessionId = data.sessionId;
                server.username = username;
            };

            var onLoginServerSuccess = function(data, textStatus, xhr) {
                if(typeof data === 'string') {
                    processLegacyResponse30(data, xhr);
                    return;
                }
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    if(errorResponse.errorText === EVWEB2.errors.jsonLoginFailed) {
                        errorResponse.errorText = 'Incorrect Username/Password.';
                    }
                    callback(errorResponse, server);
                    return;
                }
                if(data.address === undefined && data.name === undefined) {
                    processLegacyResponse32_38(data, username);
                }
                else {
                    processLoginResponse(data, username);
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the server list
                callback(successResponse, server, data.token);
            };

            var settings = {
                success: onLoginServerSuccess,
                error: onLoginServerError,
                url: this.service.url() + EVWEB2.urls.login,
                type: 'POST',
                dataType: 'json',
                data: {
                    u: username,
                    p: password,
                    l: 1,
                    s: this.id,
                    output: 'json',
                    responseVersion: 2
                }
            };

            if(saveCredentials) {
                settings.data.save = '1';
            }

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * The loginToken function is a convenience method for saving login credentials with a valid token
         * takes the place of a password.
         * Note: Tokens expire after one use, be sure to always store the most recently generated token.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response, the instance of the
         *  {@link EVWEB2.Server}, and the generated stored login credentials token.
         * @param {String} username The username credential for logging into the server
         * @param {String} token The stored login credentials token for logging into the server
         */
        this.loginToken = function(callback, username, token) {
            var server = this;

            var onLoginTokenError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse, server);
            };

            var onLoginTokenSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse, server);
                    return;
                }

                processLoginResponse(data, username);

                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the server list
                callback(successResponse, server, data.token);
            };

            var settings = {
                success: onLoginTokenSuccess,
                error: onLoginTokenError,
                url: this.service.url() + EVWEB2.urls.login,
                type: 'POST',
                dataType: 'json',
                data: {
                    u: username,
                    token: token,
                    s: this.id
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Login with stored credentials (this can only be used if the 'canAutoLogin' property is true).
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response, and the {@link EVWEB2.Server}
         *  instance.
         */
        this.loginStoredCredentials = function(callback) {
            var server = this;

            if (!server.canAutoLogin) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No stored credentials available.');
                callback(errorResponse, server);
                return;
            }

            var onLoginStoredCredentialsError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse, server);
            };

            var onLoginStoredCredentialsSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse, server);
                    return;
                }

                processLoginResponse(data, '');

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, server);
            };

            var settings = {
                success: onLoginStoredCredentialsSuccess,
                error: onLoginStoredCredentialsError,
                url: this.service.url() + EVWEB2.urls.login,
                type: 'POST',
                dataType: 'json',
                data: {
                    s: this.id,
                    auto_login: true,
                    output: 'json'
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * The logout function is a simple calling function the performs a call to the exacqVision
         * web service to logout of the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response.
         */
        this.logout = function (callback) {
            var server = this;

            var resetServerItems = function() {
                server.username = '';
                server.sessionId = server.id;
                if(server.userPermissions !== null) {
                    server.userPermissions = null;
                }

                if (server.loginRequired) {
                    if(server.detailInfo !== null) {
                        server.detailInfo.version = '';
                        server.detailInfo.daysRecordedVideo = 0;
                    }
                    if(server.licenseInfo !== null) {
                        server.licenseInfo = null;
                    }
                }
            };

            var onLogoutServerError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                resetServerItems();
                if(typeof callback === 'function') {
                    callback(errorResponse);
                }
            };

            var onLogoutServerSuccess = function(/*data, textStatus, xhr*/) {
                var successResponse = new EVWEB2.ResponseStatus(true);
                resetServerItems();
                if(typeof callback === 'function') {
                    callback(successResponse);
                }
            };

            var settings = {
                success: onLogoutServerSuccess,
                error: onLogoutServerError,
                url: this.service.url() + EVWEB2.urls.logout,
                data: {
                    s: this.sessionId
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        var responseToCameraInstance = function(response, server) {
            var disabled = response.disabled !== 0;
            var video = response.state === 0;
            // The state property is not provided in 2.0 services, so manually add it.
            if(response.state === undefined && response.disabled === 0) {
                video = true;
            }

            var ptz = response.ptz === 1;
            var ptzType = EVWEB2.ptzTypes.none;
            if(ptz) {
                ptzType = EVWEB2.ptzTypes.standard;
            }

            if(response.id === undefined) {
                // Generate the ID from the plugin, interface, device, and context IDs.
                response.id = EVWEB2.util.pidToCameraId(response.p, response.i, response.d, response.ctx);
            }

            var resolution;
            if(response.resolution !== undefined) {
                resolution = new EVWEB2.CameraResolution(response.resolution.width, response.resolution.height);
            }

            return new EVWEB2.Camera(server, response.id, response.ctx, response.name, ptz, disabled, video,
                response.OSD, ptzType, response.digitalPtz, response.formats, resolution, response.quality,
                response.frameRate, response.parentId, response.rotation, response.streamFormats, response.isSearchOnly);
        };

        /**
         *	The getCameras function is meant to act as a handler and parser for list retrieval from the exacqVision
         *	web service back-end.  It uses asynchronous javascript requests to the server for information on
         *	the available camera feeds available from the requested server.  The information received from this call
         *	is then parsed and properly formatted into {@link EVWEB2.Camera} objects that then provide the proper
         *	methods for viewing the camera feeds.
         *
         *  @param {Function} callback Callback function to be executed when the call completes. The function gets
         *  passed three arguments: {@link EVWEB2.ResponseStatus} instance with the details of the response, an array
         *  of {@link EVWEB2.Camera} instances, and a modified instance of {@link EVWEB2.Server}. (Note: The instance
         *  used for the call is modified as well.)
         *  @param {Boolean} [showAll=false] Disable legacy filtering that removes camera sub-contexts that are
         *  quality streams. Sub-contexts saved in views are still returned.
         */
        this.getCameras = function (callback, showAll) {

            if (typeof showAll === 'undefined') {
                showAll = false;
            }

            var onGetCamerasError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };
            var server = this;
            var onGetCamerasSuccess = function(data/*, textStatus, xhr*/) {
                if(data === EVWEB2.errors.config) {
                    //Call the error callback
                    onGetCamerasError();
                    return;
                }

                // v2.0 web services don't return a proper JSON object, as no callback wraps the response.  For these
                // responses, attempt to manually parse the JSON.
                if(typeof data === 'string') {
                    try {
                        data = JSON.parse(data);
                    }
                    catch(err) {
                        onGetCamerasError();
                        return;
                    }
                }

                var resultList = data.Cameras;

                var cameraList = $.map(resultList, function(element) {
                    return responseToCameraInstance(element, server);
                });

                //Update the server with additional information
                if(data.timezone !== undefined) {
                    server.gmtOffset = data.timezone;
                    //TODO: Find out why server.osd is set this way and remove, if possible.
                    server.osd = true;
                }
                if(data.restricted !== undefined) {
                    server.restricted = data.restricted;
                }

                //Return the server list
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, cameraList, server);
            };

            var params = {
                s: this.sessionId,
                output: 'json',
                showAll: showAll ? 1 : 0
            };

            var settings = {
                success: onGetCamerasSuccess,
                error: onGetCamerasError,
                url: this.service.url() + EVWEB2.urls.getCameraList,
                data: params
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         *	The getAudioDevices function is meant to act as a handler and parser for list retrieval from the
         *	exacqVision web service back-end.  It uses asynchronous javascript requests to the server for information
         *	on the available audio inputs available from the requested server.  The information received from this
         *	call is then parsed and properly formatted into {@link EVWEB2.AudioDevice} objects that then provide the
         *	proper methods for using the audio input streams.
         *
         *  @param {Function} callback Callback function to be executed when the call completes. The function gets
         *  passed three arguments: {@link EVWEB2.ResponseStatus} instance with the details of the response and an
         *  array of {@link EVWEB2.AudioDevice} instances.
         */
        this.getAudioDevices = function (callback) {

            var onGetAudioInputsError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };
            var server = this;
            var onGetAudioInputsSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success || data === EVWEB2.errors.config) {
                    //Call the error callback
                    onGetAudioInputsError();
                    return;
                }

                var resultList = data.audio;

                var audioInputList = $.map(resultList, function(element) {
                    return new EVWEB2.AudioDevice(server, element.id, element.name, element.enabled, element.input,
                        element.output, element.format, element.frequency, element.isSearchOnly);
                });

                //Return the server list
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, audioInputList);
            };

            var params = {
                s: this.sessionId,
                output: 'json'
            };

            var settings = {
                success: onGetAudioInputsSuccess,
                error: onGetAudioInputsError,
                url: this.service.url() + EVWEB2.urls.audio,
                data: params
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Starts an export on the selected inputs for the set duration.
         * @param {Function} callback Callback function to be executed when the call
         * completes. Callback is passed a {@link EVWEB2.ResponseStatus} instance and
         * an {@link EVWEB2.VideoExport} instance, which is used to monitor and retrieve
         * the export.
         * @param {EVWEB2.Camera[]|EVWEB2.AudioDevice[]|EVWEB2.SerialDevice} inputs The inputs to export.  Can be a
         * mixed list of {@link EVWEB2.Camera}, {@link EVWEB2.AudioDevice}, and {@link EVWEB2.SerialDevice} instances.
         * @param {EVWEB2.videoExportFormatTypes} format The export format type requested.
         * @param {Date} start Date object representing the beginning of the requested period.
         * @param {Date} end Date object representing the end of the requested period.
         * @param {String} [name="Export"] The file name (without extension) to be given to
         * the download.
         */
        this.videoExport = function (callback, inputs, format, start, end, name) {
            var server = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            /**
             * Handles the success response from starting an export.
             * @param {object} data The response data
             * @param {String} data.export_id The generated export ID
             * @param {Boolean} data.success Whether the request was successful
             * @param {String} data.errorText Any error text associated with a failed request.
             * @param {String[]} data.filenames The filenames for the export.
             */
            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                var videoExport = new EVWEB2.VideoExport(server, data.export_id, inputs, format,
                    start, end, data.filenames);
                if(typeof callback === 'function') {
                    callback(successResponse, videoExport);
                }
            };

            var inputQuery = '';
            var i;
            for(i=0; i<inputs.length; i++) {
                if(inputs[i].id !== undefined) {
                    if(inputQuery.length === 0) {
                        inputQuery += '?';
                    }
                    else {
                        inputQuery += '&';
                    }
                    var queryVal;
                    if(inputs[i] instanceof EVWEB2.Camera) {
                        queryVal = 'camera';
                    }
                    else if(inputs[i] instanceof EVWEB2.AudioDevice ) {
                        queryVal = 'audio';
                    }
                    else if(inputs[i] instanceof EVWEB2.SerialDevice ) {
                        queryVal = 'serial';
                    }
                    inputQuery += queryVal + '='+ inputs[i].id;
                }
            }

            if(name === undefined) {
                name = 'Export';
            }

            var params = {
                s: server.sessionId,
                start: EVWEB2.util.Date2IETF(start),
                end: EVWEB2.util.Date2IETF(end),
                name: name,
                format: format
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: server.service.url() + EVWEB2.urls.videoexport + inputQuery,
                data: params
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Whether calls to this server require resource keys applied to state-changing operations.
         * @return {Boolean} Whether this server requires resource keys
         */
        this.requiresResourceKey = function() {
            return this.isPassthroughServer() && this.service.csrf;
        };

        /**
         * Retrieves the status for the requested items.
         * @param {Function} callback Callback function to be executed when the call
         * completes. Callback is passed a {@link EVWEB2.ResponseStatus} instance and
         * a {@link EVWEB2.Status} instance, which details the status of each requested item.
         * @param {EVWEB2.Camera[]|EVWEB2.Trigger[]|EVWEB2.Map[]} items An array of items to retrieve status.
         * This can be a mixed array of the specified instances.
         */
        this.getStatus = function (callback, items) {
            var server = this;

            var onGetStatusError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onGetStatusSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                var cameraStatuses = $.map(data.camera, function(element) {
                    var instance = $.grep(items, function(item) {
                        return item instanceof EVWEB2.Camera && element.id.toString() === item.id.toString();
                    })[0];
                    return new EVWEB2.StatusCameraItem(instance, element.status.motion, element.status.loss);
                });
                var triggerStatuses = $.map(data.trigger, function(element) {
                    var instance = $.grep(items, function(item) {
                        return item instanceof EVWEB2.Trigger && element.id.toString() === item.id.toString();
                    })[0];
                    return new EVWEB2.StatusTriggerItem(instance, element.status.state);
                });
                var mapStatuses = $.map(data.map, function(element) {
                    var instance = $.grep(items, function(item) {
                        return item instanceof EVWEB2.Map && element.id.toString() === item.id.toString();
                    })[0];
                    return new EVWEB2.StatusMapItem(instance, element.status.motion, element.status.loss);
                });

                var status = new EVWEB2.Status(server, cameraStatuses, triggerStatuses, mapStatuses);
                callback(successResponse, status);
            };

            if(items.length === 0) {
                // If there are no items, just immediately send an empty response.
                var response = {
                    success: true,
                    camera: [],
                    trigger: [],
                    map: []
                };
                onGetStatusSuccess(response);
                return;
            }


            var queryString = $.map(items, function(element) {
                if(element instanceof EVWEB2.Camera) {
                    return 'camera=' + element.id.toString();
                }
                if(element instanceof EVWEB2.Trigger) {
                    return 'trigger=' + element.id.toString();
                }
                if(element instanceof EVWEB2.Map) {
                    return 'map=' + element.id.toString();
                }
            }).join('&');

            var params = {
                s: this.sessionId
            };

            var settings = {
                success: onGetStatusSuccess,
                error: onGetStatusError,
                url: this.service.url() + EVWEB2.urls.status + '?' + queryString,
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Retrieves the overall status for the server.
         * @param {function} callback Callback function to be executed when the call
         * completes. Callback is passed a {@link EVWEB2.ResponseStatus} instance and
         * a {@link EVWEB2.ServerStatus} instance, which details the overall status of the server.
         */
        this.getServerStatus = function (callback) {
            var onServiceGetServersStatus = function(response, statuses) {
                var serverItem;
                if(response.success) {
                    serverItem = statuses[0];
                }
                callback(response, serverItem);
            };

            this.service.getServersStatus(onServiceGetServersStatus, [this]);
        };

        /**
         * Notifies the server that a process is still in use.  This prevents an inactive server from being closed.
         * Note: This does not need to be called on passthrough servers, as they will never be closed.
         * @param {function} [callback] Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance.
         */
        this.notifyUse = function (callback) {
            var executeCallback = function(params) {
                if(callback !== undefined) {
                    callback(params);
                }
            };

            var onNotifyUseError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                executeCallback(errorResponse);
            };

            var onNotifyUseSuccess = function(data/*, textStatus, xhr*/) {
                var successResponse = new EVWEB2.ResponseStatus(data.success, data.errorText);
                executeCallback(successResponse);
            };

            if(!this.isLoggedIn() && !this.isPassthroughServer()) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'Non-logged in servers do not need notification.');
                executeCallback(errorResponse);
                return;
            }

            var settings = {
                success: onNotifyUseSuccess,
                error: onNotifyUseError,
                url: this.service.url() + EVWEB2.urls.login,
                data: {
                    s: this.sessionId,
                    action: 'notify'
                }
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Checks with the server to verify that a process is still available. This prevents making accidental
         * requests to servers that have timed out due to inactivity and are no longer present.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed
         * a {@link EVWEB2.ResponseStatus} instance with the details of the response and a Boolean
         * indicating the validity of the session ID.
         */
        this.checkSession = function (callback) {
            var server = this;
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onCheckSessionError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onCheckSessionSuccess = function(data /*, textStatus, xhr*/){
                var successResponse = new EVWEB2.ResponseStatus(data.success, data.errorText);
                callback(successResponse, data.isValid);
            };

            var settings = {
                success: onCheckSessionSuccess,
                error: onCheckSessionError,
                url: this.service.url() + EVWEB2.urls.login,
                data: {
                    s: this.sessionId,
                    action: 'verify'
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Retrieves the users information for the specified server.
         * @param {function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.SystemUsageInfo} instances,
         * which represent the usage information for each user on the server.
         */
        this.getSystemUsageInfo = function(callback) {
            var server = this;
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onGetSystemUsageInfoError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetSystemUsageInfoSuccess = function(data/*, textStatus, xhr*/) {
               var users = data.users;

               var usersList = $.map(users, function(element) {
                    return new EVWEB2.SystemUsageInfo(element.username, element.level, element.address,
                                                        element.streams, element.audit, element.instanceName);
               });
               var successResponse = new EVWEB2.ResponseStatus(true);
               callback(successResponse, usersList);
            };

            var settings = {
                success: onGetSystemUsageInfoSuccess,
                error: onGetSystemUsageInfoError,
                url: this.service.url() + EVWEB2.urls.serverUsers,
                data: {
                    s: this.sessionId
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Retrieves the plugin information from the specified server.
         * @param {function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.SystemPluginInfo} instances,
         * which represent the version information and status for each plugin/library on the server.
         */
        this.getSystemPluginInfo = function(callback) {
            var server = this;
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onGetSystemPluginInfoError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetSystemPluginInfoSuccess = function(data/*, textStatus, xhr*/) {
                var plugins = data.plugins;

                var pluginsList = $.map(plugins, function(element) {
                    return new EVWEB2.SystemPluginInfo(element.name, element.filename, element.version, element.isOpen,
                                                            element.openCode);
                });
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, pluginsList);
            };

            var settings = {
                success: onGetSystemPluginInfoSuccess,
                error: onGetSystemPluginInfoError,
                url: this.service.url() + EVWEB2.urls.serverPlugins,
                data: {
                    s: this.sessionId
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Get the current configuration information from the system.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and a {@link EVWEB2.SystemConfig} instance.
         */
        this.getSystemInformation = function(callback) {
            var server = this;

            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onGetSystemInfoError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetSystemInfoSuccess = function(data/*, textStatus, xhr*/) {
                var isUtf8Enabled = data.utf8Enabled;
                var systemName = data.systemName;
                var systemHardwareInfo = new EVWEB2.SystemHardwareInfo(data.serialNumber, data.modelNumber,
                    data.motherboard, data.bios, data.processor, data.totalMemory, data.os, data.runningSince);

                var systemConfigInfo = new EVWEB2.SystemConfig(server, systemName, systemHardwareInfo, isUtf8Enabled);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, systemConfigInfo);
            };

            var settings = {
                success: onGetSystemInfoSuccess,
                error: onGetSystemInfoError,
                url: this.service.url() + EVWEB2.urls.systemInfo,
                data: {
                    s: this.sessionId
                }
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Retrieve a list of the custom groups available on the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed
         * a {@link EVWEB2.ResponseStatus} instance, an array of {@link EVWEB2.UserGroup} instances and the associated
         * {@link EVWEB2.Server} instance.
         */
        this.getUserGroups = function(callback) {
            var server = this;
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onGetUserGroupsError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetUserGroupsSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var customGroupsList = data.groups;

                var customUserGroups = $.map(customGroupsList, function(element) {
                    var accessLevel = element.role;

                    var permissions = EVWEB2.util.internal.processUserGroupPermissions(element.permissions);

                    var priorities = $.map(element.priorities, function(elem) {
                        return new EVWEB2.UserGroupPriority(elem.priority, elem.value);
                    });

                    var customGroupPermissions = new EVWEB2.CustomGroupPermissions(element.cameras, element.audios,
                                                        element.serials, element.softTriggers);

                    return new EVWEB2.UserGroup(element.name, accessLevel, permissions, priorities, element.guid,
                                                    customGroupPermissions, element.managed);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, customUserGroups, server);
            };

            var settings = {
                success: onGetUserGroupsSuccess,
                error: onGetUserGroupsError,
                url: this.service.url() + EVWEB2.urls.userGroups,
                data: {
                    s: this.sessionId
                }
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Retrieve a list of users that exist on the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed
         * a {@link EVWEB2.ResponseStatus} instance, an array of {@link EVWEB2.User} instances and the associated
         * {@link EVWEB2.Server} instance.
         */
        this.getUsers = function(callback) {
            var server = this;
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onGetUsersError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetUsersSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var usersList = data.users;
                var users = $.map(usersList, function(element) {
                    return new EVWEB2.User(server, element.name, element.groupName, element.accountType,
                        element.isOrphaned, element.managed);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, users, server);
            };

            var settings = {
                success: onGetUsersSuccess,
                error: onGetUsersError,
                url: this.service.url() + EVWEB2.urls.users,
                data: {
                    s: this.sessionId
                }
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Add a new user to the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed
         * a {@link EVWEB2.ResponseStatus} instance.
         * @param {EVWEB2.UserGroup} userGroup The user group information.
         * @param {EVWEB2.User} user The user to create.
         * @param {String} password The password for the new user account.
         */
        this.addUser = function(callback, userGroup, user, password) {
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onAddUserError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onAddUserSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, user, userGroup, password);
            };

            var bitmask = EVWEB2.util.internal.generatePermissionsBitmask(userGroup.permissions);

            var params = {
                s: this.sessionId,
                name: user.username,
                password: password,
                role: userGroup.accessLevel,
                accountType: user.accountType,
                guid: userGroup.guid,
                grpName: userGroup.name,
                grpGroupPermission: bitmask.group,
                grpUserPermission: bitmask.user,
                grpAdminPermission: bitmask.admin,
                grpCameras: userGroup.customGroupPermissions.cameras.join(","),
                grpAudios: userGroup.customGroupPermissions.audios.join(","),
                grpSerials: userGroup.customGroupPermissions.serials.join(","),
                grpSoftTriggers: userGroup.customGroupPermissions.softTriggers.join(",")
            };

            var priority = userGroup.getPriority(EVWEB2.groupPriorityTypes.ptz);
            if (priority !== undefined){
                params['grpPtzPriority'] = priority.value;
            }

            priority = userGroup.getPriority(EVWEB2.groupPriorityTypes.twoWayAudio);
            if (priority !== undefined){
                params['grpAudioPriority'] = priority.value;
            }

            priority = userGroup.getPriority(EVWEB2.groupPriorityTypes.client);
            if (priority !== undefined){
                params['grpRemotePriority'] = priority.value;
            }

            var settings = {
                success: onAddUserSuccess,
                error: onAddUserError,
                url: this.service.url() + EVWEB2.urls.users,
                type: 'POST',
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Retrieves the security integrations devices for this server.
         * @param {function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         *  {@link EVWEB2.SecurityIntegrationsDevice} objects detailing all of the security integrations devices
         *   associated with the
         *  server.
         */
        this.getSecurityIntegrationsDevices = function(callback) {
            var server = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                // Process the devices
                var devices = $.map(data.devices, function(element) {
                    return new EVWEB2.SecurityIntegrationsDevice(server, element.id, element.name, element.host,
                        element.port, element.type, element.enabled, element.connectionStatus, element.firmware,
                        element.serial, element.user, element.auth);
                });

                callback(successResponse, devices);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: server.service.url() + EVWEB2.urls.securityIntegrationDevices,
                data: {
                    s: server.sessionId
                }
            };

            if(server.service.isXss()) {
                EVWEB2.util.updateRequestForXss(settings);
            }
            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Retrieves the basic serial configuration information.
         * @param {function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an
         *  {@link EVWEB2.ServerSerialSupport} instance.
         */
        this.getSerialInfo = function(callback) {
            var server = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                var dataSupports = data.serial.supports;
                var serialSupports = new EVWEB2.ServerSerialFunctionality(dataSupports.advancedLineEnding,
                    dataSupports.sotMarkers, dataSupports.xmlFormatting, dataSupports.replace, dataSupports.rules);
                var serialInfo = new EVWEB2.ServerSerialSupport(server, serialSupports, data.serial.uart,
                    data.serial.ip, data.serial.uses, data.serial.ipTypes);

                callback(successResponse, serialInfo);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: server.service.url() + EVWEB2.urls.serverSerialInfo,
                data: {
                    s: server.sessionId
                }
            };

            EVWEB2.ajax(settings, server.service);

        };

        /**
         * Retrieves a list of serial devices on this server.
         * @param {function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         *  {@link EVWEB2.SerialDevice} objects.
         */
        this.getSerialDevices = function(callback) {
            var server = this;

            /**
             * Maps serial device data received from the web service to a {@link EVWEB2.SerialDevice} instance.
             * @private
             * @param {Array} data Array of data objects to convert
             * @param {EVWEB2.SerialDeviceTypes} type The type of data represented.
             * @return {EVWEB2.SerialDevice} The serial device
             */
            var dataToSerialDevice = function(data, type) {
                return $.map(data, function(element) {
                    var connectionInfo;
                    if(type === EVWEB2.SerialDeviceTypes.Uart) {
                        connectionInfo = new EVWEB2.UartSerialDeviceConnectionInfo(element.port, element.baudRate,
                            element.dataBits, element.stopBits, element.parity, element.flowControl);
                    }
                    else if(type === EVWEB2.SerialDeviceTypes.Ip) {
                        connectionInfo = new EVWEB2.IpSerialDeviceConnectionInfo(element.address, element.type,
                            element.ipPort, element.remotePort);
                    }

                    var lineInfo = new EVWEB2.SerialDeviceLineInfo(element.maxLineLength, element.lineEnding,
                        element.timeout);

                    return new EVWEB2.SerialDevice(server, element.id, element.name, connectionInfo, lineInfo,
                        element.use, type, element.profile);

                });
            };

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                var devices = dataToSerialDevice(data.uart, EVWEB2.SerialDeviceTypes.Uart);

                devices = devices.concat(dataToSerialDevice(data.ip, EVWEB2.SerialDeviceTypes.Ip));

                callback(successResponse, devices);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: server.service.url() + EVWEB2.urls.serialDevices,
                data: {
                    s: server.sessionId
                }
            };

            EVWEB2.ajax(settings, server.service);

        };

        /**
         * Retrieves a list of serial profiles on this server.
         * @param {function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         *  {@link EVWEB2.SerialProfile} objects.
         */
        this.getSerialProfiles  = function(callback) {
            var server = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                var devices = $.map(data.profiles, function(element) {
                    var display = element.display;
                    var fontInfo = new EVWEB2.FontInfo(display.fontName, display.fontSize, display.fontStyle,
                        display.fontColor, display.fontFamily, display.fontWeight, display.underline);
                    var caseSens = element.caseSensitivity;
                    var caseSensitivity = new EVWEB2.SerialCaseSensitivity(caseSens.transmissionMarkers,
                        caseSens.keywords, caseSens.masks, caseSens.replacements, caseSens.rules);
                    var mark = element.markers;
                    var markers = new EVWEB2.SerialProfileMarkers(mark.type, mark.start, mark.end);
                    return new EVWEB2.SerialProfile(server, element.id, element.name, fontInfo, caseSensitivity,
                        markers, element.retention);
                });

                callback(successResponse, devices);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: server.service.url() + EVWEB2.urls.serialProfiles,
                data: {
                    s: server.sessionId
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Retrieves a list of active events on this server.
         * @param {function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         *  {@link EVWEB2.Event} objects.
         * @param {EVWEB2.EventType[]} [filter=[]] An array of event types to filter with.  If none are specified,
         *  all events are returned.
         */
        this.getEvents = function(callback, filter) {
            var server = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                var events = $.map(data.events, function(element) {
                    var extraInfo;
                    if(element.extra !== undefined) {
                        extraInfo = new EVWEB2.EventExtraInfo(server, element.extra.item, element.extra.type);
                    }
                    return new EVWEB2.Event(server, element.event, EVWEB2.util.IETF2Date(element.time),
                        element.device, extraInfo);
                });

                callback(successResponse, events);
            };

            var data = {
                s: server.sessionId
            };
            if(filter !== undefined) {
                data.filter = filter;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: server.service.url() + EVWEB2.urls.events,
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Callback invoked by
         * {@link EVWEB2.Server#getAnalyticRules|getAnalyticRules()}.
         * @callback EVWEB2.Server~onGetAnalyticRules
         * @param {EVWEB2.ResponseStatus} response Success state of the response.
         * @param {EVWEB2.AnalyticRule[]} rules The analytic rules configured on this server.
         */
        /**
         * List analytic rules on this server.
         * @param {EVWEB2.Server~onGetAnalyticRules} callback Callback to be invoked on completion.
         */
        this.getAnalyticRules = function(callback) {
            var server = this;

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if (!data.success) {
                    callback(new EVWEB2.ResponseStatus(false, data.errorText));
                    return;
                }

                var rules = data.rules.map(function(rule) {
                    var osdConfig = new EVWEB2.AnalyticRuleOSDConfig(
                        EVWEB2.util.RGBA(rule.osdInfo.bgColor, rule.osdInfo.bgOpacity),
                        EVWEB2.util.RGBA(rule.osdInfo.borderColor, rule.osdInfo.borderOpacity)
                    );

                    // this endpoint existed for one quarter (19.06 release) without the templates list,
                    // don't choke on mapping if it isn't present
                    var metadataTemplates;
                    if (rule.metadataTemplates) {
                        metadataTemplates = rule.metadataTemplates.map(function(template) {
                            return new EVWEB2.EventMetadataTemplate(template.key, template.valueType);
                        });
                    }

                    var source;
                    if (rule.sourceType === EVWEB2.analyticRuleSourceType.camera) {
                        source = new EVWEB2.AssociatedCameraSource(rule.sourceId.id);
                    } else if (rule.sourceType === EVWEB2.analyticRuleSourceType.audio) {
                        source = new EVWEB2.AssociatedAudioSource(rule.sourceId.id);
                    }
                    return new EVWEB2.AnalyticRule(server, rule.ruleId, rule.deviceId, source, rule.name, osdConfig,
                        rule.metadataEnabled, metadataTemplates);
                });
                callback(new EVWEB2.ResponseStatus(true), rules);
            };
            var onError = function(xhr/*,textStatus, errorThrown*/) {
                callback(new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr)));
            };

            EVWEB2.ajax({
                method: 'GET',
                url: this.service.url() + EVWEB2.urls.analyticRules,
                data: {
                    s: this.sessionId
                },
                success: onSuccess,
                error: onError
            }, this.service);
        };
    };
}());

/*globals EVWEB2:true*/
(function() {
    /**
     * Definitions for the trigger states (On/Off) used by {@link EVWEB2.Trigger.toggle}
     * @enum {number}
     * @readonly
     * @category Soft Triggers
     */
    EVWEB2.triggerState = {
        /**
         * Off
         */
        off: 0,
        /**
         * On
         */
        on: 1,
        /**
         * Unknown
         */
        unknown: -1
    };

    /**
     * The Trigger object is a wrapped object that handles the control of a soft trigger on a server. The objects are
     * generated in an array from {@link EVWEB2.getTriggers} that will retrieve the soft triggers available on a
     * server.  The object holds the polling timer for keeping a trigger held to "on" (as triggers automatically
     * turn off after 5 seconds).
     * @param {EVWEB2.Server} [server=null] The server instance of the trigger.
     * @param {String} [id=''] The ID of the trigger.
     * @param {String} [name='Unnamed Trigger'] The name of the trigger.
     * @param {EVWEB2.triggerState} [state=EVWEB2.triggerState.unknown] The state of the soft trigger.
     * @class
     * @category Soft Triggers
     */
    EVWEB2.Trigger = function (server, id, name, state) {
        /**
         * Server the soft trigger belongs to
         * @type EVWEB2.Server
         */
        this.server = null;

        /**
         * ID of the soft trigger on the server
         * @type String
         */
        this.id = '';

        /**
         * Name of the soft trigger
         * @type String
         */
        this.name = 'Unnamed Trigger';

        /**
         * State of the soft trigger
         * @type EVWEB2.triggerState
         */
        this.state = EVWEB2.triggerState.unknown;

        /**
         * The interval key for polling a trigger.
         * @private
         * @type Number
         */
        var triggerCheckInterval = -1;

        /**
         * An internally-scoped reference to this.
         * @private
         * @type Object
         */
        var self = this;

        //Assign the constructor values
        if(typeof server !== 'undefined') {
            this.server = server;
        }
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof name !== 'undefined') {
            this.name = name;
        }
        if(typeof state !== 'undefined') {
            this.state = state;
        }

        /**
         * @ignore
         */
        var triggerCheck = function() {
            self.toggle(EVWEB2.triggerState.on);
        };

        /**
         *  The toggle method is used to toggle the trigger on or off.  If it is being turned on,
         *  a timer will be set to continue polling the server that the trigger is on to preserve the state
         *  until the switch is set to off.  If no state parameter is given, the state will toggle.
         *  @param {EVWEB2.triggerState} [state] The new state of the trigger
         *  @return {EVWEB2.triggerState} The updated state
         */
        this.toggle = function (state) {
            //Update the state
            if (typeof state === "undefined") {
                //Toggle the state
                if (this.state === EVWEB2.triggerState.off) {
                    this.state = EVWEB2.triggerState.on;
                }
                else {
                    this.state = EVWEB2.triggerState.off;
                }
            } else {
                this.state = state;
            }
            if(this.state === EVWEB2.triggerState.off) {
                // turn off timer
                clearInterval(triggerCheckInterval);
                triggerCheckInterval = -1;
            }
            else {
                // establish timer
                if(triggerCheckInterval === -1) {
                    triggerCheckInterval = setInterval(triggerCheck, EVWEB2.config.triggerPollingRate);
                }
            }

            var params = {
                s: this.server.sessionId,
                tid: this.id,
                state: this.state === EVWEB2.triggerState.off ? 'off' : 'on'
            };

            if (this.server.requiresResourceKey()) {
                if (this.server.service.resourceKey === '') {
                    clearInterval(triggerCheckInterval);
                    throw new Error("CSRF enforced, passthrough will not work.");
                }
                params.key = this.server.service.resourceKey;
            }

            var settings = {
                url: this.server.service.url() + EVWEB2.urls.trigger,
                type: 'POST',
                dataType: 'text',
                data: params
            };
            EVWEB2.ajax(settings, this.server.service, true);
            return this.state;
        };
    };

    /**
     * The getTriggers function is a retrieval function that will make a call for data from the exacqVision web
     * service back-end for a list of the soft triggers available on the designated server.  The function will
     * make the request from the server and parse the data returned to generate an array of the {@link EVWEB2.Trigger}
     * instances that will handle the calls to set the triggers as needed.
     *
     * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
     *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
     *  {@link EVWEB2.Trigger} instances.
     * @param {EVWEB2.Server} server The target server.
     * @category Soft Triggers
     */
    EVWEB2.getTriggers = function (callback, server) {
        var onGetTriggersError = function(/*xhr, textStatus, errorThrown*/) {
            var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
            callback(errorResponse);
        };

        var onGetTriggersSuccess = function(data/*, textStatus, xhr*/) {
            if(data === EVWEB2.errors.triggers) {
                //Call the error callback
                onGetTriggersError();
                return;
            }
            var resultList = data.Triggers;

            var triggerList = $.map(resultList, function(element) {
                return new EVWEB2.Trigger(server, element.id, element.name, element.state);
            });
            var successResponse = new EVWEB2.ResponseStatus(true);
            //Return the server list
            callback(successResponse, triggerList, server);
        };

        var settings = {
            success: onGetTriggersSuccess,
            error: onGetTriggersError,
            url: server.service.url() + EVWEB2.urls.trigger,
            data: {
                s: server.sessionId
            }
        };

        EVWEB2.ajax(settings, server.service);
    };

}());
/*globals EVWEB2:true*/
(function() {

    "use strict";

    /**
     * Definitions for types of View slot items returned from the server.
     * @enum {number}
     * @readonly
     * @category Views
     */
    EVWEB2.ViewSlotItemTypes = {
        /**
         * None
         */
        none: 0,
        /**
         * Camera
         */
        camera: 1,
        /**
         * Audio
         */
        audio: 2,
        /**
         * Serial
         */
        serial: 3,
        /**
         * Group
         */
        group: 4,
        /**
         * Soft Trigger
         */
        softTrigger: 5,
        /**
         * I/O Trigger
         */
        ioTrigger: 6,
        /**
         * Time Trigger
         */
        timeTrigger: 7
    };

    /**
     * The ViewFolder object is a wrapped object that represents a folder containing one or more views or folders.
     * The objects are generated in an array from {@link EVWEB2.getViews}.
     * @param {String} [id=''] The ID of the View Folder.
     * @param {String} [name=''] The name of the View Folder.
     * @param {String} [parentId=''] The parent ID of the View Folder.
     * @class
     * @category Views
     */
    EVWEB2.ViewFolder = function(id, name, parentId) {
        /**
         * The ID of the view folder
         * @type String
         */
        this.id = '';

        /**
         * Name of the view folder
         * @type String
         */
        this.name = '';

        /**
         * The ID of the view folder's parent folder
         * @type String
         */
        this.parentId = '';

        //Assign the constructor values
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof name !== 'undefined') {
            this.name = name;
        }
        if(typeof parentId !== 'undefined') {
            this.parentId = parentId;
        }
    };

    /**
     * The ViewSlotItem object is a wrapped object that represents an item associated with a view. The objects are
     * generated in an array from {@link EVWEB2.Service.getViews}.
     * @param {String} [id=''] The ID of the associated item.
     * @param {EVWEB2.Server} [server=null] The server instance of the associated camera.
     * @param {Function} [type=null] The type reference of the item.
     * @param {Number} [slotIndex=0] The layout slot index that this view item corresponds to.
     * @param {EVWEB2.digitalPtzTypes} [digitalPtzType=null] The digital PTZ ID of the associated camera, if present.
     * @class
     * @constructor
     * @category Views
     */
    EVWEB2.ViewSlotItem = function(id, server, type, slotIndex, digitalPtzType) {
        /**
         * The ID of the item
         * @type String
         */
        this.id = '';

        /**
         * The ID of the server
         * @type String
         */
        this.server = '';

        /**
         * The server instance of the associated camera
         * @type EVWEB2.Server
         */
        this.serverInstance = null;

        /**
         * The type of the item (a reference to an EVWEB2 class)
         * @type Object
         */
        this.type = null;

        /**
         * The slot index for this item.
         * @type Number
         */
        this.slotIndex = 0;

        /**
         * The ID of the digital PTZ camera
         * @type EVWEB2.digitalPtzTypes
         */
        this.digitalPtzType = null;

        //Assign the constructor values
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof server !== 'undefined') {
            this.server = server.id;
            this.serverInstance = server;
        }
        if(typeof type !== 'undefined') {
            this.type = type;
        }
        if(typeof slotIndex !== 'undefined') {
            this.slotIndex = slotIndex;
        }
        if(typeof digitalPtzType !== 'undefined') {
            this.digitalPtzType = digitalPtzType;
        }
    };


    /**
     * The ViewCameraInfo object is a wrapped object that represents a camera associated with a view. The objects are
     * generated in an array from {@link EVWEB2.getViews}.
     * Note: This class is only used in association with {@link EVWEB2.View.cameras} and has been deprecated in favor
     * of {@link EVWEB2.ViewSlotItem}.
     * @deprecated See {@link EVWEB2.ViewSlotItem} for non-deprecated usage.
     * @param {String} [camera=''] The camera ID of the associated camera.
     * @param {EVWEB2.Server} [server=null] The server instance of the associated camera.
     * @param {EVWEB2.digitalPtzTypes} [digitalPtzType=null] The digital PTZ ID of the associated camera, if present.
     * @class
     * @constructor
     * @category Views
     */
    EVWEB2.ViewCameraInfo = function(camera, server, digitalPtzType) {
        /**
         * The ID of the camera
         * @type String
         */
        this.camera = '';

        /**
         * The ID of the server
         * @type String
         */
        this.server = '';

        /**
         * The server instance of the associated camera
         * @type EVWEB2.Server
         */
        this.serverInstance = null;

        /**
         * The ID of the digital PTZ camera
         * @type EVWEB2.digitalPtzTypes
         */
        this.digitalPtzType = null;

        //Assign the constructor values
        if(typeof camera !== 'undefined') {
            this.camera = camera;
        }
        if(typeof server !== 'undefined') {
            this.server = server.id;
            this.serverInstance = server;
        }
        if(typeof digitalPtzType !== 'undefined') {
            this.digitalPtzType = digitalPtzType;
        }
    };

    /**
     * The ViewCameraInfo object is a wrapped object that represents a camera associated with a view. The objects are
     * generated in an array from {@link EVWEB2.getViews}.
     * @param {String} [id=''] The ID of the associated audio input.
     * @param {EVWEB2.Server} [server=null] The server instance of the associated camera.
     * @deprecated See {@link EVWEB2.ViewSlotItem} for non-deprecated usage.
     * @class
     * @constructor
     * @category Views
     */
    EVWEB2.ViewAudioInputInfo = function(id, server) {
        /**
         * The ID of the associated audio input.
         * @type String
         */
        this.id = '';

        /**
         * The ID of the server
         * @type String
         */
        this.server = '';

        /**
         * The server instance of the associated camera
         * @type EVWEB2.Server
         */
        this.serverInstance = null;

        //Assign the constructor values
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof server !== 'undefined') {
            this.server = server.id;
            this.serverInstance = server;
        }
    };

    /**
     * The View object is a wrapped set of information for a server side view.  It just holds the properties of an
     * individual view.
     * @param {String} [name='Unnamed'] Name of the view.
     * @param {EVWEB2.ViewFolder} [folder=null] The view's container folder.
     * @param {EVWEB2.ViewSlotItem[]} [items=[]] Array of the items in the view.  Note: This class also supports an
     * array of {@link EVWEB2.ViewCameraInfo} for this property to retain legacy support.
     * @param {Number} [layout=-1] Number of video panels in this view.
     * @param {EVWEB2.Layout} [layoutInfo=null] Custom layout information for the view.
     * @param {Number} [order=-1] Order value for the view, used in sorting the view list.
     * @param {EVWEB2.ViewAudioInputInfo} [audioInput=null] The audio input in the view.
     * @param {String} [description=''] Description of the view.
     * @param {String} [id=''] ID of the view.
     * @class
     * @category Views
     */
    EVWEB2.View = function (name, folder, items, layout, layoutInfo, order, audioInput, description, id) {
        /**
         * ID of the view
         * @type String
         */
        this.id = "";

        /**
         * Name of the view
         * @type String
         */
        this.name = "Unnamed";

        /**
         * The ID of the View's container folder
         * @type EVWEB2.ViewFolder
         */
        this.folder = null;

        /**
         * Array of the objects in the view
         * @type EVWEB2.ViewSlotItem[]
         */
        this.items = [];

        /**
         * Array of the cameras in the view
         * @deprecated See {@link EVWEB2.View.items}
         * @type EVWEB2.ViewCameraInfo[]
         */
        this.cameras = [];

        /**
         * Number of video panels in this view
         * @type Number
         */
        this.layout = -1;

        /**
         * Layout information for the view
         * @type EVWEB2.Layout
         */
        this.layoutInfo = null;

        /**
         * Order value for the view, used in sorting the view list
         * @type Number
         */
        this.order = -1;

        /**
         * Audio input applied to this view
         * @deprecated See {@link EVWEB2.View.items}
         * @type EVWEB2.ViewAudioInputInfo
         */
        this.audioInput = null;

        /**
         * Description of the view
         * @type String
         */
        this.description = "";

        //Assign the constructor values
        if(id !== undefined) {
            this.id = id;
        }
        if(name !== undefined) {
            this.name = name;
        }
        if(folder !== undefined) {
            this.folder = folder;
        }
        if( layout !== undefined) {
            this.layout = layout;
        }
        if(layoutInfo !== undefined) {
            this.layoutInfo = layoutInfo;
        }
        if(items !== undefined) {
            var itemsAreCameraInfo = $.grep(items, function(element) {
                return element instanceof EVWEB2.ViewCameraInfo;
            }).length > 0;

            if(itemsAreCameraInfo) {
                // Process the legacy formats
                this.items = $.map(items, function(element, index) {
                    if(element !== null) {
                        return new EVWEB2.ViewSlotItem(element.camera, element.serverInstance, EVWEB2.Camera, index,
                            element.digitalPtzType);
                    }
                });
                this.cameras = items;
            }
            else {
                this.items = items;
                this.cameras = [];

                var cameraItems = $.grep(this.items, function(element) {
                    return element.type === EVWEB2.Camera;
                });

                // Create an array of null items that is the size of the layout
                var camerasSize = cameraItems.length;
                if(this.layout !== -1) {
                    camerasSize = this.layout;
                }
                var i;
                for(i=0; i<camerasSize; i++) {
                    this.cameras[i] = null;
                }
                // Add in the view camera infos
                var instance = this;
                $.each(cameraItems, function(index, element) {
                    instance.cameras[element.slotIndex] = new EVWEB2.ViewCameraInfo(parseInt(element.id, 10),
                        element.serverInstance, element.digitalPtzType);
                });
                // Set the audio input value
                var audioItem = $.grep(this.items, function(element) {
                    return element.type === EVWEB2.AudioDevice;
                })[0];
                if(audioItem !== undefined) {
                    this.audioInput = new EVWEB2.ViewAudioInputInfo(audioItem.id, audioItem.serverInstance);
                }
            }
        }
        if(order !== undefined) {
            this.order = order;
        }
        if(audioInput !== undefined) {
            // Set the deprecated value
            this.audioInput = audioInput;

            // Add it to the items list.
            var audio = $.grep(this.items, function(element) {
                return element.type === EVWEB2.AudioDevice;
            })[0];
            if(audio === undefined) {
                this.items.push(
                    new EVWEB2.ViewSlotItem(audioInput.id, audioInput.serverInstance, EVWEB2.AudioDevice, 0));
            }
        }
        if(description !== undefined) {
            this.description = description;
        }

        /**
         * Applies the current digital PTZ settings for the selected slot in the view.  The provided camera must be a
         * created digital PTZ camera from the camera for the slot identified in {@link EVWEB2.View#cameras}.
         * This method is deprecated in favor of {@link EVWEB2.Camera.createDigitalPtzCamera}, which will also apply
         * any view-specific digital PTZ settings.  Additionally, this method does not support applying digital PTZ
         * settings for views received as a {@link EVWEB2.VideoPushMessage}.
         * @deprecated
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and the passed digital PTZ camera
         *  instance.
         * @param {Number} slot The slot in the view.
         * @param {EVWEB2.Camera} camera The digital PTZ camera to apply the settings.
         */
        this.applyDigitalPtzSettingsForSlot = function(callback, slot, camera) {
            var slotInfo = this.cameras[slot];

            var errorText;
            if(
                typeof slotInfo === 'undefined' ||
                slotInfo === null ||
                slotInfo.digitalPtzType === null
               ) {
                errorText = 'This view slot does not support digital PTZ.';
            }
            else if(camera.ptzType !== EVWEB2.ptzTypes.digital) {
                errorText = 'The provided camera is not a digital PTZ camera.';
            }
            else if(camera.sourceCamera.id !== slotInfo.camera) {
                errorText = 'The provided digital PTZ camera is not derived from the camera for this slot.';
            }
            else if(camera.digitalPtzType !== slotInfo.digitalPtzType) {
                errorText = 'The provided digital PTZ camera is not the correct type for this slot.';
            }
            if(typeof errorText !== 'undefined') {
                var errorResponse = new EVWEB2.ResponseStatus(false,errorText);
                callback(errorResponse);
                return;
            }

            var onApplyDigitalPtzSettingsError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onApplyDigitalPtzSettingsSuccess = function(data/*, textStatus, xhr*/) {
                //Return the digital PTZ camera
                var response = new EVWEB2.ResponseStatus(data.success, data.errorText);
                callback(response, camera);
            };

            var settings = {
                success: onApplyDigitalPtzSettingsSuccess,
                error: onApplyDigitalPtzSettingsError,
                url: slotInfo.serverInstance.service.url() + EVWEB2.urls.digitalPtz,
                data: {
                    s: slotInfo.serverInstance.sessionId,
                    ptz: camera.id,
                    folder: this.folder.name,
                    slot: slot
                }
            };
            if(this.id)
                settings.data.viewid = this.id;
            else
                settings.data.view = this.name;

            EVWEB2.ajax(settings, slotInfo.serverInstance.service);
        };
    };

    /**
     *  The getViews function retrieves the server side views from the exacqVision servers.
     *  @deprecated This method is superceded by {@link EVWEB2.Service.getViews}.
     *  @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
     *   {@link EVWEB2.ResponseStatus} instance with the details of the response, an array of {@link EVWEB2.View}
     *   instances, and an array of {@link EVWEB2.ViewFolder} instances.
     *  @param {EVWEB2.Server|EVWEB2.Server[]} servers A single {@link EVWEB2.Server} instance or an array of
     *  {@link EVWEB2.Server} instances
     *  @category Views
     */
    EVWEB2.getViews = function (callback, servers) {
        if(!$.isArray(servers)) {
            servers = [servers];
        }

        if(servers.length === 0) {
            var errorResponse = new EVWEB2.ResponseStatus(false,'No servers defined');
            callback(errorResponse);
        }

        servers[0].service.getViews(callback, servers);
   };

}());

/*globals EVWEB2:true*/
(function() {
    /**
     * Definitions for the metadata flags returned for a given metadata item.
     * @enum {string}
     * @readonly
     * @category Search
     */
    EVWEB2.metadataFlags = {
        /**
         * Free run
         */
        freeRun: 'freeRun',
        /**
         * Alarm
         */
        alarm: 'alarm',
        /**
         * Motion
         */
        motion: 'motion'
    };

    /**
     * Bit field values for flags.
     * @internal
     * @type {Number}
     * @category Search
     */
    var FLAG_FREE_RUN = 0x00;
    var FLAG_ALARM = 0x40;
    var FLAG_MOTION = 0x80;

    /**
     * A metadata item, representing a duration of a given metadata event.
     * @param {Date} [start=new Date()] The start date time of the metadata item.
     * @param {Date} [end=new Date()] The end date time of the metadata item.
     * @param {Number|EVWEB2.metadataFlags[]} flags The flags associated with the metadata event. If the value is a
     * number, it is treated as a bit field returned from the server
     * @class
     * @constructor
     * @category Search
     */
    EVWEB2.MetadataItem = function(start, end, flags) {

        /**
         * Start date of the metadata item
         * @type Date
         */
        this.start = new Date();

        /**
         * End date of the metadata item
         * @type Date
         */
        this.end = new Date();

        /**
         * The flags associated with this metadata item
         * @type Array
         */
        this.flags = [];

        /**
         * The active flag associated with the group of flags
         * @type {String}
         */
        this.activeFlag = '';

        if(typeof start !== 'undefined') {
            this.start = start;
        }
        if(typeof end !== 'undefined') {
            this.end = end;
        }
        /* eslint-disable no-bitwise */
        if(typeof flags !== 'undefined') {
            if(typeof flags === 'number') {
                if(flags === FLAG_FREE_RUN) {
                    //for Free Run
                    this.flags.push(EVWEB2.metadataFlags.freeRun);
                }
                if((flags&(FLAG_ALARM)) === FLAG_ALARM) {
                    //for Alarm
                    this.flags.push(EVWEB2.metadataFlags.alarm);
                }
                if((flags&(FLAG_MOTION)) === FLAG_MOTION) {
                    //for Motion
                    this.flags.push(EVWEB2.metadataFlags.motion);
                }
            }
            else {
                this.flags = flags;
            }

            // Set the active flag
            if($.inArray(EVWEB2.metadataFlags.alarm, this.flags) !== -1) {
                this.activeFlag = EVWEB2.metadataFlags.alarm;
            }

            else if($.inArray(EVWEB2.metadataFlags.motion, this.flags) !== -1) {
                this.activeFlag = EVWEB2.metadataFlags.motion;
            }

            else if($.inArray(EVWEB2.metadataFlags.freeRun, this.flags) !== -1) {
                this.activeFlag = EVWEB2.metadataFlags.freeRun;
            }
        }
        /* eslint-enable no-bitwise */
    };

    /**
     * A container for all metadata information associated with an input.
     * @param {EVWEB2.Camera|EVWEB2.AudioDevice} [instance=null] The input instance associated wtih the metadata.
     * @param {EVWEB2.MetadataItem[]} [metadata=[]] An array of all metadata items associated with the input for the
     * given time range
     * @param {Date} [start=new Date()] The start date time of the metadata information.
     * @param {Date} [end=new Date()] The end date time of the metadata information.
     * @class
     * @constructor
     * @category Search
     */
    EVWEB2.MetadataInformation = function(instance, metadata, start, end) {
        /**
         * The instance associated with this metadata
         * @type EVWEB2.Camera|EVWEB2.AudioDevice
         */
        this.instance = null;

        /**
         * The metadata items for this time range
         * @type EVWEB2.MetadataItem[]
         */
        this.metadata = [];

        /**
         * Start date of the search
         * @type Date
         */
        this.start = new Date();

        /**
         * End date of the search
         * @type Date
         */
        this.end = new Date();

        if(typeof instance !== 'undefined') {
            this.instance = instance;
        }
        if(typeof metadata !== 'undefined') {
            this.metadata = metadata;
        }
        if(typeof start !== 'undefined') {
            this.start = start;
        }
        if(typeof end !== 'undefined') {
            this.end = end;
        }
    };

    /**
     * A container for all metadata information requested by a call to {@link EVWEB2.getMetadata}.
     * @param {EVWEB2.MetadataInformation[]} [cameraMetadata=[]] The metadata information associated with the requested
     * {@link EVWEB2.Camera} instances.
     * @param {EVWEB2.MetadataInformation[]} [audioMetadata=[]] The metadata information associated with the requested
     * {@link EVWEB2.AudioDevice} instances.
     * @param {Date} [start=new Date()] The start date time of the requested metadata information.
     * @param {Date} [end=new Date()] The end date time of the requested metadata information.
     * @param {String} [sessionId=''] The generated session ID for the metadata instance.
     * @class
     * @constructor
     * @category Search
     */
    EVWEB2.Metadata = function(cameraMetadata, audioMetadata, start, end, sessionId) {
        /**
         * Server this Search is attached to
         * @type EVWEB2.Server
         */
        this.server = null;

        /**
         * The session ID for the metadata instance.
         * @type String
         */
        this.sessionId = '';

        /**
         * Metadata information for the associated cameras
         * @type EVWEB2.MetadataInformation[]
         */
        this.cameras = [];

        /**
         * Metadata information for the associated audio input streams
         * @type EVWEB2.MetadataInformation[]
         */
        this.audioInputs = [];

        /**
         * Start date of the search
         * @type Date
         */
        this.start = new Date();

        /**
         * End date of the search
         * @type Date
         */
        this.end = new Date();

        if(typeof cameraMetadata !== 'undefined') {
            this.cameras = cameraMetadata;
            if(cameraMetadata.length > 0) {
                this.server = cameraMetadata[0].instance.server;
            }
        }
        if(typeof audioMetadata !== 'undefined') {
            this.audioInputs = audioMetadata;
            if(audioMetadata.length > 0) {
                this.server = audioMetadata[0].instance.server;
            }
        }
        if(typeof start !== 'undefined') {
            this.start = start;
        }
        if(typeof end !== 'undefined') {
            this.end = end;
        }
        if(typeof sessionId !== 'undefined') {
            this.sessionId = sessionId;
        }

        /**
         * Generates a URL for retrieving a frame from the specified camera at a given time.
         * NOTE: This method should not be used for normal video playback, as performance will be very poor in that
         * application.
         *
         * @param {EVWEB2.Camera} camera Target camera for the search
         * @param {Date} timestamp The timestamp of the required frame
         * @param {Number} width The width of the image in pixels
         * @param {Number} height The height of the image in pixels
         * @param {Number} quality Quality of the requested image between 1 and 10 (1 lowest, 10 highest)
         * @return {String} The url to access the frame
         */
        this.getFrameAtTime = function (camera, timestamp, width, height, quality) {
            if(this.sessionId === '' || !camera.supportsGetFrame()) {
                return '';
            }
            var url = this.server.service.url() + EVWEB2.urls.metadata;
            var params = [
                's=' + this.sessionId,
                'action=frame',
                'time=' + EVWEB2.util.Date2IETF(timestamp)
            ];

            var useNativeJpeg = false;
            if(camera.ptzType === EVWEB2.ptzTypes.digital) {
                params.push('camera=' + camera.sourceCamera.id);
                params.push('session=' + camera.server.sessionId);
                params.push('digitalptz=' + camera.id);
            }
            else {
                params.push('camera=' + camera.id);
                var forwardingSettings = this.server.service.jpegForwarding;
                if(forwardingSettings.enabled && $.inArray(EVWEB2.cameraFormats.jpeg, camera.formats) !== -1) {
                    useNativeJpeg = camera.quality * (forwardingSettings.qualityThreshold/100) < quality &&
                        (camera.resolution.width * (forwardingSettings.sizeThreshold/100) < width ||
                            camera.resolution.height * (forwardingSettings.sizeThreshold/100) < height);
                }
            }
            var format = EVWEB2.cameraFormats.transcodedJpeg;
            if(useNativeJpeg || $.inArray(EVWEB2.cameraFormats.transcodedJpeg, camera.formats) === -1) {
                format = EVWEB2.cameraFormats.jpeg;
            }
            if(format !== EVWEB2.cameraFormats.jpeg) {
                params.push('w='+width);
                params.push('h='+height);
                params.push('q='+quality);
            }
            params.push('format='+format);
            url += '?' + params.join(';') + ';';

            var date = new Date();
            url += date.getTime();
            return url;
        };

        /**
         * Notifies the service that a process is still in use.  This prevents an active instance from being closed.
         * @param {function} [callback] Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance.
         */
        this.notifyUse = function (callback) {
            if(this.sessionId === '') {
                if(typeof callback === 'function') {
                    var errorResponse = new EVWEB2.ResponseStatus(false, 'Metadata instance is not avaialble.');
                    callback(errorResponse);
                }
                return;
            }
            var metadataServer = new EVWEB2.Server(this.server.service, '', this.server.id, true, false,
                this.sessionId);
            metadataServer.notifyUse(callback);
        };

        /**
         * Logs out the current metadata instance.  This destroys all resources associated with the metadata and should
         * be called for each metadata instance as it is no longer needed.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response.
         */
        this.logout = function (callback) {
            if(this.sessionId === '') {
                if(typeof callback === 'function') {
                    var errorResponse = new EVWEB2.ResponseStatus(false, 'Metadata instance is not avaialble.');
                    callback(errorResponse);
                }
                return;
            }

            var onLogoutServerError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                if(typeof callback === 'function') {
                    callback(errorResponse);
                }
            };

            var onLogoutServerSuccess = function(/*data, textStatus, xhr*/) {
                var successResponse = new EVWEB2.ResponseStatus(true);
                if(typeof callback === 'function') {
                    callback(successResponse);
                }
            };

            var settings = {
                success: onLogoutServerSuccess,
                error: onLogoutServerError,
                url: this.server.service.url() + EVWEB2.urls.logout,
                data: {
                    s: this.sessionId
                }
            };

            EVWEB2.ajax(settings, this.server.service);
        };

    };

    /**
     * The metadata function handles retrieving metadata information for a set of cameras over a duration.  It
     * queries the server for the metadata information on the set of cameras.
     *
     * For backwards compatability, when communicating with services running version 2.10.1 or earlier, audio inputs
     * are not supported.  Requesting audio input metadata information will not cause a failure, but no results will be
     * returned for the audio inputs.
     *
     * @param {Function} callback Callback function to be executed when the call completes. The function gets passed
     *  two arguments: {@link EVWEB2.ResponseStatus} instance with the details of the response and a
     *  {@link EVWEB2.Metadata} instance describing all of the metadata information for the associated inputs.
     * @param {EVWEB2.Camera[]|EVWEB2.AudioDevice[]} inputs Array of {@link EVWEB2.Camera} and
     * {@link EVWEB2.AudioDevice} objects that are the targets for the metadata search.
     * @param {Date} start The start time of the metadata search
     * @param {Date} end The end time of the metadata search
     * @category Search
     */
    EVWEB2.getMetadata = function (callback, inputs, start, end) {
        // Generate the different input lists
        var cameras = $.grep(inputs, function(element) {
            return element instanceof EVWEB2.Camera;
        });
        var audioInputs = $.grep(inputs, function(element) {
            return element instanceof EVWEB2.AudioDevice;
        });

        var onGetMetadataError = function(xhr/*, textStatus, errorThrown*/) {
            var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
            if(xhr.status === 408 || xhr.status === 504) {
                errorResponse.errorText = 'A timeout has occurred requesting metadata.';
            }
            if(xhr.status === 403) {
                errorResponse.errorText = "No permission to search.";
            }
            callback(errorResponse);
        };

        var metadataItemFromResponse = function(responseItem) {
            var itemStart = EVWEB2.util.IETF2Date(responseItem.start);
            var itemEnd = EVWEB2.util.IETF2Date(responseItem.end);
            return new EVWEB2.MetadataItem(itemStart, itemEnd, responseItem.flags);
        };

        var processCameraMetadataResponses = function(responseCameras) {
            return $.map(responseCameras, function(element, key) {
                var metadataItems = $.map(element.metadata, metadataItemFromResponse);

                var camera = $.grep(cameras, function(element) {
                    return element.id.toString() === key;
                })[0];

                return new EVWEB2.MetadataInformation(camera, metadataItems, element.start, element.end);
            });
        };

        var processAudioInputsMetadataResponses = function(responseAudioInputs) {
            return $.map(responseAudioInputs, function(element, key) {
                var metadataItems = $.map(element.metadata, metadataItemFromResponse);

                var audioInput = $.grep(audioInputs, function(element) {
                    return element.id.toString() === key;
                })[0];

                return new EVWEB2.MetadataInformation(audioInput, metadataItems, element.start, element.end);
            });
        };

        var onOldGetMetadataSuccess = function(data/*, textStatus, xhr*/) {
            if(data === EVWEB2.errors.servers) {
                //Call the error callback
                onGetMetadataError();
            }

            var cameraMetadata = processCameraMetadataResponses(data);
            var metadataResponse = new EVWEB2.Metadata(cameraMetadata, undefined, start, end);

            var successResponse = new EVWEB2.ResponseStatus(true);
            //Return the server list
            callback(successResponse, metadataResponse);
        };

        var onGetMetadataSuccess = function(data/*, textStatus, xhr*/) {
            if(data === EVWEB2.errors.servers) {
                //Call the error callback
                onGetMetadataError();
            }

            var cameraMetadata = processCameraMetadataResponses(data.cameras);
            var audioInputsMetadata = processAudioInputsMetadataResponses(data.audio);
            var metadataResponse = new EVWEB2.Metadata(cameraMetadata, audioInputsMetadata, start, end, data.sessionId);

            var successResponse = new EVWEB2.ResponseStatus(true);
            //Return the server list
            callback(successResponse, metadataResponse);
        };

        var server;
        if(cameras.length > 0) {
            server = cameras[0].server;
        }
        else if (audioInputs.length > 0) {
            server = audioInputs[0].server;
        }
        else {
            var errorResponse = new EVWEB2.ResponseStatus(false, 'No items to search.');
            callback(errorResponse);
            return;
        }

        var onVersionNumberResponse = function(response, versionNumber) {
            var useNewRequest = false;
            if(response.success) {
                if (versionNumber === '0.0.0.0') {
                    // Always use the new method internally
                    useNewRequest = true;
                }
                else {
                    var versionValues = versionNumber.split('.');
                    // Use the new request if it's a version greater than 2.10
                    var majorVersion = 0;
                    var minorVersion = 0;
                    if(versionValues.length > 2) {
                        majorVersion = parseInt(versionValues[0], 10);
                        minorVersion = parseInt(versionValues[1], 10);
                    }

                    useNewRequest = majorVersion > 2 || (majorVersion === 2 && minorVersion > 10);
                }
            }

            var url = server.service.url() + EVWEB2.urls.metadata + '?s=' + server.sessionId;
            if(useNewRequest) {
                url += ';responseVersion=2';
            }
            var i;
            for(i=0; i<cameras.length; i++) {
                if(typeof cameras[i].id !== 'undefined') {
                    url += ';camera='+ cameras[i].id;
                }
            }
            for(i=0; i<audioInputs.length; i++) {
                if(typeof audioInputs[i].id !== 'undefined') {
                    url += ';audio='+ audioInputs[i].id;
                }
            }
            url += ';start='+EVWEB2.util.Date2IETF(start) + ";end=" + EVWEB2.util.Date2IETF(end);

            var settings = {
                success: onOldGetMetadataSuccess,
                error: onGetMetadataError,
                url: url,
                dataType: 'json'
            };

            if(useNewRequest) {
                settings.success = onGetMetadataSuccess;
            }

            EVWEB2.ajax(settings, server.service);
        };

        // Get the version number of the service to determine which HTTP request to make
        server.service.version(onVersionNumberResponse);
    };

    /**
     * The metadata function handles retrieving metadata information for a set of cameras over a duration.  It
     * queries the server for the metadata information on the set of cameras.
     * @param {Function} callback Callback function to be executed when the call completes. The function gets passed
     *  two arguments: {@link EVWEB2.ResponseStatus} instance with the details of the response and an object of the
     *  metadata for each camera.
     * @param {EVWEB2.Camera[]} cameras Array of {@link EVWEB2.Camera} instances for retrieving metadata.
     * @param {Date} start The start time of the metadata search
     * @param {Date} end The end time of the metadata search
     * @deprecated This function has been deprecated in place of EVWEB2.getMetadata to support a more consistent naming structure,
     * a defined result object, as well as to provide searching on audio inputs.
     * @category Search
     */
    EVWEB2.metadata = function (callback, cameras, start, end) {
        var onGetMetadata = function(response, metadata) {
            // Convert the EVWEB2.Metadata objects back to the original format, ignoring audio inputs.
            var camerasMetadata = {};

            $.each(metadata.cameras, function(index, element) {
                var cameraMetadata = {
                    start: element.start,
                    end: element.end,
                    metadata: {}
                };

                $.each(element.metadata, function(index, element) {
                    // Map the flags back to the bitfield
                    var flags = 0x0;
                    var i;
                    /* eslint-disable no-bitwise */
                    for(i=0; i<element.flags.length; i++) {
                        if(element.flags[i] === EVWEB2.metadataFlags.freeRun) {
                            flags = flags | FLAG_FREE_RUN;
                        }
                        else if(element.flags[i] === EVWEB2.metadataFlags.motion) {
                            flags = flags | FLAG_MOTION;
                        }
                        else if(element.flags[i] === EVWEB2.metadataFlags.alarm) {
                            flags = flags | FLAG_ALARM;
                        }
                    }
                    /* eslint-enable no-bitwise */
                    cameraMetadata.metadata[index] = {
                        start: EVWEB2.util.Date2IETF(element.start),
                        end: EVWEB2.util.Date2IETF(element.end),
                        flags: flags
                    };
                });
                camerasMetadata[element.instance.id] = cameraMetadata;
            });
            callback(response, camerasMetadata);
        };

        EVWEB2.getMetadata(onGetMetadata, cameras, start, end);
    };

}());
/*globals EVWEB2:true, $:false*/
(function() {
    /**
     * The Search Audio Clip Info object is a container representing the information surrounding
     * a single audio clip in a search.  This object is generally not used, as it is
     * only relevant in situations where the sample rate or format of a given audio stream changed
     * over time.
     * @class
     * @param {Date} [start=new Date()] Start date of the clip
     * @param {Date} [end=new Date()] End date of the clip
     * @param {EVWEB2.audioDeviceNativeFormatTypes} [nativeFormat=EVWEB2.audioDeviceNativeFormatTypes.none] The native
     * format for the audio device for the duration of the clip.
     * @param {Number} [frequency=0] The samples per second of the returned audio for the duration
     * of the clip.
     * @param {Number} [frames=0] The number of frames associated with this clip.
     * @param {Number} [samplesPerFrame=0] The number of samples in a given frame for this clip.
     * @constructor
     * @category Search
     */
    EVWEB2.SearchAudioClipInfo = function (start, end, nativeFormat, frequency, frames, samplesPerFrame) {
        /**
         * Start date of the clip
         * @type Date
         */
        this.start = new Date();

        /**
         * End date of the clip
         * @type Date
         */
        this.end = new Date();

        /**
         * The native format for the audio device for the duration of the clip.
         * @type EVWEB2.audioDeviceNativeFormatTypes
         */
        this.nativeFormat = EVWEB2.audioDeviceNativeFormatTypes.none;

        /**
         * The samples per second of the returned audio for the duration of the clip.
         * @type Number
         */
        this.frequency = 0;

        /**
         * The number of frames associated with this clip.
         * @type {number}
         */
        this.frames = 0;

        /**
         * The number of samples in a given frame for this clip.
         * @type {number}
         */
        this.samplesPerFrame = 0;

        if(start !== undefined) {
            this.start = start;
        }
        if(end !== undefined) {
            this.end = end;
        }
        if(nativeFormat !== undefined) {
            this.nativeFormat = nativeFormat;
        }
        if(frequency !== undefined) {
            this.frequency = frequency;
        }
        if(frames !== undefined) {
            this.frames = frames;
        }
        if(samplesPerFrame !== undefined) {
            this.samplesPerFrame = samplesPerFrame;
        }

    };

    /**
     * The Search Audio Info object is a container representing the audio clip information
     * for a given audio device in a search.  This object is generally not used, as it is
     * only relevant in situations where the sample rate or format of a given audio stream
     * changed over time.
     * @class
     * @param {EVWEB2.AudioDevice} [audioInput] The audio device instance associated with this
     * clip information
     * @param {EVWEB2.SearchAudioClipInfo[]} [audioClipsInformation] The individual audio clip
     * information for all clips in the searched stream.
     * @param {Number} [frames] The total number of frames associated with all of the clips for
     * this device.
     * @constructor
     * @category Search
     */
    EVWEB2.SearchAudioInfo = function (audioInput, audioClipsInformation, frames) {

        /**
         * The audio device instance associated with this clip information
         * @type EVWEB2.AudioDevice
         */
        this.audioInput = null;

        /**
         * The individual audio clip information for all clips in the searched stream.
         * @type EVWEB2.SearchAudioClipInfo[]
         */
        this.audioClipsInformation = [];

        /**
         * The total number of frames associated with all of the clips for this device.
         * @type {number}
         */
        this.frames = 0;

        if(audioInput !== undefined) {
            this.audioInput = audioInput;
        }
        if(audioClipsInformation !== undefined) {
            this.audioClipsInformation = audioClipsInformation;
        }
        if(frames !== undefined) {
            this.frames = frames;
        }
    };

    /**
     * SearchVideoClipInfo represents a single time range in a search where stored video exists.
     * @class
     * @param {Date} start The start of the clip.
     * @param {Date} end The end of the clip.
     * @constructor
     * @category Search
     */
    EVWEB2.SearchVideoClipInfo = function(start, end) {
        /**
         * The start of the clip.
         * @type {Date}
         */
        this.start = start || null;

        /**
         * The end of the clip.
         * @type {Date}
         */
        this.end = end || null;
    };

    /**
     * SearchVideoInfo represents the video clip information for a given searched camera.
     * @class
     * @param {EVWEB2.Camera} camera The associated camera instance.
     * @param {EVWEB2.SearchVideoClipInfo[]} clips The individual clip ranges present in the search for the camera.
     * @constructor
     * @category Search
     */
    EVWEB2.SearchVideoInfo = function(camera, clips) {
        /**
         * The associated camera instance.
         * @type EVWEB2.Camera
         */
        this.camera = camera || null;

        /**
         * The individual clip ranges present in the search for the camera.
         * @type EVWEB2.SearchVideoClipInfo[]
         */
        this.clips = clips || [];
    };

    /**
     * Enum of search statuses
     * @enum {Number}
     * @readonly
     * @category Search
     */
    EVWEB2.SearchStatusType = {
        /**
         * Unknown
         */
        unknown: 0,
        /**
         * Not started
         */
        notStarted: 1,
        /**
         * Started
         */
        started: 2,
        /**
         * Completed
         */
        complete: 3,
        /**
         * Error due to disk space restrictions
         */
        errorSpace: 4,
        /**
         * Unknown error
         */
        errorUnknown: 5
    };


    /**
     * Container object for overall search status information.  This information represents
     * the status of the search process itself, in terms of retrieving and processing
     * frames for playback
     * @class
     * @param {EVWEB2.SearchStatusType} status The status of the search.
     * @param {Number} frames The number of frames retrieved by the search process.  Note: This
     *   value represents the total number of "playable" frames available.  Playback of frames
     *   past this value is not possible.
     * @param {Number} totalFrames The total number of frames for the search.
     * @constructor
     * @category Search
     */
    EVWEB2.SearchStatus = function(status, frames, totalFrames) {
        /**
         * The status of the search.
         * @type {EVWEB2.SearchStatusType}
         */
        this.status = status;

        /**
         * The number of frames retrieved by the search process.  Note: This value represents
         * the total number of "playable" frames available.  Playback of frames past this
         * value is not possible.
         * @type {Number}
         */
        this.frames = frames;

        /**
         * The total number of frames for the search.
         * @type {Number}
         */
        this.totalFrames = totalFrames;
    };

    /**
     * Container for the overall search frame count information.  This information represents the breakdown
     * of frames by video and audio.
     * @param {Number} video The number of video frames in the search.
     * @param {Number} audio The number of audio frames in the search.
     * @constructor
     * @category Search
     */
    EVWEB2.SearchFrameCounts = function(video, audio) {
        /**
         * The number of video frames in the search.
         * @type {Number}
         */
        this.video = video;

        /**
         * The number of audio frames in the search.
         * @type {Number}
         */
        this.audio = audio;
    };

    /**
     * The Search object is a container representing a requested search.
     * @class
     * @param {String} searchId Search ID used to identify the search on the web service.
     * @param {Array.<(EVWEB2.Camera|EVWEB2.AudioDevice)>} inputs The inputs associated with the search.  Can be a mixed
     * list of {@link EVWEB2.Camera} and {@link EVWEB2.AudioDevice} instances.
     * @param {Date} start Start date of the search
     * @param {Date} end End date of the search
     * @param {Number|EVWEB2.SearchFrameCounts} frames The frame information for the search, broken down by video and
     * audio or (legacy) the total number of frames in the search.
     * @param {EVWEB2.SearchAudioInfo[]} [audioInformation] Information about each audio clip for each audio input.
     * @param {EVWEB2.SearchVideoInfo[]} [videoInformation] Information about each clip range for the searched cameras.
     * @constructor
     * @category Search
     */
    EVWEB2.Search = function (searchId, inputs, start, end, frames, audioInformation, videoInformation) {
        /**
         * Search ID used to identify the search
         * @type String
         */
        this.searchId = '';

        /**
         * The cameras associated with the search
         * @type EVWEB2.Camera[]
         */
        this.cameras = [];

        /**
         * The audio inputs associated with the search
         * @type EVWEB2.AudioDevice[]
         */
        this.audioInputs = [];

        /**
         * The serial devices associated with the search
         * @type {EVWEB2.SerialDevice[]}
         */
        this.serialDevices = [];

        /**
         * Server this Search is attached to
         * @type EVWEB2.Server
         */
        this.server = null;

        /**
         * Start date of the search
         * @type Date
         */
        this.start = new Date();

        /**
         * End date of the search
         * @type Date
         */
        this.end = new Date();

        /**
         * Number of frames in the search
         * @deprecated This has been deprecated in favor of {@link EVWEB2.Search.frameInfo}, which provides
         * more granularity in the breakdown of video and audio frames.
         * @type Number
         */
        this.frames = 0;

        /**
         * The frame counts associated with the search.  Note: When performing frame-related actions
         * (e.g. {@link EVWEB2.Search.step}}, video and audio frames are indexed separately.
         * @type {EVWEB2.SearchFrameCounts}
         */
        this.frameInfo = null;

        /**
         * Information about each audio clip for each audio input.
         * Note: This property is generally unused, as it is only relevant in situations where the sample rate or
         * format of a given audio stream changed over time.
         * @type {EVWEB2.SearchAudioInfo[]}
         */
        this.audioInformation = [];

        /**
         * Information about each clip range for the searched cameras.
         * Note: This property is not needed for basic search playback. The web service will jump frame gaps for you
         * if you allow it to advance its own playhead. You will only need this information if you intend
         * to request frames from a search at specific times (ie. keep track of your own playhead).
         * @type {EVWEB2.SearchVideoInfo[]}
         */
        this.videoInformation = [];

        //Assign the constructor values
        if(searchId !== undefined) {
            this.searchId = searchId;
        }
        if(inputs !== undefined) {
            // Generate the different input lists
            this.cameras = $.grep(inputs, function(element) {
                return element instanceof EVWEB2.Camera;
            });
            this.audioInputs = $.grep(inputs, function(element) {
                return element instanceof EVWEB2.AudioDevice;
            });
            this.serialDevices = $.grep(inputs, function(element) {
                return element instanceof EVWEB2.SerialDevice;
            });
            if(inputs.length > 0) {
                this.server = inputs[0].server;
            }
        }
        if(start !== undefined) {
            this.start = start;
        }
        if(end !== undefined) {
            this.end = end;
        }
        if(frames !== undefined) {
            if(frames instanceof EVWEB2.SearchFrameCounts) {
                this.frames = frames.video + frames.audio;
                this.frameInfo = frames;
            }
            else {
                // Legacy mode, treat all frames as video
                this.frames = frames;
                this.frameInfo = new EVWEB2.SearchFrameCounts(frames, 0);
            }

        }
        if(audioInformation !== undefined) {
            this.audioInformation = audioInformation;
        }
        if(videoInformation !== undefined) {
            this.videoInformation = videoInformation;
        }

        /**
         * The setSpeed function handles modifying the playback speed for searches initiated with the
         * {@link EVWEB2.getSearch} function.  Each search feed can be sped up, slowed down, or rewound.  To control
         * this, the setSpeed takes the new speed (100 being real time, 0 being paused, and negatives being rewinding)
         * and sets the rate at which images are retrieved to be on that playspeed for the timeline.
         *
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and the updated speed.
         * @param {Number} speed The new speed desired for this search
         */
        this.setSpeed = function (callback, speed) {
            var onSearchPlaySpeedError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSearchPlaySpeedSuccess = function(data/*, textStatus, xhr*/) {
                var playSpeed = parseInt(data, 10);
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, playSpeed);
            };

            var settings = {
                success: onSearchPlaySpeedSuccess,
                error: onSearchPlaySpeedError,
                url: this.server.service.url() + EVWEB2.urls.speed + '/' + speed,
                dataType: 'text',
                data: {
                    search_id: this.searchId
                }
            };

            EVWEB2.ajax(settings, this.server.service);
        };

        /**
         * The playing function is an AJAX call to check the status of a search feed.  It is used to validate
         * whether a search is still continuing or whether it has expired and no new images are available.  This
         * function calls to the web service web server to check whether the feed is still being played or whether
         * it is stopped.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and a Boolean indicating whether
         *  the search is currently playing.
         */
        this.playing = function (callback) {
            var onSearchPlayingError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSearchPlayingSuccess = function(data/*, textStatus, xhr*/) {
                var playSpeed = parseInt(data, 10);
                var successResponse = new EVWEB2.ResponseStatus(true);
                var isPlaying = true;
                if (playSpeed === -1 || playSpeed === 0) {
                    isPlaying = false;
                }
                callback(successResponse, isPlaying);
            };

            var settings = {
                success: onSearchPlayingSuccess,
                error: onSearchPlayingError,
                url: this.server.service.url() + EVWEB2.urls.speed,
                dataType: 'text',
                data: {
                    search_id: this.searchId
                }
            };

            EVWEB2.ajax(settings, this.server.service);
        };

        /**
         * The step function handles small jumps in the playback of a search.  It can be used for walking through a
         * feed to look for something specific and detailed.  The intended use of this is to be coupled with a
         * playspeed of 0 (i.e. the feed is paused).  With the step function, no image will be grabbed, but the
         * next time you pull an image from this search, it will be at the new location in the timeline.  The step
         * size can be positive or negative and refers to the number of frames either forward or backward from the
         * current frame. If no step size is provided, the current frame of the search will be returned.
         *
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance with the details of the response and a Number indicating the current
         * playback frame.
         * @param {Number|String} [stepSize] The frame to step to or the offset amount to step (e.g. '+5' is step 5
         * frames forward).
         */
        this.step = function (callback, stepSize) {
            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var newFrame;
                if(typeof data === 'string') {
                    // Handle legacy responses
                    newFrame = parseInt(data, 10);
                }
                else {
                    newFrame = parseInt(data.frame, 10);
                }
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, newFrame);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: this.server.service.url() + EVWEB2.urls.step + '/',
                data: {
                    search_id: this.searchId,
                    output: 'json'
                }
            };
            if(typeof stepSize !== 'undefined') {
                settings.url += stepSize.toString();
            }

            EVWEB2.ajax(settings, this.server.service);
        };

        /**
         * The getTime function handles retrieving the current date/time from a camera feed attached to a search.
         * It queries the server and parses the returned string to a proper javascript date/time object.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and a Date object of the current
         *  time of the search.
         */
        this.getTime = function (callback) {
            var onSearchTimeError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSearchTimeSuccess = function(data, textStatus, xhr) {
                var searchTime;
                try{
                    data = JSON.parse(data);
                    searchTime = data.timeWithMs || data.time;
                }
                catch(e){
                    searchTime = data;
                }

                var xDurationText = xhr.getResponseHeader('X-Duration');
                var xServerText = xhr.getResponseHeader('X-Server-Time');
                var xDuration = xDurationText !== null ? parseInt(xDurationText, 10) : 0;
                var serverTimeDifference = xServerText !== null ? Math.abs(Date.now() - Date.parse(xServerText)) : 0;
                var currentTime = EVWEB2.util.IETF2Date(searchTime);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, currentTime, xDuration, serverTimeDifference);
            };

            var settings = {
                success: onSearchTimeSuccess,
                error: onSearchTimeError,
                url: this.server.service.url() + EVWEB2.urls.time,
                dataType: 'text',
                data: {
                    search_id: this.searchId,
                    output: 'json'
                }
            };

            EVWEB2.ajax(settings, this.server.service);
        };

        /**
         * Logs out the current search.  This destroys all resources associated with the search and should be called
         * for each search as the search is finished.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response.
         */
        this.logout = function (callback) {
            var server = this.server;
            var onLogoutServerError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                if(typeof callback === 'function') {
                    callback(errorResponse);
                }
            };

            var onLogoutServerSuccess = function(/*data, textStatus, xhr*/) {
                var successResponse = new EVWEB2.ResponseStatus(true);
                if(typeof callback === 'function') {
                    callback(successResponse);
                }
            };

            var settings = {
                success: onLogoutServerSuccess,
                error: onLogoutServerError,
                url: server.service.url() + EVWEB2.urls.logout,
                data: {
                    s: this.searchId
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Notifies the service that a process is still in use.  This prevents an inactive search from being closed.
         * @param {Function} [callback] Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance.
         */
        this.notifyUse = function (callback) {
            var searchServer = new EVWEB2.Server(this.server.service, '', this.server.id, true, false, this.searchId);
            searchServer.notifyUse(callback);
        };

        /**
         * Retrieves the status of the search.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and a {@link EVWEB2.SearchStatus}
         *  object detailing the status of the search.
         */
        this.getStatus = function(callback) {
            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var status = new EVWEB2.SearchStatus(data.status.status,
                    data.status.frames.retrieved, data.status.frames.total);
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, status);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: this.server.service.url() + EVWEB2.urls.searchStatus,
                data: {
                    s: this.searchId
                }
            };

            EVWEB2.ajax(settings, this.server.service);
        };

        /**
         * Generates a stream ID for a video.web or pull.web request based off of the provided ID.
         * @param {String} streamId The stream ID to process.
         * @return {String} A stream ID
         */
        var generateStreamId = function(streamId) {
            if (typeof streamId === "undefined") {
                if (EVWEB2.config.defaultStreamId === null) {
                    EVWEB2.config.defaultStreamId = EVWEB2.util.generateStreamId();
                }
                streamId = EVWEB2.config.defaultStreamId;
            }
            return streamId;
        };

        /**
         * Gets a frame from the searched camera at the specified time.
         * @param {EVWEB2.Camera} camera The camera for the frame.
         * @param {Date} time The time of the frame.
         * @param {Number} width The width of the image in pixels
         * @param {Number} height The height of the image in pixels
         * @param {Number} quality Quality between 1 and 10 with the level of quality of the image (1 lowest, 10
         * highest)
         * @param {String} [streamId] The unique stream ID for the feed
         * @return {String} The URL to request the desired frame from this search.
         */
        this.getFrame = function(camera, time, width, height, quality, streamId) {
            if(!camera.supportsGetFrame()) {
                return '';
            }

            var url = this.server.service.url() + EVWEB2.urls.searchVideo;
            var params = [
                's=' + this.server.sessionId,
                'search_id=' + this.searchId,
                'camera=' + camera.id,
                'time=' + EVWEB2.util.Date2IETF(time, true),
                'stream=' + generateStreamId(streamId)
            ];

            var useNativeJpeg = false;
            var forwardingSettings = this.server.service.jpegForwarding;
            if(forwardingSettings.enabled && $.inArray(EVWEB2.cameraFormats.jpeg, camera.formats) !== -1) {
                useNativeJpeg = camera.quality * (forwardingSettings.qualityThreshold/100) < quality &&
                                (camera.resolution.width * (forwardingSettings.sizeThreshold/100) < width ||
                                camera.resolution.height * (forwardingSettings.sizeThreshold/100) < height);
            }

            var format = EVWEB2.cameraFormats.transcodedJpeg;
            if(useNativeJpeg || $.inArray(EVWEB2.cameraFormats.transcodedJpeg, camera.formats) === -1) {
                format = EVWEB2.cameraFormats.jpeg;
            }
            if(format !== EVWEB2.cameraFormats.jpeg) {
                params.push('w='+width);
                params.push('h='+height);
                params.push('q='+quality);
            }
            params.push('format='+format);

            url += '?' + params.join(';') + ';';

            var date = new Date();
            url += date.getTime();
            return url;
        };

    };

    /**
     * The getSearch function makes the initializing call for a search on a series of {@link EVWEB2.Camera} instances
     * on a given period.  It requests the period feed for the given {@link EVWEB2.Camera} instances and
     * retrieves the information to later manipulate the search.  The image feed values are timed on the web server
     * and will pass in real time without requiring any time detection on the front-end.
     * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
     *  {@link EVWEB2.ResponseStatus} instance with the details of the response and a {@link EVWEB2.Search} instance.
     * @param {EVWEB2.Camera[]|EVWEB2.AudioDevice[]|EVWEB2.SerialDevice} inputs Array of {@link EVWEB2.Camera},
     * {@link EVWEB2.AudioDevice}, and {@link EVWEB2.SerialDevice} objects that are the targets for the search
     *  requested.
     * @param {Date|Number|String} start Date object or integer/string representing the number of milliseconds since
     * epoch, this is to be the beginning of the requested period.
     * @param {Date|Number|String} end Date object or integer/string representing the number of milliseconds since
     * epoch, this is to be the end of the requested period.
     * @param {Boolean} [startPaused=false] Whether the search should start paused or not.
     * @category Search
     */
    EVWEB2.getSearch = function (callback, inputs, start, end, startPaused) {
        //Forward-declaring onSearchSuccess due to circular references.
        var onSearchSuccess;

        var onSearchError = function(xhr, textStatus/*, errorThrown*/) {
            if((xhr.status === 200) && (textStatus === 'parsererror')){
                onSearchSuccess(xhr.responseText);
                return;
            }
            var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
            if(xhr.status === 408) {
                errorResponse.errorText = 'A timeout has occurred requesting the search.';
            }
            callback(errorResponse);
        };

        onSearchSuccess = function(data, textStatus, xhr) {
            if(data === EVWEB2.errors.search) {
                onSearchError(xhr);
            }

            if(typeof data === 'string') {
                // we received a string rather than json
                // build a json object
                var dataString = data;
                data = {};

                var dataStringArray = dataString.split('&');
                var i;
                for(i=0; i<dataStringArray.length; i++) {
                    var thisKeyValueArray = dataStringArray[i].split('=');

                    if(thisKeyValueArray.length === 2) {
                        if(thisKeyValueArray[0] === 'frames') {
                            data.frames = parseInt(thisKeyValueArray[1], 10);
                        } else if(thisKeyValueArray[0] === 'start') {
                            data.start_time = decodeURIComponent(thisKeyValueArray[1]);
                        } else if(thisKeyValueArray[0] === 'end') {
                            data.end_time = decodeURIComponent(thisKeyValueArray[1]);
                        } else if(thisKeyValueArray[0] === 'search_id') {
                            data.search_id = thisKeyValueArray[1];
                        }
                    }
                }
            }
            var startDate;
            if(typeof data.start_time !== 'undefined') {
                startDate = EVWEB2.util.IETF2Date(data.start_time);
            }
            var endDate;
            if(typeof data.end_time !== 'undefined') {
                endDate = EVWEB2.util.IETF2Date(data.end_time);
            }

            // Process the audio clip information (if present)
            var audioInfoList;
            if(typeof data.audioInfo !== 'undefined') {
                audioInfoList = $.map(data.audioInfo, function(element) {
                    // Process each of the clips
                    var audioClips = $.map(element.audioClips, function(clip) {
                        var clipStart = EVWEB2.util.IETF2Date(clip.startTime);
                        var clipEnd = EVWEB2.util.IETF2Date(clip.endTime);
                        return new EVWEB2.SearchAudioClipInfo(clipStart, clipEnd, clip.format,
                            clip.frequency, clip.frames, clip.samplesPerFrame);
                    });
                    // Find the associated input.
                    var audioInput = $.grep(inputs, function(device) {
                        return device.id === element.deviceId;
                    })[0];

                    return new EVWEB2.SearchAudioInfo(audioInput, audioClips, element.frames);
                });
            }

            var frameInfo = data.frames;
            if(data.frameCounts !== undefined) {
                frameInfo = new EVWEB2.SearchFrameCounts(data.frameCounts.video, data.frameCounts.audio);
            }

            var videoInfo;
            if (data.videoInfo) {
                videoInfo = $.map(data.videoInfo, function(info) {
                    var ranges = $.map(info.clips, function(clip) {
                        return new EVWEB2.SearchVideoClipInfo(EVWEB2.util.IETF2Date(clip.startTime),
                            EVWEB2.util.IETF2Date(clip.endTime));
                    });
                    var camera = $.grep(inputs, function(input) {
                        return input.id.toString() === info.deviceId;
                    })[0];
                    return new EVWEB2.SearchVideoInfo(camera, ranges);
                });
            }

            var search = new EVWEB2.Search(data.search_id, inputs, startDate, endDate, frameInfo, audioInfoList,
                videoInfo);

            var successResponse = new EVWEB2.ResponseStatus(true);
            callback(successResponse, search);
        };

        if(typeof startPaused === 'undefined') {
            startPaused = false;
        }

        if(inputs.length === 0) {
            var errorResponse = new EVWEB2.ResponseStatus(false, 'No search inputs provided.');
            callback(errorResponse);
            return;
        }

        // Generate the different input lists
        var cameras = $.grep(inputs, function(element) {
            return element instanceof EVWEB2.Camera;
        });
        var audioInputs = $.grep(inputs, function(element) {
            return element instanceof EVWEB2.AudioDevice;
        });
        var serialInputs = $.grep(inputs, function(element) {
            return element instanceof EVWEB2.SerialDevice;
        });

        var server = inputs[0].server;
        var url = server.service.url() + EVWEB2.urls.search + '?s=' + server.sessionId;
        var i;
        for(i=0; i<cameras.length; i++) {
            if(typeof cameras[i].id !== 'undefined') {
                url += '&camera='+ cameras[i].id;
            }
        }
        for(i=0; i<audioInputs.length; i++) {
            if(typeof audioInputs[i].id !== 'undefined') {
                url += '&audio='+ audioInputs[i].id;
            }
        }
        for(i=0; i<serialInputs.length; i++) {
            if(typeof serialInputs[i].id !== 'undefined') {
                url += '&serial='+ serialInputs[i].id;
            }
        }

        url += '&start='+EVWEB2.util.Date2IETF(start) + "&end=" + EVWEB2.util.Date2IETF(end) + '&output=json';

        if(startPaused) {
            url += '&start_paused=1';
        }

        if (server.requiresResourceKey()) {
            if (server.service.resourceKey === '') {
                throw new Error("CSRF enforced, passthrough will not work.");
            }
            url += '&key='+server.service.resourceKey;
        }

        var settings = {
            success: onSearchSuccess,
            error: onSearchError,
            url: url,
            dataType: 'json'
        };

        EVWEB2.ajax(settings, server.service);
    };
}());

/*globals EVWEB2:true*/
(function() {
    /**
     * Layout slots represent the positioning and sizing of a given camera panel in a layout.
     * @param {Number} [top=0] The top position of the layout slot, in terms of the {@link EVWEB2.Layout} instance.
     * @param {Number} [left=0] The left position of the layout slot, in terms of the {@link EVWEB2.Layout} instance.
     * @param {Number} [width=0] The width of the layout slot, in terms of the {@link EVWEB2.Layout} instance.
     * @param {Number} [height=0] The height of the layout slot, in terms of the {@link EVWEB2.Layout} instance.
     * @class
     * @category Util
     */
    EVWEB2.LayoutSlot = function(top, left, width, height) {
        /**
         * Top location of the layout slot
         * @type Number
         */
        this.top = 0;

        /**
         * Left location of the layout slot
         * @type Number
         */
        this.left = 0;

        /**
         * Width of the layout slot
         * @type Number
         */
        this.width = 0;

        /**
         * Height of the layout slot
         * @type Number
         */
        this.height = 0;

        if(typeof top !== 'undefined') {
            this.top = top;
        }
        if(typeof left !== 'undefined') {
            this.left = left;
        }
        if(typeof width !== 'undefined') {
            this.width = width;
        }
        if(typeof height !== 'undefined') {
            this.height = height;
        }
    };

    /**
     * A layout is the definition of a layout--the visual layout of a series of cameras.
     * @param {String|undefined} [name="Unnamed"] The name of the layout.
     * @param {Number} [width=0] The width of the layout.  i.e. the number of columns that compose the layout.
     * @param {Number} [height=0] The height of the layout.  i.e. the number of rows that compose the layout.
     * @param {Number} [length=0] The number of cameras this layout supports.
     * @param {EVWEB2.LayoutSlot[]} [slots=[]] The slot definitions for each camera slot in the layout.
     * @param {Number} [aspectRatio=4/3] The aspect ratio of the layout.
     * @param {Boolean} [ws=false] Boolean flag as to whether the layout is widescreen.
     * @class
     * @category Util
     */
    EVWEB2.Layout = function(name, width, height, length, slots, aspectRatio, ws) {
        /**
         * Name of the layout
         * @type String
         */
        this.name = "Unnamed";

        /**
         * Width of the layout
         * @type Number
         */
        this.width = 0;

        /**
         * Height of the layout
         * @type Number
         */
        this.height = 0;

        /**
         * Number of panels in the layout
         * @type Number
         */
        this.length = 0;

        /**
         * Array of slots in the layout
         * @type Array
         */
        this.slots = [];

        /**
        * Aspect ratio of the layout
        * @type Number
        */
        this.aspectRatio = 4/3;

        /**
         * Whether layout is widescreen or not
         * @type Boolean
         */
        this.ws = false;

        //Assign the constructor values
        if(typeof name !== 'undefined') {
            this.name = name;
        }
        if(typeof width !== 'undefined') {
            this.width = width;
        }
        if(typeof height !== 'undefined') {
            this.height = height;
        }
        if(typeof length !== 'undefined') {
            this.length = length;
        }
        if(typeof slots !== 'undefined') {
            this.slots = slots;
        }
        if(typeof aspectRatio !== 'undefined') {
            this.aspectRatio = aspectRatio;
        }
        if(typeof ws !== 'undefined') {
            this.ws = ws;
        }
    };

}());
/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * Definitions for the formats supported for receiving audio input.
     * @enum {string}
     * @readonly
     * @category Audio
     */
    EVWEB2.audioInputStreamFormatTypes = {
//        mp3: 'mp3',
//        ogg: 'ogg',
//        opus: 'opus',
        /**
         * Uncompressed 16-bit PCM at the frame rate of the device
         */
        raw: 'raw',
        /**
         * The native format of the audio input
         */
        'native': 'native'  //native is a reserved keyword in JavaScript: it must be quoted as a property name.
    };

    /**
     * Definitions for the formats supported for sending audio output.  Note: RAW is defined as uncompressed 16bit at
     * the frame rate of the device.
     * @enum {string}
     * @readonly
     * @category Audio
     */
    EVWEB2.audioOutputStreamFormatTypes = {
        /**
         * Uncompressed 16-bit PCM at the frame rate of the device
         */
        raw: 'raw',
        /**
         * The native format of the audio output
         */
        'native': 'native'  //native is a reserved keyword in JavaScript: it must be quoted as a property name.
    };

    /**
     * Definitions for the native formats available to audio devices.
     * @enum {Number}
     * @readonly
     * @category Audio
     */
    EVWEB2.audioDeviceNativeFormatTypes = {
        /**
         * None
         */
        none: -1,
        /**
         * PCM (g.711 mu-law encoded at the frame rate of the device)
         */
        pcm: 0,
        /**
         * ADPCM
         */
        adpcm: 1,
        /**
         * MP2
         */
        mp2: 2,
        /**
         * MP3
         */
        mp3: 3,
        /**
         * AAC
         */
        aac: 4,
        /**
         * g726
         */
        g726: 5
    };

    /**
     * The AudioDevice object acts as a large container for all the audio device operations and information.
     * It is initially populated from the information retrieved in the {@link EVWEB2.Server.getAudioDevices}
     * function and holds the unique information for an individual audio stream on an exacqVision server.  The
     * information can be used to then playback audio on the stream.
     * @param {EVWEB2.Server} [server=null] Server instance this audio stream is associated with.
     * @param {String} [id=''] ID of the audio stream according to the web service.
     * @param {String} [name='Undefined'] Name of this audio stream.
     * @param {Boolean} [enabled=false] Boolean flag for whether the audio device is enabled
     * @param {Boolean} [supportsInput=false] Boolean flag for whether the audio device supports input.
     * @param {Boolean} [supportsOutput=false] Boolean flag for whether the audio device supports output.
     * @param {EVWEB2.audioDeviceNativeFormatTypes} [nativeFormat=EVWEB2.audioDeviceNativeFormatTypes.none] The native
     *   format for the audio device.
     * @param {Number} [frequency=0] The samples per second of the returned audio.
     * @param {Boolean} [isSearchOnly=false] The search only status of this audio stream.
     * @class
     * @constructor
     * @category Audio
     */
    EVWEB2.AudioDevice = function (server, id, name, enabled, supportsInput, supportsOutput, nativeFormat, frequency, isSearchOnly) {
        /**
         * Unique ID for this audio stream
         * @type string
         */
        this.id = '';

        /**
         * Name of this audio stream
         * @type String
         */
        this.name = 'Undefined';

        /**
         * Server instance this audio stream is attached to
         * @type EVWEB2.Server
         */
        this.server = null;

        /**
         * Boolean flag for whether the audio device is enabled
         * @type Boolean
         */
        this.enabled = false;

        /**
         * Boolean flag for whether the audio device supports input.
         * @type Boolean
         */
        this.supportsInput = false;

        /**
         * Boolean flag for whether the audio device supports output.
         * @type Boolean
         */
        this.supportsOutput = false;

        /**
         * The native format for the audio device.
         * @type EVWEB2.audioDeviceNativeFormatTypes
         */
        this.nativeFormat = EVWEB2.audioDeviceNativeFormatTypes.none;

        /**
         * The samples per second of the returned audio.
         * @type Number
         */
        this.frequency = 0;

        /**
         * The search only status of the audio stream.
         * @type Boolean
         */
        this.isSearchOnly = false;

        //Assign the constructor values
        if(typeof server !== 'undefined') {
            this.server = server;
        }
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof name !== 'undefined') {
            this.name = name;
        }
        if(typeof enabled !== 'undefined') {
            this.enabled = enabled;
        }
        if(typeof supportsInput !== 'undefined') {
            this.supportsInput = supportsInput;
        }
        if(typeof supportsOutput !== 'undefined') {
            this.supportsOutput = supportsOutput;
        }
        if(typeof nativeFormat !== 'undefined') {
            this.nativeFormat = nativeFormat;
        }
        if(typeof frequency !== 'undefined') {
            this.frequency = frequency;
        }
        if(typeof isSearchOnly !== 'undefined') {
            this.isSearchOnly = isSearchOnly;
        }

        /**
         * The audio input object, once set, has all the information needed to retrieve audio data from the web
         * service for it. Since streaming audio data requires a specific URL, each AudioInput instance contains a
         * method to generate the URL for retrieving the audio stream. If the search ID parameter is set, the returned
         * URL will be pulling from an already initialized search session. This ID will point to the requested history
         * audio stream for the audio input.
         * @param {EVWEB2.audioInputStreamFormatTypes} type The type of audio stream to request.
         * @param {String} [searchId] The unique search ID for the feed.
         * @param {Number} [start] (Search Only) The starting frame to retrieve. If not specified, all frames for the
         * search will be streamed. Note: Video and audio frames are indexed separately. Be sure to reference
         * {@link EVWEB2.Search.frameInfo.audio} for the proper frame counts.
         * @param {Number} [end] (Search Only) The ending frame to retrieve. If not specified, all frames from the start
         * frame onward will be streamed. Note: Video and audio frames are indexed separately. Be sure to reference
         * {@link EVWEB2.Search.frameInfo.audio} for the proper frame counts.
         * @return {string} The URL to request the desired audio stream for this audio input
         */
        this.getAudio = function (type, searchId, start, end) {
            if(!this.enabled || !this.supportsInput) {
                throw new Error("Audio device is not enabled or does not support audio input.");
            }

            var url = this.server.service.url() + EVWEB2.urls.audio;
            var params = [];

            if (searchId  !== undefined) {
                params.push('s=' + searchId);
                if(start !== undefined) {
                    params.push('startFrame=' + start);
                }
                if(end !== undefined) {
                    params.push('endFrame=' + end);
                }
            }
            else {
                params.push('s=' + this.server.sessionId);
            }
            params.push('a=' + this.id);
            params.push('type='+type);

            url += '?' + params.join(';') + ';';

            var date = new Date();
            url += date.getTime();
            return url;
        };

        /**
         * The getAudioOutput method returns a URL to use to send audio data to a device. You will need to use this method
         * as opposed to EVWEB2.AudioDevice.sendAudio if you wish to have control over any audio POST requests.
         * @param {EVWEB2.audioOutputStreamFormatTypes} [type=EVWEB2.audioOutputStreamFormatTypes.native] The type of
         * audio stream to send, if EVWEB2.audioOutputStreamFormatTypes.raw is used, the data must be given in the
         * form of single-channel, uncompressed 16-bit PCM.
         * @returns {String} The URL to use to send audio of the given type to the device.
         */
        this.getAudioOutput = function(type) {
            if (type === undefined) {
                type = EVWEB2.audioOutputStreamFormatTypes.native;
            }

            var params = [
                's=' + this.server.sessionId,
                'a=' + this.id,
                'type=' + type
            ];
            return this.server.service.url() + EVWEB2.urls.audio + '?' + params.join('&');
        };

        /**
         * The sendAudio method sends audio data to the audio device as it is received.
         * @param {Function} callback Callback function to be executed when the call completes. The function is
         * passed a {@link EVWEB2.ResponseStatus} instance with the details of the response and the audio device
         * {@link EVWEB2.AudioDevice} instance it belongs to.
         * @param {Int16Array|Blob} data The audio data to send.
         * @param {EVWEB2.audioOutputStreamFormatTypes} [type=EVWEB2.audioOutputStreamFormatTypes.native] The type of
         * audio stream to send, if EVWEB2.audioOutputStreamFormatTypes.raw is used the data must contain
         * Raw-uncompressed 16 bit rate PCM data with 1 channel of audio.
         */
        this.sendAudio = function(callback, data, type) {
            if(!this.enabled || !this.supportsOutput) {
                throw new Error("Audio device is not enabled or does not support audio output.");
            }

            var url = this.server.service.url() + EVWEB2.urls.audio;
            var params = [
                's=' + this.server.sessionId,
                'a=' + this.id
            ];

            if(type !== undefined) {
                params.push('type=' + type);
            }

            url += '?' + params.join(';') + ';';

            var audioDevice = this;

            var onSendAudioSuccess = function(response) {
                callback(response, audioDevice);
            };

            var onSendAudioError = function() {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse, audioDevice);
            };

            var settings = {
                success: onSendAudioSuccess,
                error: onSendAudioError,
                url: url,
                data: data,
                type: 'POST',
                contentType: 'application/octet-stream',
                processData: false,
            };

            EVWEB2.ajax(settings, this.server.service);
        };
    };
}());

/*globals EVWEB2:true*/
(function() {
    /**
     * Definitions for the possible video export formats available.
     * @enum {string}
     * @readonly
     * @category Search
     */
    EVWEB2.videoExportFormatTypes = {
        /**
         * PS
         */
        ps: 'ps',
        /**
         * AVI
         */
        avi: 'avi',
        /**
         * Embedded ePlayer
         */
        eplayer: 'eplayer',
        /**
         * Zipped PS
         */
        psZip: 'ps_zip',
        /**
         * MP4
         */
        mp4: 'mp4',
        /**
         * PSX
         */
        psx: 'psx',
        /**
         * MOV
         */
        mov: 'mov'
    };

    /**
     * Definitions for the possible video export formats available.
     * @enum {number}
     * @readonly
     * @category Search
     */
    EVWEB2.videoExportStatusTypes= {
        /**
         * Not started
         */
        notStarted: 0,
        /**
         * Pending
         */
        pending: 1,
        /**
         * Exporting
         */
        exporting: 2,
        /**
         * Completed
         */
        completed: 3
    };

    /**
     * The VideoExportStatus object acts as a container for the current status of a
     * video export.  It is initially populated from the information retrieved by
     * {@link EVWEB2.VideoExport} and holds the current status and, if
     * applicable, the download link for the export.
     * @param {EVWEB2.VideoExport} [videoExport=null] The video export instance this
     * status is associated with
     * @param {EVWEB2.videoExportStatusTypes} [status=EVWEB2.videoExportStatusTypes.notStarted]
     * The status of the video export.
     * @param {Number} [percentComplete=0] The percent of export completed.
     * @param {Number} [totalSize=0] The current total file size of the export, in bytes.
     * @class
     * @constructor
     * @category Search
     */
    EVWEB2.VideoExportStatus = function (videoExport, status, percentComplete, totalSize) {
        /**
         * The video export instance this status is associated with
         * @type EVWEB2.VideoExport
         */
        this.videoExport = null;

        /**
         * Status of the video export
         * @type EVWEB2.videoExportStatusTypes
         */
        this.status = EVWEB2.videoExportStatusTypes.notStarted;

        /**
         * The percent of export completed.
         * @type Number
         */
        this.percentComplete = 0;

        /**
         * The current total file size of the export, in bytes.
         * @type Number
         */
        this.totalSize = 0;

        //Assign the constructor values
        if(typeof videoExport !== 'undefined') {
            this.videoExport = videoExport;
        }
        if(typeof status !== 'undefined') {
            this.status = status;
        }
        if(typeof percentComplete !== 'undefined') {
            this.percentComplete = percentComplete;
        }
        if(typeof totalSize !== 'undefined') {
            this.totalSize = totalSize;
        }
    };

    /**
     * The VideoExport object acts as a container for a video export.  It is initially
     * populated from the information retrieved by {@link EVWEB2.Server.videoExport} and
     * holds the information related to the export, as well as methods for retrieving
     * the export.
     * @param {Object} [server=null] {@link EVWEB2.Server} instance this video export
     * is associated with.
     * @param {String} [id=''] ID of the export, returned by {@link EVWEB2.Server.videoExport}.
     * @param {EVWEB2.Camera[]|EVWEB2.AudioDevice[]|EVWEB2.SerialDevice} inputs The inputs associated
     *  with the export.  Can be a mixed list of {@link EVWEB2.Camera}, {@link EVWEB2.AudioDevice}, and
     *  {@link EVWEB2.SerialDevice} instances.
     * @param {EVWEB2.videoExportFormatTypes} [format=EVWEB2.videoExportFormatTypes.ps]
     * The format type of the export.
     * @param {Date} [start=null] Date object representing the beginning of the export
     * period.
     * @param {Date} [end=null] Date object representing the end of the export period.
     * @constructor
     * @param {String[]} [filenames=[]] The file names of the files generated by the export.
     * @class
     * @category Search
     */
    EVWEB2.VideoExport = function (server, id, inputs, format, start, end, filenames) {
        /**
         * Server instance this export status is associated with
         * @type EVWEB2.Server
         */
        this.server = null;

        /**
         * Unique ID for the export
         * @type string
         */
        this.id = '';

        /**
         * The camera feeds associated with the export.  The property is deprecated, use the
         * updated {@link EVWEB2.VideoExport.inputs} property instead.
         * @type EVWEB2.Camera[]
         * @deprecated
         */
        this.cameras = [];

        /**
         * The inputs associated with the export.
         * @type EVWEB2.Camera[]|EVWEB2.AudioDevice[]|EVWEB2.SerialDevice
         */
        this.inputs = [];

        /**
         * The format type of the export.
         * @type EVWEB2.videoExportFormatTypes
         */
        this.format = EVWEB2.videoExportFormatTypes.ps;

        /**
         * Date object representing the beginning of the export period.
         * @type Date
         */
        this.start = null;

        /**
         * Date object representing the end of the export period.
         * @type Date
         */
        this.end = null;

        /**
         * The file names of the files generated by the export.
         * @type String[]
         */
        this.filenames = [];

        //Assign the constructor values
        if(typeof server !== 'undefined') {
            this.server = server;
        }
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof inputs !== 'undefined') {
            this.inputs = inputs;

            this.cameras = $.grep(inputs, function(element) {
                return element instanceof EVWEB2.Camera;
            });
        }
        if(typeof format !== 'undefined') {
            this.format = format;
        }
        if(typeof start !== 'undefined') {
            this.start = start;
        }
        if(typeof end !== 'undefined') {
            this.end = end;
        }
        if(typeof filenames !== 'undefined') {
            this.filenames = filenames;
        }

        /**
         * Retrieves the status of the export.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance and a
         * {@link EVWEB2.VideoExportStatus} instance.
         */
        this.getStatus = function (callback) {
            var videoExport = this;
            var onGetStatusError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onGetStatusSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Call the error callback
                    onGetStatusError();
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                var status = new EVWEB2.VideoExportStatus(videoExport, data.status, data.progress, data.size);
                callback(successResponse, status);
            };

            var settings = {
                success: onGetStatusSuccess,
                error: onGetStatusError,
                url: this.server.service.url() + EVWEB2.urls.videoexport,
                data: {
                    'export': this.id.toString()
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Generates a URI for downloading a file generated by the export.
         * @param {Number} fileIndex The index of the generated file name in {@link EVWEB2.VideoExport.filenames}.
         * @returns {String} URI for downloading the specified file.
         */
        this.getDownloadUri = function(fileIndex) {
            if(typeof this.filenames[fileIndex] === 'undefined') {
                throw new Error("File index is not generated for this export.");
            }
            var url = this.server.service.url() + EVWEB2.urls.videoexport;
            url += '?export=' + this.id.toString() + '&action=download&file=' + fileIndex;
            return url;
        };

        /**
         * Ends an export, stopping all export processing and removing the download link.
         * Note: Exports will timeout automatically after 15 minutes, however, it is
         * highly recommended that you manually end an export when finished to reduce
         * load on the server.
         * @param {Function} callback Callback function to be executed when the call
         * completes. Callback is passed a {@link EVWEB2.ResponseStatus} instance.
         */
        this.endExport = function (callback) {
            var onVideoExportEndError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onVideoExportEndSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Call the error callback
                    onVideoExportEndError();
                }
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };

            var settings = {
                success: onVideoExportEndSuccess,
                error: onVideoExportEndError,
                url: this.server.service.url() + EVWEB2.urls.videoexport,
                data: {
                    'export': this.id.toString(),
                    action: 'finish'
                }
            };

            EVWEB2.ajax(settings, server.service);
        };
    };


}());
/*globals EVWEB2:true*/

(function() {

    /**
     * The types of supported map item shapes.
     * @enum {number}
     * @readonly
     * @category Maps
     */
    EVWEB2.mapItemShapeTypes = {
        /**
         * None
         */
        none: 0,
        /**
         * Unknown
         */
        unknown: 1,
        /**
         * Balloon
         */
        balloon: 2,
        /**
         * Square
         */
        square: 3,
        /**
         * Pin
         */
        pin: 4
    };

    /**
     * The types of supported map items.
     * @enum {number}
     * @readonly
     * @category Maps
     */
    EVWEB2.mapItemCaptionPositionTypes = {
        /**
         * None
         */
        none: 0,
        /**
         * Right
         */
        right: 1,
        /**
         * Left
         */
        left: 2,
        /**
         * Top
         */
        top: 3,
        /**
         * Bottom
         */
        bottom: 4
    };

    /**
     * The types of supported map items.
     * @enum {number}
     * @readonly
     * @category Maps
     */
    EVWEB2.mapItemTypes = {
        /**
         * None
         */
        none: 0,
        /**
         * Camera
         */
        camera: 1,
        /**
         * Audio
         */
        audio: 2,
        /**
         * Serial
         */
        serial: 3,
        /**
         * Group
         */
        group: 4,
        /**
         * Soft Trigger
         */
        softTrigger: 5,
        /**
         * Input Trigger
         */
        inputTrigger: 6
    };

    /**
     * The types of supported map item shapes.
     * @enum {number}
     * @readonly
     * @category Maps
     */
    EVWEB2.mapItemFlagTypes = {
        /**
         * Auto-context
         */
        autocontext: 0x1,
        /**
         * Mirror
         */
        mirror: 0x2,
        /**
         * Output Hint
         */
        outputHint: 0x4
    };


    /**
     * The MapItemCaptionInfo object represents caption information associated with a map
     * item. The objects are generated in {@link EVWEB2.getMaps}.
     * @param {EVWEB2.mapItemCaptionPositionTypes} [position=EVWEB2.mapItemCaptionPositionTypes.none] The type of item.
     * @param {String} [color='#FFFFFF'] The hex value of the color for the caption.
     * @class
     * @constructor
     * @category Maps
     */
    EVWEB2.MapItemCaptionInfo = function(position, color) {
        /**
         * Position of the map
         * @type EVWEB2.mapItemCaptionPositionTypes
         */
        this.position = EVWEB2.mapItemCaptionPositionTypes.none;

        /**
         * Hex value of the color for the caption
         * @type String
         */
        this.color = '#FFFFFF';

        //Assign the constructor values
        if(typeof position !== 'undefined') {
            this.position = position;
        }
        if(typeof color !== 'undefined') {
            this.color = color;
        }
    };

    /**
     * The MapItemInfo object represents an item associated with a map. The
     * objects are generated in an array from {@link EVWEB2.getMaps}.
     * @param {String} [id=''] The id of the map item.
     * @param {String} [serverId=''] The server id of the server associated with the map item.
     * @param {EVWEB2.mapItemTypes} [type=EVWEB2.mapItemTypes.none] The type of the map item.
     * @param {EVWEB2.mapItemShapeTypes} [shape=EVWEB2.mapItemShapeTypes.none] The shape
     * of the map item.
     * @param {Number} [x=0] The x coordinate of the item (relative to the containing
     * {@link EVWEB2.Map}'s width property).
     * @param {Number} [y=0] The y coordinate of the item (relative to the containing
     * {@link EVWEB2.Map}'s height property).
     * @param {EVWEB2.MapItemCaptionInfo} [caption=null] The caption info for the
     * map item.
     * @param {Number} [rotation=0] The rotation of the item.
     * @param {Number} [flags=0] An OR'd list of flags associated with this map item.
     * @class
     * @constructor
     * @category Maps
     */
    EVWEB2.MapItemInfo = function(id, serverId, type, shape, x, y, caption, rotation, flags) {
        /**
        * The id of the map item.
        * @type String
        */
        this.id = '';

        /**
         * The server id of the server associated with the map item.
         * @type String
         */
        this.serverId = '';

        /**
         * The type of the map item.
         * @type EVWEB2.mapItemTypes
         */
        this.type = EVWEB2.mapItemTypes.none;

        /**
         * Hex value of the color for the caption
         * @type EVWEB2.mapItemShapeTypes
         */
        this.shape = EVWEB2.mapItemShapeTypes.none;

        /**
         * The x coordinate of the item
         * @type Number
         */
        this.x = 0;

        /**
         * The y coordinate of the item
         * @type Number
         */
        this.y = 0;

        /**
         * Caption info for map item
         * @type EVWEB2.MapItemCaptionInfo
         */
        this.caption = null;

        /**
         * The rotation of the map item
         * @type Number
         */
        this.rotation = 0;

        /**
         * An array of all flags associated with the map item.
         * @type EVWEB2.mapItemFlagTypes[]
         */
        this.flags = [];

        //Assign the constructor values
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof serverId !== 'undefined') {
            this.serverId = serverId;
        }
        if(typeof type !== 'undefined') {
            this.type = type;
        }
        if(typeof shape !== 'undefined') {
            this.shape = shape;
        }
        if(typeof x !== 'undefined') {
            this.x = x;
        }
        if(typeof y !== 'undefined') {
            this.y = y;
        }
        if(typeof caption !== 'undefined') {
            this.caption = caption;
        }
        if(typeof rotation !== 'undefined') {
            this.rotation = rotation;
        }
        if(typeof flags !== 'undefined') {
            /* eslint-disable no-bitwise */
            if((flags&EVWEB2.mapItemFlagTypes.autocontext) === EVWEB2.mapItemFlagTypes.autocontext) {
                this.flags.push(EVWEB2.mapItemFlagTypes.autocontext);
            }
            if((flags&EVWEB2.mapItemFlagTypes.mirror) === EVWEB2.mapItemFlagTypes.mirror) {
                this.flags.push(EVWEB2.mapItemFlagTypes.mirror);
            }
            if((flags&EVWEB2.mapItemFlagTypes.outputHint) === EVWEB2.mapItemFlagTypes.outputHint) {
                this.flags.push(EVWEB2.mapItemFlagTypes.outputHint);
            }
            /* eslint-enable no-bitwise */
        }
    };

    /**
     * The Map object is a wrapped set of information for a server side map.  It
     * acts as a container for the properties of an individual map.
     * @param {EVWEB2.Service} [service=null] The service instance for this map.
     * @param {String} [id=''] ID of the map.
     * @param {EVWEB2.Server} [server=null] The root server instance associated with this map. Items may be from
     * multiple servers, but all map-level requests are targeted to this server.
     * @param {String} [parentId='0'] ID of the parent map.
     * @param {String} [name='Unnamed'] Name of the map.
     * @param {String} [description=''] Description of the map.
     * @param {EVWEB2.MapItemInfo[]} [items=[]] Array of the map items
     * associated with the map.
     * @param {String[]} [servers=[]] Array of the servers used in merging the map
     * @class
     * @category Maps
     */
    EVWEB2.Map = function (service, id, server, parentId, name, description, items, servers) {
        /**
         * The service instance for this server
         * @type EVWEB2.Service
         */
        this.service = null;

        /**
         * ID of the map
         * @type String
         */
        this.id = '';

        /**
         * The root server instance associated with this map. Items may be from multiple servers, but all map-level
         * requests are targeted to this server.
         * @type EVWEB2.Server
         */
        this.server = null;

        /**
         * ID of the parent map.
         * @type String
         */
        this.parentId = '0';

        /**
         * Name of the map
         * @type String
         */
        this.name = 'Unnamed';

        /**
         * Description of the map
         * @type String
         */
        this.description = '';

        /**
         * Array of map items associated with the map
         * @type Array
         */
        this.items = [];

        /**
         * Array of servers associated with the map
         * @type Array
         */
        this.servers = [];

        //Assign the constructor values
        if(typeof service !== 'undefined') {
            this.service = service;
        }
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof server !== 'undefined') {
            this.server = server;
        }
        if(typeof parentId !== 'undefined') {
            this.parentId = parentId;
        }
        if(typeof name !== 'undefined') {
            this.name = name;
        }
        if(typeof description !== 'undefined') {
            this.description = description;
        }
        if(typeof items !== 'undefined') {
            this.items = items;
        }
        if(typeof servers !== 'undefined') {
            this.servers = servers;
        }

        /**
         * Retrieves the URL for the map's background image.
         * @return {string} The URL for the map's background image
         */
        this.getImageUrl = function() {
            if(typeof this.id !== 'undefined') {
                var url = this.service.url() + EVWEB2.urls.map;
                url += '?map=' + this.id;
                url += '&legacy=false';
                servers.forEach(function(server) {
                    url += '&s=' + server.sessionId;
                })
                return url;
            }
        };
    };

}());

/*globals EVWEB2:true*/
(function() {

    "use strict";

    EVWEB2.serverStatus = {
        normal: 0,
        alarm: 1,
        motion: 2
    };

    /**
     * A status instance for an individual camera.
     * @param {EVWEB2.Camera} [instance=null] The camera instance associated with this status.
     * @param {Boolean} [motion=false] Whether motion is detected on the camera.
     * @param {Boolean} [loss=false] Whether video loss is detected on the camera.
     * @class
     * @category Server
     */
    EVWEB2.StatusCameraItem = function(instance, motion, loss) {
        /**
         *  The camera instance associated with this status
         * @type EVWEB2.Camera
         */
        this.instance = null;

        /**
         * Whether motion is detected on the camera
         * @type Boolean
         */
        this.motion = false;

        /**
         * Whether video loss is detected on the camera
         * @type Boolean
         */
        this.loss = false;

        //Assign the constructor values
        if(typeof instance !== 'undefined') {
            this.instance = instance;
        }
        if(typeof motion !== 'undefined') {
            this.motion = motion;
        }
        if(typeof loss !== 'undefined') {
            this.loss = loss;
        }
    };

    /**
     * A status instance for an individual trigger.
     * @param {EVWEB2.Trigger} [instance=null] The trigger instance associated with this status.
     * @param {EVWEB2.triggerState} [triggerState=EVWEB2.triggerState.unknown] The state of the trigger.
     * @class
     * @category Server
     */
    EVWEB2.StatusTriggerItem = function(instance, triggerState) {
        /**
         *  The trigger instance associated with this status
         * @type EVWEB2.Trigger
         */
        this.instance = null;

        /**
         * The state of the trigger
         * @type EVWEB2.triggerState
         */
        this.triggerState = EVWEB2.triggerState.unknown;

        //Assign the constructor values
        if(typeof instance !== 'undefined') {
            this.instance = instance;
        }
        if(typeof triggerState !== 'undefined') {
            this.triggerState = triggerState;
        }
    };

    /**
     * A status instance for an individual map.
     * @param {EVWEB2.Map} [instance=null] The map instance associated with this status.
     * @param {Boolean} [motion=false] Whether motion is detected on any of cameras included in
     * the map.
     * @param {Boolean} [loss=false] Whether video loss is detected on on any of cameras included
     * in the map.
     * @class
     * @category Server
     */
    EVWEB2.StatusMapItem = function(instance, motion, loss) {
        /**
         *  The map instance associated with this status
         * @type EVWEB2.Map
         */
        this.instance = null;

        /**
         * Whether motion is detected on any of cameras included in the map
         * @type Boolean
         */
        this.motion = false;

        /**
         * Whether video loss is detected on any of cameras included in the map
         * @type Boolean
         */
        this.loss = false;

        //Assign the constructor values
        if(typeof instance !== 'undefined') {
            this.instance = instance;
        }
        if(typeof motion !== 'undefined') {
            this.motion = motion;
        }
        if(typeof loss !== 'undefined') {
            this.loss = loss;
        }
    };

    /**
     * A collection of status information returned by {@link EVWEB2.Server.getStatus}.
     * @param {EVWEB2.Server} [server=null] The server associated with the statuses.
     * @param {EVWEB2.StatusCameraItem[]} [cameras=[]] An array of all requested camera statuses.
     * @param {EVWEB2.StatusTriggerItem[]} [triggers=[]] An array of all requested trigger statuses.
     * @param {EVWEB2.StatusMapItem[]} [maps=[]] An array of all requested map statuses.
     * @class
     * @category Server
     */
    EVWEB2.Status = function(server, cameras, triggers, maps) {
        /**
         * The server associated with the statuses
         * @type EVWEB2.Server
         */
        this.server = null;


        /**
         * The camera statuses
         * @type EVWEB2.StatusCameraItem[]
         */
        this.cameras = [];

        /**
         * The trigger statuses
         * @type EVWEB2.StatusTriggerItem[]
         */
        this.triggers = [];

        /**
         * The map statuses
         * @type EVWEB2.StatusMapItem[]
         */
        this.maps = [];

        //Assign the constructor values
        if(typeof server !== 'undefined') {
            this.server = server;
        }
        if(typeof cameras !== 'undefined') {
            this.cameras = cameras;
        }
        if(typeof triggers !== 'undefined') {
            this.triggers = triggers;
        }
        if(typeof maps !== 'undefined') {
            this.maps = maps;
        }
    };

    /**
     * A collection of status information returned by {@link EVWEB2.Server.getStatus}.
     * @param {EVWEB2.Server} [server=null] The server associated with the statuses.
     * @param {String[]} [lossCameras=[]] An array of camera IDs for all cameras in a loss state.
     * @param {String[]} [motionCameras=[]] An array of camera IDs for all cameras in a loss state.
     * @param {String[]} [alarmTriggers=[]] An array of trigger IDs for all soft triggers in an alarm state.
     * @param {EVWEB2.serverStatus} [serverStatus=EVWEB2.serverStatus.normal] The server status enum value;
     * @class
     * @category Server
     */
    EVWEB2.ServerStatus = function(server, lossCameras, motionCameras, alarmTriggers, serverStatus) {
        /**
         * The server associated with the statuses
         * @type EVWEB2.Server
         */
        this.server = null;


        /**
         * The camera IDs for all cameras in a loss state.
         * @type String[]
         */
        this.lossCameras = [];

        /**
         * The camera IDs for all cameras in a motion state.
         * @type String[]
         */
        this.motionCameras = [];

        /**
         * The trigger IDs for all soft triggers in an alarm state.
         * @type String[]
         */
        this.alarmTriggers = [];

        /**
         * The server status enum value.
         * @type EVWEB2.serverStatus
         */
        this.serverStatus = EVWEB2.serverStatus.normal;


        //Assign the constructor values
        if(server !== undefined) {
            this.server = server;
        }
        if(lossCameras !== undefined) {
            this.lossCameras = lossCameras;
        }
        if(motionCameras !== undefined) {
            this.motionCameras = motionCameras;
        }
        if(alarmTriggers !== undefined) {
            this.alarmTriggers = alarmTriggers;
        }
        if(serverStatus !== undefined) {
            this.serverStatus = serverStatus;
        }
    };

}());
/*globals EVWEB2:true*/

(function() {

    /**
     * The types of supported group icons.
     * @enum {number}
     * @readonly
     * @category Groups
     */
    EVWEB2.groupIconTypes = {
        /**
         * None
         */
        none: 0,
        /**
         * Factory
         */
        factory: 1,
        /**
         * Court
         */
        court: 2,
        /**
         * House
         */
        house: 3,
        /**
         * Skyscraper
         */
        skyscraper: 4,
        /**
         * Station
         */
        station: 5,
        /**
         * Office
         */
        office: 6
    };


    /**
     * The types of supported group items. This is a placeholder copy of {@link EVWEB2.mapItemTypes}
     * @enum {number}
     * @readonly
     * @category Groups
     */
    EVWEB2.groupItemTypes = EVWEB2.mapItemTypes;

    /**
     * The GroupItemInfo object represents an item associated with a group. The
     * objects are generated in an array from {@link EVWEB2.getGroups}.
     * @param {String} [id=''] The id of the group item.
     * @param {String} [serverId=''] The server id of the server associated with the group item.
     * @param {EVWEB2.groupItemTypes} [type=EVWEB2.groupItemTypes.none] The type of the group item.
     * @class
     * @category Groups
     */
    EVWEB2.GroupItemInfo = function(id, serverId, type) {
        /**
         * The id of the group item.
         * @type String
         */
        this.id = '';

        /**
         * The server id of the server associated with the group item.
         * @type String
         */
        this.serverId = '';

        /**
         * The type of the group item.
         * @type EVWEB2.groupItemTypes
         */
        this.type = EVWEB2.groupItemTypes.none;

        //Assign the constructor values
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof serverId !== 'undefined') {
            this.serverId = serverId;
        }
        if(typeof type !== 'undefined') {
            this.type = type;
        }
    };

    /**
     * The Group object is a wrapped set of information for a server side group.  It
     * acts as a container for the properties of an individual group.
     * @param {String} [id=''] ID of the group.
     * @param {String} [name='Unnamed'] Name of the group.
     * @param {String} [description=''] Description of the group.
     * @param {EVWEB2.groupIconTypes} [icon=EVWEB2.groupIconTypes.none] The icon associated
     * with the group.
     * @param {EVWEB2.GroupItemInfo[]} [items=[]] Array of the items
     * associated with the group.
     * @class
     * @category Groups
     */
    EVWEB2.Group = function (id, name, description, icon, items) {
        /**
         * ID of the group
         * @type String
         */
        this.id = '';

        /**
         * Name of the group
         * @type String
         */
        this.name = 'Unnamed';

        /**
         * Description of the group
         * @type String
         */
        this.description = '';

        /**
         * Type of group icon
         * @type EVWEB2.groupIconTypes
         */
        this.icon = EVWEB2.groupIconTypes.none;

        /**
         * Array of items associated with the group
         * @type Array
         */
        this.items = [];

        //Assign the constructor values
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof name !== 'undefined') {
            this.name = name;
        }
        if(typeof description !== 'undefined') {
            this.description = description;
        }
        if(typeof icon !== 'undefined') {
            this.icon = icon;
        }
        if(typeof items !== 'undefined') {
            this.items = items;
        }
    };

}());
/*globals EVWEB2:true*/

/**
 * The ThumbnailSearchInfo object represents information for a frame.
 * @param {String} [sessionId=''] Session ID associated with the search.
 * @param {EVWEB2.Camera} [camera=null] Camera associated with the thumbnail search.
 * @param {Date} [frameTimestamp=new Date()] Timestamp associated with the frame.
 * @param {Number} [frameIndex=-1] Index of the frame to retrieve.
 * @class
 * @category Search
 */

EVWEB2.ThumbnailSearchInfo = function (sessionId, camera, frameTimestamp, frameIndex) {
    /**
     * Session ID associated with the thumbnail search
     * @type String
     */
    this.sessionId = '';

    /**
     * Camera associated with the thumbnail search
     * @type EVWEB2.Camera
     */
    this.camera = null;

    /**
     * Timestamp of the required frame
     * @type Date
     */
    this.frameTimestamp = new Date();

    /**
     * Index of the required frame
     * @type Number
     */
    this.frameIndex = -1;

    //Assign the constructor values
    if(typeof sessionId !== 'undefined') {
        this.sessionId = sessionId;
    }
    if(typeof camera !== 'undefined') {
        this.camera = camera;
    }
    if(typeof frameTimestamp !== 'undefined') {
        this.frameTimestamp = frameTimestamp;
    }
    if(typeof frameIndex !== 'undefined') {
        this.frameIndex = frameIndex;
    }

    /**
     * The getThumbnailImageUrl object is used to retrieve the thumbnail image.
     * @param {Number} width The width of the thumbnail image in pixels.
     * @param {Number} height The height of the thumbnail image in pixels.
     * @param {Number} quality The quality of the thumbnail image ranging from 1 -10.
     * @return {String} The URL to request the required thumbnail image.
     */
    this.getThumbnailImageUrl = function(width, height, quality) {
        if(!this.camera.supportsGetFrame()) {
            return '';
        }
        var camera = this.camera;
        var server = camera.server;
        var url = server.service.url() + EVWEB2.urls.thumbnail;

        var params = [
            's=' + sessionId,
            'frame=' + this.frameIndex
        ];

        var useNativeJpeg = false;
        var forwardingSettings = server.service.jpegForwarding;
        if(forwardingSettings.enabled && $.inArray(EVWEB2.cameraFormats.jpeg, camera.formats) !== -1) {
            useNativeJpeg = camera.quality * (forwardingSettings.qualityThreshold/100) < quality &&
                (camera.resolution.width * (forwardingSettings.sizeThreshold/100) < width ||
                    camera.resolution.height * (forwardingSettings.sizeThreshold/100) < height);
        }

        var format = EVWEB2.cameraFormats.transcodedJpeg;
        if(useNativeJpeg || $.inArray(EVWEB2.cameraFormats.transcodedJpeg, camera.formats) === -1) {
            format = EVWEB2.cameraFormats.jpeg;
        }
        if(format !== EVWEB2.cameraFormats.jpeg) {
            params.push('w='+width);
            params.push('h='+height);
            params.push('q='+quality);
        }
        params.push('format='+format);

        url += '?' + params.join(';');

        return url;
    };
};

/**
 * The ThumbnailSearch object represents a thumbnail search. The
 * objects are generated from {@link EVWEB2.Camera.getThumbnailSearch}.
 * @param {String} [sessionId=''] The session id associated with the search.
 * @param {EVWEB2.Camera} [camera=null] The camera associated with the thumbnail search.
 * @param {Date} [start=new Date()] Start time of the search.
 * @param {Date} [end=new Date()] End time of the search.
 * @param {EVWEB2.ThumbnailSearchInfo[]} [framesInfo=[]] An array of ThumbnailSearchInfo objects.
 * @class
 * @category Search
 */
EVWEB2.ThumbnailSearch = function(sessionId, camera, start, end, framesInfo) {
    /**
     * Session ID according to the webservice
     * @type String
     */
    this.sessionId = '';

    /**
    * Camera associated with the thumbnail search
    * @type EVWEB2.Camera
    */
    this.camera = null;

    /**
     * Start time of the search
     * @type Date
     */
    this.start = new Date();

    /**
     * End time of the search
     * @type Date
     */
    this.end = new Date();

    /**
    * Array of frame information associated with the search
    * @type EVWEB2.ThumbnailSearchInfo[]
    */
    this.framesInfo = [];

    //Assign the constructor values
    if(typeof sessionId !== 'undefined') {
        this.sessionId = sessionId;
    }
    if(typeof camera !== 'undefined') {
        this.camera = camera;
    }
    if(typeof start !== 'undefined') {
        this.start = start;
    }
    if(typeof end !== 'undefined') {
        this.end = end;
    }
    if(typeof framesInfo !== 'undefined') {
        this.framesInfo = framesInfo;
    }

    /**
     * Logs out the current thumbnail search.  This destroys all resources associated with the search and should be
     * called for each thumbnail search as the search is finished.
     * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
     *  {@link EVWEB2.ResponseStatus} instance with the details of the response.
     */
    this.logout = function (callback) {
        var server = this.camera.server;
        var onLogoutServerError = function(/*xhr, textStatus, errorThrown*/) {
            var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
            if(typeof callback === 'function') {
                callback(errorResponse);
            }
        };

        var onLogoutServerSuccess = function(/*data, textStatus, xhr*/) {
            var successResponse = new EVWEB2.ResponseStatus(true);
            if(typeof callback === 'function') {
                callback(successResponse);
            }
        };

        var settings = {
            success: onLogoutServerSuccess,
            error: onLogoutServerError,
            url: server.service.url() + EVWEB2.urls.logout,
            data: {
                s: this.sessionId
            }
        };

        EVWEB2.ajax(settings, server.service);
    };

    /**
     * Notifies the service that a process is still in use.  This prevents an inactive thumbnail search from being
     * closed.
     * @param {function} [callback] Callback function to be executed when the call completes. Callback is passed a
     * {@link EVWEB2.ResponseStatus} instance.
     */
    this.notifyUse = function (callback) {
        var searchServer = new EVWEB2.Server(this.camera.server.service, '', this.camera.server.id, true, false, this.sessionId);
        searchServer.notifyUse(callback);
    };

};
/*globals EVWEB2:true*/
(function() {

    /**
     * The TourFolder object is a wrapped object that represents a folder containing one or more tours or folders.
     * The objects are generated in an array from {@link EVWEB2.Service.getTours}.
     * @param {String} [id=''] The ID of the tour folder.
     * @param {String} [name=''] The name of the tour folder.
     * @param {String} [parentId=''] The parent ID of the tour folder.
     * @class
     * @category Tours
     */
    EVWEB2.TourFolder = function(id, name, parentId) {
        /**
         * The ID of the tour folder
         * @type String
         */
        this.id = '';

        /**
         * Name of the tour folder
         * @type String
         */
        this.name = '';

        /**
         * The ID of the tour folder's parent folder
         * @type String
         */
        this.parentId = '';

        //Assign the constructor values
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof name !== 'undefined') {
            this.name = name;
        }
        if(typeof parentId !== 'undefined') {
            this.parentId = parentId;
        }
    };

    /**
     * The TourItem object is a wrapped object that represents a section of the tour. The objects are generated in
     * an array from {@link EVWEB2.Service.getTours}.
     * @param {Number} [index=0] The index in the tour.
     * @param {Number} [dwell=0] The dwell time, in seconds, for the tour item.
     * @param {String} [view=''] The name of the view to be displayed for this tour item.
     * @class
     * @constructor
     * @category Tours
     */
    EVWEB2.TourItem = function(index, dwell, view) {
        /**
         * The index in the tour.
         * Note: Not all indexes are contiguous.
         * @type Number
         */
        this.index = 0;

        /**
         * The dwell time, in seconds for the tour item.
         * @type Number
         */
        this.dwell = 0;

        /**
         * The name of the view to be displayed for this tour item.
         * @type String
         */
        this.view = '';

        //Assign the constructor values
        if(typeof index !== 'undefined') {
            this.index = index;
        }
        if(typeof dwell !== 'undefined') {
            this.dwell = dwell;
        }
        if(typeof view !== 'undefined') {
            this.view = view;
        }
    };

    /**
     * The Tour object is a wrapped set of information for a view tour.
     * @param {String} [name=''] Name of the tour.
     * @param {EVWEB2.TourFolder} [folder=null] The tour's container folder.
     * @param {EVWEB2.TourItem[]} [items=[]] Array of the items in the tour.
     * @param {String} [description=''] Description of the tour.
     * @param {EVWEB2.Service} [service=null] Service the tour belongs to.
     * @class
     * @category Tours
     */
    EVWEB2.Tour = function (name, folder, items, description, service) {
        /**
         * Name of the tour
         * @type String
         */
        this.name = '';

        /**
         * The ID of the tour's container folder
         * @type EVWEB2.TourFolder
         */
        this.folder = null;

        /**
         * Array of the items in the tour.
         * @type EVWEB2.TourItem[]
         */
        this.items = [];

        /**
         * Description of the tour
         * @type String
         */
        this.description = '';

        /**
         * Service the tour belongs to.
         * @type EVWEB2.Service
         */
        this.service = null;

        //Assign the constructor values
        if(typeof name !== 'undefined') {
            this.name = name;
        }
        if(typeof folder !== 'undefined') {
            this.folder = folder;
        }
        if(typeof items !== 'undefined') {
            this.items = items;
        }
        if(typeof description !== 'undefined') {
            this.description = description;
        }
        if(typeof service !== 'undefined') {
            this.service = service;
        }
    };
}());
/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * The type of label to display for associations.
     * @enum {number}
     * @readonly
     * @category Associations
     */
    EVWEB2.associationLabel = {
        /**
         * Unknown
         */
        unknown: -1,
        /**
         * None
         */
        none: 0,
        /**
         * Custom Font
         */
        customFont: 1
    };

    /**
     * The type of overlay style for associations.
     * @enum {number}
     * @readonly
     * @category Associations
     */
    EVWEB2.overlayStyle = {
        /**
         * Unknown
         */
        unknown: -1,
        /**
         * Persistent
         */
        persistent: 0,
        /**
         * Hover
         */
        hover: 1
    };

    /**
     * The available display positions for associations.
     * @enum {number}
     * @readonly
     * @category Associations
     */
    EVWEB2.overlayPosition = {
        /**
         * Unknown
         */
        unknown: -1,
        /**
         * None
         */
        none: 0,
        /**
         * Right
         */
        right: 1,
        /**
         * Left
         */
        left: 2,
        /**
         * Top
         */
        top: 3,
        /**
         * Bottom
         */
        bottom: 4
    };

    /**
     * The types of association items available.
     * @enum {number}
     * @readonly
     * @category Associations
     */
    EVWEB2.associationType = {
        /**
         * None
         */
        none: 0,
        /**
         * Record video
         */
        recordVideo: 1,
        /**
         * Video output
         */
        videoOutput: 2,
        /**
         * Audio input
         */
        audioInput: 3,
        /**
         * Audio output
         */
        audioOutput: 4,
        /**
         * Serial port
         */
        serialPort: 5,
        /**
         * Input trigger
         */
        inputTrigger: 6,
        /**
         * Output trigger
         */
        outputTrigger: 7,
        /**
         * Soft trigger
         */
        softTrigger: 8,
        /**
         * Analytics
         */
        analytics: 9,
        /**
         * Security Integrations
         */
        securityIntegrations: 10,
        /**
         * Digital PTZ
         */
        digitalPtz: 11,
        /**
         * Replay
         */
        replay: 12,
        /**
         * Auto-export
         */
        autoExport: 13,
        /**
         * Auto-focus
         */
        autoFocus: 14,
        /**
         * Suspect tracking
         */
        suspectTracking: 15
    };

    /**
     * The different types of PTZ associations. Returned as {@link EVWEB2.AssociationItem.extra} when
     * the type of the association item is {@link EVWEB2.associationType.digitalPtz}.
     * @enum {number}
     * @readonly
     * @category Associations
     */
    EVWEB2.associationPtzType = {
        /**
         * Mechanical PTZ preset
         */
        mechanicalPreset: 0,
        /**
         * Digital PTZ preset
         */
        digitalPreset: 1,
        /**
         * List mechanical PTZ presets
         */
        listMechanicalPresets: 2,
        /**
         * List digital PTZ presets
         */
        listDigitalPresets: 3,
        /**
         * Toggle digital PTZ
         */
        toggleDigitalPtz: 4
    };

    /**
     * Container for an association item.
     * @param {Number} id The id of the item (e.g. camera id, audio id, soft-trigger id, etc).
     * @param {EVWEB2.associationType} [type=EVWEB2.associationType.none] The type of the item in the association.
     * @param {Number} [position=0] Zero-based index to explicitly specify the item in an association
     * relative to other items.
     * @param {Boolean} [statusOnly=true] Whether the association item is for reporting status only or
     * whether it represents a toggle item.
     * @param {Number} [extra=null] If the id is not enough to specify the specific association item.
     * @constructor
     * @category Associations
     */
    EVWEB2.AssociationItem = function(id, type, position, statusOnly, extra) {

        /**
         * The id of the item (e.g. camera id, audio id, soft-trigger id, etc).
         * @type {number}
         */
        this.id = id;

        /**
         * The type of the item in the association.
         * @type {EVWEB2.associationType}
         */
        this.type = EVWEB2.associationType.none;

        /**
         * Zero-based index to explicitly specify the item in an association relative to other items.
         * @type {number}
         */
        this.position = 0;

        /**
         * Whether the association item is for reporting status only or whether it represents a toggle item.
         * @type {boolean}
         */
        this.statusOnly = false;

        /**
         * If the id is not enough to specify the specific association item.
         * @type {number|null}
         */
        this.extra = null;

        if(type !== undefined) {
            this.type = type;
        }
        if(position !== undefined) {
            this.position = position;
        }
        if(statusOnly !== undefined) {
            this.statusOnly = statusOnly;
        }
        if(extra !== undefined) {
            this.extra = extra;
        }
    };

    /**
     * Container for camera association information.
     * @param {EVWEB2.Server} server The server instance the association belongs to.
     * @param {EVWEB2.Camera} camera The camera to which the association belongs to.
     * @param {String} [guid=''] The unique association ID.
     * @param {EVWEB2.AssociationItem[]} [items=[]] The list of items in this association.
     * @param {EVWEB2.associationLabel} [label=EVWEB2.associationLabel.unknown] The association label type.
     * @param {EVWEB2.overlayStyle} [style=EVWEB2.overlayStyle.unknown] The overlay style.
     * @param {EVWEB2.overlayPosition} [position=EVWEB2.overlayPosition.unknown] The position of the overlay.
     * @param {EVWEB2.fontColor} [bgColor=EVWEB2.fontColor.unknown] The overlay background color.
     * @param {Number} [opacity=50] The opacity of the overlay, from 0 - 100 with 0 being transparent.
     * @param {EVWEB2.FontInfo} [fontInfo=new EVWEB2.FontInfo()] The font information for the overlay.
     * @constructor
     * @category Associations
     */
    EVWEB2.Association = function(server, camera, guid, items, label, style, position, bgColor, opacity, fontInfo) {

        /**
         * The server instance the association belongs to.
         * @type {EVWEB2.Server}
         */
        this.server = server;

        /**
         * The camera to which the association belongs to.
         * @type {EVWEB2.Camera}
         */
        this.camera = camera;

        /**
         * The unique association ID.
         * @type {String}
         */
        this.guid = '';

        /**
         * The list of items in this association.
         * @type {EVWEB2.AssociationItem[]}
         */
        this.items = [];

        /**
         * The association label type.
         * @type {EVWEB2.associationLabel}
         */
        this.label = EVWEB2.associationLabel.unknown;

        /**
         * The overlay style.
         * @type {EVWEB2.overlayStyle}
         */
        this.style = EVWEB2.overlayStyle.unknown;

        /**
         * The position of the overlay.
         * @type {EVWEB2.overlayPosition}
         */
        this.position = EVWEB2.overlayPosition.unknown;

        /**
         * The overlay background color.
         * @type {EVWEB2.fontColor}
         */
        this.bgColor = EVWEB2.fontColor.unknown;

        /**
         * The opacity of the overlay, from 0 - 100 with 0 being transparent.
         * @type {Number}
         */
        this.opacity = 50;

        /**
         * The font information for the overlay.
         * @type {EVWEB2.FontInfo}
         */
        this.fontInfo = new EVWEB2.FontInfo();

        if(guid !== undefined) {
            this.guid = guid;
        }
        if(items !== undefined) {
            this.items = items;
        }
        if(label !== undefined) {
            this.label = label;
        }
        if(style !== undefined) {
            this.style = style;
        }
        if(position !== undefined) {
            this.position = position;
        }
        if(bgColor !== undefined) {
            this.bgColor = bgColor;
        }
        if(opacity !== undefined) {
            this.opacity = opacity;
        }
        if(fontInfo !== undefined) {
            this.fontInfo = fontInfo;
        }
    };

}());

/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * The connection status of an security integrations device
     * @enum {number}
     * @readonly
     * @category Security Integrations
     */
    EVWEB2.securityIntegrationsDeviceConnectionStatus = {
        /**
         * Bad message format
         */
        badMessageFormat: -13,
        /**
         * Command not supported
         */
        commandNotSupported: -12,
        /**
         * Internal error
         */
        internalError: -11,
        /**
         * Operator error
         */
        operatorError: -6,
        /**
         * Command failed
         */
        commandFailed: -5,
        /**
         * Authentication error
         */
        authenticationError: -4,
        /**
         * Connection error
         */
        connectionError: -3,
        /**
         * Uninitialized
         */
        uninitialized: 0,
        /**
         * Not connected
         */
        notConnected: 1,
        /**
         * Connecting
         */
        connecting: 2,
        /**
         * Connection successful
         */
        connectionSuccessful: 3,
        /**
         * Authenticating
         */
        authenticating: 4,
        /**
         * Command request
         */
        commandRequest: 5
    };


    /**
     * The actions that can be applied to an security integrations device sensor.
     * @enum {number}
     * @readonly
     * @category Security Integrations
     */
    EVWEB2.securityIntegrationsSensorAction = {
        /**
         * None
         */
        none: 0,
        /**
         * Lock
         */
        lock: 1,
        /**
         * Unlock
         */
        unlock: 2,
        /**
         * Arm
         */
        arm: 3,
        /**
         * Disarm
         */
        disarm: 4,
        /**
         * Activate
         */
        activate: 5,
        /**
         * Deactivate
         */
        deactivate: 6,
        /**
         * Enable reader
         */
        enableReader: 7,
        /**
         * Disable reader
         */
        disableReader: 8,
        /**
         * Card presented
         */
        cardPresented: 9,
        /**
         * Input supervised
         */
        inputSupervised: 10,
        /**
         * Input unsupervised
         */
        inputUnsupervised: 11,
        /**
         * Input normal
         */
        inputNormal: 12,
        /**
         * Arm Away
         */
        armAway: 13,
        /**
         * Arm Stay
         */
        armStay: 14,
        /**
         * Arm No entry delay
         */
        armNoEntryDelay: 15
    };

    /**
     * The types of security integrations device sensors.
     * @enum {number}
     * @readonly
     * @category Security Integrations
     */
    EVWEB2.securityIntegrationsSensorType = {
        /**
         * None
         */
        none: -1,
        /**
         * Relay
         */
        relay: 0,
        /**
         * Input
         */
        input: 1,
        /**
         * Lock
         */
        lock: 2,
        /**
         * Rex
         */
        rex: 3,
        /**
         * Reader
         */
        reader: 4,
        /**
         * Door
         */
        door: 5,
        /**
         * Partition
         */
        partition: 6,
        /**
         * Zone
         */
        zone: 7
    };

    /**
     * The available directions of security integrations device sensors.
     * @enum {number}
     * @readonly
     * @category Security Integrations
     */
    EVWEB2.securityIntegrationsSensorDirection = {
        /**
         * None
         */
        none: -1,
        /**
         * In
         */
        directionIn: 0,
        /**
         * Out
         */
        directionOut: 1,
        /**
         * In-Out
         */
        directionInOut: 2
    };

    /**
     * The available states of an security integrations device sensor.
     * @enum {number}
     * @readonly
     * @category Security Integrations
     */
    EVWEB2.securityIntegrationsSensorState = {
        /**
         * Invalid
         */
        invalid: 0,
        /**
         * Input normal
         */
        inputNormal: 1,
        /**
         * Input Alarmed
         */
        inputAlarmed: 2,
        /**
         * Locked
         */
        locked: 3,
        /**
         * Unlocked
         */
        unlocked: 4,
        /**
         * Armed
         */
        armed: 5,
        /**
         * Disarmed
         */
        disarmed: 6,
        /**
         * Activated
         */
        activated: 7,
        /**
         * Deactivated
         */
        deactivated: 8,
        /**
         * Reader enabled
         */
        readerEnabled: 9,
        /**
         * Reader disabled
         */
        readerDisabled: 10,
        /**
         * Open
         */
        open: 11,
        /**
         * Open too long
         */
        openTooLong: 12,
        /**
         * Closed
         */
        closed: 13,
        /**
         * Door forced open
         */
        doorForcedOpen: 14,
        /**
         * Access Granted
         */
        accessGranted: 15,
        /**
         * Access Denied
         */
        accessDenied: 16,
        /**
         * Rex Granted
         */
        rexGranted: 17,
        /**
         * Rex Denied
         */
        rexDenied: 18,
        /**
         * Lock failure
         */
        lockFailure: 19,
        /**
         * Input supervised
         */
        inputSupervised: 20,
        /**
         * Input not supervised
         */
        inputNotSupervised: 21,
        /**
         * Partition pre-alarm
         */
        partitionPreAlarm: 22,
        /**
         * Partition pre-disarm
         */
        partitionPreDisarm: 23,
        /**
         * Partition alarm
         */
        partitionAlarm: 24,
        /**
         * Partition armed stay
         */
        partitionArmedStay: 25,
        /**
         * Partition armed away
         */
        partitionArmedAway: 26,
        /**
         * Partition armed no entry delay
         */
        partitionArmedNoEntryDelay: 27,
        /**
         * Partition not ready
         */
        partitionNotReady: 28,
        /**
         * Zone open
         */
        zoneOpen: 29,
        /**
         * Zone alarm
         */
        zoneAlarm: 30,
        /**
         * Not monitoring
         */
        notMonitoring: 998,
        /**
         * Error
         */
        error: 999
    };

    /**
     * The available alarm states for an security integrations device sensor.
     * @enum {number}
     * @readonly
     * @category Security Integrations
     */
    EVWEB2.securityIntegrationsSensorAlarm = {
        /**
         * Alert
         */
        alert: 1,
        /**
         * Alarm
         */
        alarm: 2
    };

    /**
     * The available authentication types for a security integration device.
     * @enum {number}
     * @readonly
     * @category Security Integrations
     */
    EVWEB2.securityIntegrationsAuthType = {
        /**
         * None
         */
        none: 0,
        /**
         * Username and password
         */
        userPass: 1,
        /**
         * Access code
         */
        accessCode: 2
    };

    /**
     * The error codes for failing sensor actions.
     * @enum {number}
     * @readonly
     * @category Security Integrations
     */
    EVWEB2.securityIntegrationsSensorErrorType = {
        /**
         * Permission error
         */
        permissionError: -10,
        /**
         * Invalid command
         */
        invalidCommand: -9,
        /**
         * Command timeout
         */
        commandTimeout: -8,
        /**
         * Invalid session
         */
        invalidSession: -7,
        /**
         * Other
         */
        other: -6,
        /**
         * Command OK
         */
        commandOk: 0
    };

    /**
     * Container for traditional type credentials for security integrations devices.  See
     * {@link EVWEB2.SecurityIntegrationsDevice.login} for more details.
     * @param {String} username The username for the device.
     * @param {String} [password=null] The password for the device.
     * @constructor
     * @category Security Integrations
     */
    EVWEB2.SecurityIntegrationsDeviceCredsTraditional = function(username, password) {
        /**
         * The auth type implemented by this credentials.
         * @type {EVWEB2.securityIntegrationsAuthType}
         */
        this.authType = EVWEB2.securityIntegrationsAuthType.userPass;

        /**
         * The username for the device.
         * @type {String}
         */
        this.username = username;

        /**
         * The password for the device.
         * @type {String|null}
         */
        this.password = null;

        if(password !== undefined) {
            this.password = password;
        }
    };

    /**
     * Container for access code type credentials for security integrations devices.  See
     * {@link EVWEB2.SecurityIntegrationsDevice.login} for more details.
     * @param {String} accessCode The access code for the device.
     * @constructor
     * @category Security Integrations
     */
    EVWEB2.SecurityIntegrationsDeviceCredsAccessCode = function(accessCode) {
        /**
         * The auth type implemented by this credentials.
         * @type {EVWEB2.securityIntegrationsAuthType}
         */
        this.authType = EVWEB2.securityIntegrationsAuthType.accessCode;

        /**
         * The access code for the device.
         * @type {String}
         */
        this.accessCode = accessCode;
    };

    /**
     * Container for an security integrations device
     * @param {EVWEB2.Server} server The server associated with the security integrations device.
     * @param {Number} id The ID of the security integrations device.
     * @param {String} [name=""] The name of the device.
     * @param {String} [host=""] The host of the device.
     * @param {Number} [port=0] The port of the device.
     * @param {String} [type=""] The manufacturer of the device.
     * @param {boolean} [enabled=false] Whether the device is enabled.
     * @param {EVWEB2.securityIntegrationsDeviceConnectionStatus} [connectionStatus=EVWEB2.securityIntegrationsDeviceConnectionStatus.uninitialized]
     * The connection status of the device.
     * @param {String} [firmware=""] The firmware version of the device.
     * @param {String} [serial=""] The serial of the device.
     * @param {String} [user=""] The username used to configure the device.
     * @param {EVWEB2.securityIntegrationsAuthType} [authType=EVWEB2.securityIntegrationsAuthType.userPass] The
     * authentication type used by the device.
     * @constructor
     * @category Security Integrations
     */
    EVWEB2.SecurityIntegrationsDevice = function(server, id, name, host, port, type, enabled, connectionStatus,
                                                 firmware, serial, user, authType) {

        /**
         * The server associated with the security integrations device.
         * @type {EVWEB2.Server}
         */
        this.server = server;

        /**
         * The ID of the security integrations device.
         * @type {number}
         */
        this.id = id;

        /**
         * The host of the device.
         * @type {String}
         */
        this.name = "";

        /**
         * The host of the device.
         * @type {String}
         */
        this.host = "";

        /**
         * The port of the device.
         * @type {Number}
         */
        this.port = 0;

        /**
         * The manufacturer of the device.
         * @type {string}
         */
        this.type = "";

        /**
         * Whether the device is enabled.
         * @type {boolean}
         */
        this.enabled = false;

        /**
         * The connection status of the device.
         * @type {EVWEB2.securityIntegrationsDeviceConnectionStatus}
         */
        this.connectionStatus = EVWEB2.securityIntegrationsDeviceConnectionStatus.uninitialized;

        /**
         * The firmware version of the device.
         * @type {string}
         */
        this.firmware = "";

        /**
         * The serial of the device.
         * @type {string}
         */
        this.serial = "";

        /**
         * The username used to configure the device.
         * @type {string}
         */
        this.user = "";

        /**
         * The token used to perform sensor actions, used internally by {@link EVWEB2.SecurityIntegrationsDeviceSensor.performAction}.
         * This token is generated by {@link EVWEB2.SecurityIntegrationsDevice.login} and should not be set manually.
         * @type {String|null}
         */
        this.token = null;

        /**
         * The expiration date of the token.
         * @type {Date|null}
         */
        this.tokenExpiration = null;

        /**
         * The authentication type used by this device.
         * @type {EVWEB2.securityIntegrationsAuthType}
         */
        this.authType = EVWEB2.securityIntegrationsAuthType.userPass;

        if(name !== undefined) {
            this.name = name;
        }
        if(host !== undefined) {
            this.host = host;
        }
        if(port !== undefined) {
            this.port = port;
        }
        if(type !== undefined) {
            this.type = type;
        }
        if(enabled !== undefined) {
            this.enabled = enabled;
        }
        if(connectionStatus !== undefined) {
            this.connectionStatus = connectionStatus;
        }
        if(firmware !== undefined) {
            this.firmware = firmware;
        }
        if(serial !== undefined) {
            this.serial = serial;
        }
        if(user !== undefined) {
            this.user = user;
        }
        if(authType !== undefined) {
            this.authType = authType;
        }

        /**
         * Retrieves the list of sensors for this device.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         *  {@link EVWEB2.SecurityIntegrationsDeviceSensor} objects detailing all of the sensors associated with the
         *  device.
         */
        this.getSensors = function(callback) {
            var device = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                // Process the devices
                var sensors = $.map(data.sensors, function(element) {
                    var timestamp = element.statusTimestamp ?
                        EVWEB2.util.IETF2Date(element.statusTimestamp) : undefined;

                    var persistedStatuses = element.persistedStatus ? element.persistedStatus.map(function(obj){
                        obj.statusTimestamp = EVWEB2.util.IETF2Date(obj.statusTimestamp);
                        return obj;
                    }) : undefined;

                    return new EVWEB2.SecurityIntegrationsDeviceSensor(device, element.sensorId, element.name,
                        element.type, element.direction, element.availableActions, element.inputs,
                        element.defaultActionTimeout, element.maxActionTimeout, element.status, element.alarm,
                        timestamp, element.statusMessage, persistedStatuses);
                });

                callback(successResponse, sensors);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: device.server.service.url() + EVWEB2.urls.securityIntegrationsDeviceSensors,
                data: {
                    s: device.server.sessionId,
                    device: device.id
                }
            };

            EVWEB2.ajax(settings, device.server.service);
        };

        /**
         * Logs into the device, retrieving a token for use in
         * {@link EVWEB2.SecurityIntegrationsDeviceSensor.performAction}. Note: The web service will store the
         * provided username and password and associate those with the returned token for the duration of the
         * expiration period provided or until a {@link EVWEB2.SecurityIntegrationsDevice} is performed.  As such,
         * this token should be protected from unauthorized use.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response, the generated token for use
         *  with {@link EVWEB2.SecurityIntegrationsDeviceSensor.performAction}, the expiration date of the token, and
         *  an array of {@link EVWEB2.SecurityIntegrationsDeviceSensor} IDs that the logged in user can access.
         * @param {EVWEB2.SecurityIntegrationsDeviceCredsTraditional|EVWEB2.SecurityIntegrationsDeviceCredsAccessCode} credentials The credentials to log into the device.
         * @param {Date} expiration The date at which the generated token should expire.  Note: values more
         * than 30 days in the future will be normalized to 30 days.  Be sure to check the response value
         * for the actual expiration date.
         */
        this.login = function(callback, credentials, expiration) {
            var device = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                device.token = data.token;
                device.tokenExpiration = EVWEB2.util.IETF2Date(data.expiration);

                callback(successResponse, device.token, device.tokenExpiration, data.sensors);
            };

            var data = {
                s: device.server.sessionId,
                device: device.id,
                username: credentials.username,
                password: credentials.password,
                expiration: EVWEB2.util.Date2IETF(expiration)
            };

            if(credentials.authType === EVWEB2.securityIntegrationsAuthType.userPass) {
                data.username = credentials.username;
                data.password = credentials.password;
            }
            else if(credentials.authType === EVWEB2.securityIntegrationsAuthType.accessCode) {
                data.accessCode = credentials.accessCode;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: device.server.service.url() + EVWEB2.urls.securityIntegrationsDeviceLogin,
                type: 'POST',
                data: data
            };

            EVWEB2.ajax(settings, device.server.service);
        };

        /**
         * Checks whether the device is currently logged in.
         * @return {boolean} Whether the device is currently logged in.
         */
        this.isLoggedIn = function() {
            if(this.authType === EVWEB2.securityIntegrationsAuthType.none) {
                return true;
            }
            if(this.token === null) {
                return false;
            }
            return this.tokenExpiration > new Date();
        };

        /**
         * Logs out of the device.  Note: after performing this action, the token is destroyed and cannot be used
         * again.  Additionally, any calls to {@link EVWEB2.SecurityIntegrationsDeviceSensor.performAction} for sensors
         * associated with this device will fail until another login call is made.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response.
         */
        this.logout = function(callback) {
            var device = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                device.token = null;
                device.tokenExpiration = null;

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };

            if(device.token === null) {
                var errorResponse = new EVWEB2.ResponseStatus(false, "Not logged in.");
                callback(errorResponse);
                return;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: device.server.service.url() + EVWEB2.urls.securityIntegrationsDeviceLogin,
                type: 'DELETE',
                data: {
                    s: device.server.sessionId,
                    device: device.id,
                    token: device.token
                }
            };

            EVWEB2.ajax(settings, device.server.service);
        };

    };

    /**
     * Container for an security integrations device sensor.
     * @param {EVWEB2.SecurityIntegrationsDevice} device The security integrations device associated with this sensor.
     * @param {Number} id The ID of the sensor.
     * @param {String} [name=""] The name of the sensor.
     * @param {EVWEB2.securityIntegrationsSensorType} [type=EVWEB2.securityIntegrationsSensorType.none] The type of sensor.
     * @param {EVWEB2.securityIntegrationsSensorDirection} [direction=EVWEB2.securityIntegrationsSensorDirection.none] The direction
     * of the sensor.
     * @param {EVWEB2.securityIntegrationsSensorAction[]} [availableActions=[]] The actions available to perform by the sensor.
     * @param {Number[]} [inputs=[]] Associated {@link EVWEB2.SecurityIntegrationsDeviceSensor} IDs contained by this sensor.
     * @param {Number} [defaultActionTimeout=0] The default timeout, in seconds, of performing an action.
     * @param {Number} [maxActionTimeout=0] The maximum timeout, in seconds, of performing an action.
     * @param {EVWEB2.securityIntegrationsSensorState[]} [status=[]] The current states of the sensor.
     * @param {EVWEB2.securityIntegrationsSensorAlarm[]} [alarm=[]] The current alarms of the sensor.
     * @param {Date} [statusTimestamp=null] The timestamp of the last status event
     * @param {String} [statusMessage=''] The status message if available (specific to the sensor type)
     * @param {Object[]} [persistedStatus=[]] The persisted status of the sensor.
     * @constructor
     * @category Security Integrations
     */
    EVWEB2.SecurityIntegrationsDeviceSensor = function(device, id, name, type, direction, availableActions,
                                                       inputs, defaultActionTimeout, maxActionTimeout, status, alarm,
                                                       statusTimestamp, statusMessage, persistedStatus) {

        /**
         * The security integrations device associated with this sensor.
         * @type {EVWEB2.SecurityIntegrationsDevice}
         */
        this.device = device;

        /**
         * The ID of the sensor.
         * @type {Number}
         */
        this.id = id;

        /**
         * The name of the sensor.
         * @type {string}
         */
        this.name = "";

        /**
         * The type of sensor.
         * @type {EVWEB2.securityIntegrationsSensorType}
         */
        this.type = EVWEB2.securityIntegrationsSensorType.none;

        /**
         * The direction of the sensor.
         * @type {EVWEB2.securityIntegrationsSensorDirection}
         */
        this.direction = EVWEB2.securityIntegrationsSensorDirection.none;

        /**
         * The actions available to perform by the sensor.
         * @type {EVWEB2.securityIntegrationsSensorAction[]}
         */
        this.availableActions = [];

        /**
         * Associated {@link EVWEB2.SecurityIntegrationsDeviceSensor} IDs contained by this sensor.
         * @type {Number[]}
         */
        this.inputs = [];

        /**
         * The default timeout, in seconds, of performing an action.
         * @type {number}
         */
        this.defaultActionTimeout = 0;

        /**
         * The maximum timeout, in seconds, of performing an action.
         * @type {number}
         */
        this.maxActionTimeout = 0;

        /**
         * The current states of the sensor.
         * @type {EVWEB2.securityIntegrationsSensorState[]}
         */
        this.status = [];

        /**
         * The current alarms of the sensor.
         * @type {EVWEB2.securityIntegrationsSensorAlarm[]}
         */
        this.alarm = [];

        /**
         * The timestamp of the last status information if available.
         * @type {Date}
         */
        this.statusTimestamp = null;

        /**
         * The current status message of the sensor.
         * @type {string}
         */
        this.statusMessage = '';


        /**
         * @typedef {Object} PersistedStatus
         * @property {EVWEB2.securityIntegrationsSensorState[]} status
         * @property {Date} statusTimeStamp
         * @property {string} statusMessage
         */
        /**
         * The persisted status of the sensor, e.g. for a reader this would hold the last card
         * used, the time, and access granted/denied status.
         * @type {PersistedStatus[]}
         */
        this.persistedStatus = [];

        if(name !== undefined) {
            this.name = name;
        }
        if(type !== undefined) {
            this.type = type;
        }
        if(direction !== undefined) {
            this.direction = direction;
        }
        if(availableActions !== undefined) {
            this.availableActions = availableActions;
        }
        if(inputs !== undefined) {
            this.inputs = inputs;
        }
        if(defaultActionTimeout !== undefined) {
            this.defaultActionTimeout = defaultActionTimeout;
        }
        if(maxActionTimeout !== undefined) {
            this.maxActionTimeout = maxActionTimeout;
        }
        if(status !== undefined) {
            this.status = status;
        }
        if(alarm !== undefined) {
            this.alarm = alarm;
        }
        if(statusTimestamp !== undefined) {
            this.statusTimestamp = statusTimestamp;
        }
        if(statusMessage !== undefined) {
            this.statusMessage = statusMessage;
        }

        if(persistedStatus !== undefined) {
            this.persistedStatus = persistedStatus;
        }


        /**
         * Perform an action with this sensor.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response, a boolean if the action was
         *  successful, and a EVWEB2.securityIntegrationsSensorErrorType value indicating the status of the
         *  operation.
         * @param {EVWEB2.securityIntegrationsSensorAction} action The action to perform.
         * @param {Number} [timeout=0] The timeout for the action
         */
        this.performAction = function(callback, action, timeout) {
            var instance = this;

            if (!instance.device.isLoggedIn()){
                var errorResponse = new EVWEB2.ResponseStatus(false, 'Not logged in');
                callback(errorResponse);
                return;
            }

            if (timeout === undefined) {
                timeout = instance.defaultActionTimeout;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse, false);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse, false);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.actionSuccessful, data.operationStatus);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.device.server.service.url() + EVWEB2.urls.securityIntegrationsDeviceSensors,
                type: 'POST',
                data: {
                    s: instance.device.server.sessionId,
                    token: instance.device.token,
                    device: instance.device.id,
                    sensor: instance.id,
                    action: action,
                    timeout: timeout
                }
            };

            EVWEB2.ajax(settings, instance.device.server.service);
        };
    };
}());
/*globals EVWEB2:true*/
/**
 * @namespace EVWEB2
 */
(function() {
    "use strict";

    /**
     * The positions available for camera OSD text.
     * @enum {number}
     * @readonly
     * @category Camera
     */
    EVWEB2.osdPosition = {
        /**
         * None
         */
        none: 0,
        /**
         * Top-Left
         */
        topLeft: 1,
        /**
         * Top-Center
         */
        topCenter: 2,
        /**
         * Top-Right
         */
        topRight: 3,
        /**
         * Bottom-Left
         */
        bottomLeft: 7,
        /**
         * Bottom-Center
         */
        bottomCenter: 8,
        /**
         * Bottom-Right
         */
        bottomRight: 9
    };

    /**
     * The OSD text available for display.
     * @enum {number}
     * @readonly
     * @category Camera
     */
    EVWEB2.osdDisplay = {
        /**
         * Name
         */
        name: 0x8,
        /**
         * Time
         */
        time: 0x4,
        /**
         * Timezone
         */
        timezone: 0x2,
        /**
         * Date
         */
        date: 0x1
    };

    /**
     * The CameraOsdInfo object is a container for the OSD information for a camera.
     * @param {EVWEB2.osdPosition} [position=EVWEB2.osdPosition.none] The position of the OSD.
     * @param {Boolean} [name=false] Boolean flag for whether the camera name should be displayed on the OSD.
     * @param {Boolean} [time=true] Boolean flag for whether the time should be displayed on the OSD.
     * @param {Boolean} [date=false] Boolean flag for whether the date should be displayed on the OSD.
     * @param {Boolean} [timezone=false] Boolean flag for whether the timezone should be displayed on the OSD.
     * @param {String} [font='Sans'] The font used for displaying the OSD.
     * @param {Number} [fontSize=10] The font size used for displaying the OSD.
     * @param {EVWEB2.fontColor} [fontColor=EVWEB2.fontColor.white] The font color used for displaying the OSD.
     * @param {EVWEB2.fontStyle} [fontStyle=EVWEB2.fontStyle.normal] The font style used for displaying the OSD.
     * @param {EVWEB2.fontFamily} [fontFamily=EVWEB2.fontFamily.default] The font family used for displaying the OSD.
     * @param {EVWEB2.fontWeight} [fontWeight=EVWEB2.fontWeight.light] The font weight used for displaying the OSD.
     * @param {Boolean} [backgroundEnabled=false] Boolean flag for whether the background color should be displayed on the OSD.
     * @param {EVWEB2.fontColor} [backgroundColor=EVWEB2.fontColor.black] The background color for displaying OSD.
     * @param {Number} [backgroundAlpha=0] The alpha value of background color for displaying OSD.
     * @constructor
     * @category Camera
     */
    EVWEB2.CameraOsdInfo = function(position, name, time, date, timezone, font, fontSize, fontColor, fontStyle,
                                    fontFamily, fontWeight, backgroundEnabled, backgroundColor, backgroundAlpha){

        /**
         * The position of the OSD information.
         * @type {EVWEB2.osdPosition}
         */
        this.position = EVWEB2.osdPosition.none;

        /**
         * Boolean flag for whether the camera name should be displayed on the OSD.
         * @type {boolean}
         */
        this.name = false;

        /**
         * Boolean flag for whether the time should be displayed on the OSD.
         * @type {boolean}
         */
        this.time = false;

        /**
         * Boolean flag for whether the date should be displayed on the OSD.
         * @type {boolean}
         */
        this.date = false;

        /**
         * Boolean flag for whether the timezone should be displayed on the OSD.
         * @type {boolean}
         */
        this.timezone = false;

        /**
         * The font used for displaying OSD.
         * @type {String}
         */
        this.font = 'Sans';

        /**
         * The font size for displaying OSD.
         * @type {Number}
         */
        this.fontSize = 10;

        /**
         * The font color for displaying OSD.
         * @type {EVWEB2.fontColor}
         */
        this.fontColor = EVWEB2.fontColor.white;

        /**
         * The font style for displaying OSD.
         * @type {EVWEB2.fontStyle}
         */
        this.fontStyle = EVWEB2.fontStyle.normal;

        /**
         * The font family for displaying OSD.
         * @type {EVWEB2.fontStyle}
         */
        this.fontFamily = EVWEB2.fontFamily.defaultFont;

        /**
         * The font weight for displaying OSD.
         * @type {EVWEB2.fontWeight}
         */
        this.fontWeight = EVWEB2.fontWeight.light;

        /**
         * Boolean flag for whether the background color should be displayed on the OSD.
         * @type {Boolean}
         */
        this.backgroundEnabled = false;

        /**
         * The background color for displaying OSD.
         * @type {EVWEB2.fontColor}
         */
        this.backgroundColor = EVWEB2.fontColor.black;

        /**
         * The alpha value of background color for displaying OSD.
         * @type {Number}
         */
        this.backgroundAlpha = 0;

        if(position !== undefined) {
            this.position = position;
        }

        if(name !== undefined) {
            this.name = name;
        }

        if(time !== undefined) {
            this.time = time;
        }

        if(date !== undefined) {
            this.date = date;
        }

        if(timezone !== undefined) {
            this.timezone = timezone;
        }

        if(font !== undefined) {
            this.font = font;
        }

        if(fontSize !== undefined) {
            this.fontSize = fontSize;
        }

        if(fontColor !== undefined) {
            this.fontColor = fontColor;
        }

        if(fontStyle !== undefined) {
            this.fontStyle = fontStyle;
        }

        if(fontFamily !== undefined) {
            this.fontFamily = fontFamily;
        }

        if(fontWeight !== undefined) {
            this.fontWeight = fontWeight;
        }

        if(backgroundEnabled !== undefined) {
            this.backgroundEnabled = backgroundEnabled;
        }

        if(backgroundColor !== undefined) {
            this.backgroundColor = backgroundColor;
        }

        if(backgroundAlpha !== undefined) {
            this.backgroundAlpha = backgroundAlpha;
        }

        /**
         * Retrieve the bitmask value used for setting the OSD display
         * @returns {number} The bitmask OSD value
         * @internal
         */
        this.getDisplayBitmask = function(){
            /* eslint-disable no-bitwise */
            var bitmask = 0;

            if(this.name) {
                bitmask |= EVWEB2.osdDisplay.name;
            }

            if(this.date){
                bitmask |= EVWEB2.osdDisplay.date;
            }

            if(this.time){
                bitmask |= EVWEB2.osdDisplay.time;
            }

            if(this.timezone){
                bitmask |= EVWEB2.osdDisplay.timezone;
            }
            /* eslint-enable no-bitwise */

            return bitmask;
        };
    };

    /**
     * Camera Configuration container
     * @param {EVWEB2.Camera} camera the camera instance the config belongs to
     * @constructor
     * @category Camera
     */
    EVWEB2.CameraConfig = function(camera) {
        if(camera === undefined){
            throw new Error('Camera required');
        }

        /**
         * The camera instance this config belongs to
         * @type {EVWEB2.Camera}
         */
        this.camera = camera;

        /**
         * Cached OSD information.
         * @type {EVWEB2.CameraOsdInfo}
         */
        var osdInfo = null;

        /**
         * The average frame size received from the camera
         * @type {number}
         */
        var averageFrameSize = 0;

        /**
         *
         * The setOsdInfo is a method that sets the OSD display information for a camera on the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance with the details of the response.
         * @param {EVWEB2.CameraOsdInfo} cameraOsdInfo The new OSD info to apply to the camera.
         */
        this.setOsdInfo = function(callback, cameraOsdInfo){
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            if(cameraOsdInfo === undefined) {
                throw new Error('CameraOsdInfo required');
            }

            var onSetCameraOsdError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSetCameraOsdSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };

            var params = {
                s: this.camera.server.sessionId,
                camera: this.camera.id,
                position: cameraOsdInfo.position,
                display: cameraOsdInfo.getDisplayBitmask(),
                fontName: cameraOsdInfo.font,
                fontSize: cameraOsdInfo.fontSize,
                evFontColor: cameraOsdInfo.fontColor,
                evFontFamily: cameraOsdInfo.fontFamily,
                evFontStyle: cameraOsdInfo.fontStyle,
                evFontWeight: cameraOsdInfo.fontWeight,
                backgroundEnabled: cameraOsdInfo.backgroundEnabled,
                backgroundColor: cameraOsdInfo.backgroundColor,
                backgroundAlpha: cameraOsdInfo.backgroundAlpha
            };

            var settings = {
                success: onSetCameraOsdSuccess,
                error: onSetCameraOsdError,
                url: this.camera.server.service.url() + EVWEB2.urls.camera,
                data: params,
                type: 'POST'
            };
            EVWEB2.ajax(settings, this.camera.server.service, true);
        };

        /**
         * Utility function to generate the legacy OSD position strings still in use
         * from the new {@link EVWEB2.osdPosition} enumerations.
         * @param {EVWEB2.osdPosition} newPosition The new OSD position value.
         * @returns {String} The corresponding legacy string that matches the new position.
         */
        var generateDeprecatedOsdPosition = function(newPosition){
            var oldPosition;
            switch(newPosition){
                case EVWEB2.osdPosition.bottomLeft:
                    oldPosition = 'bottom-left';
                    break;
                case EVWEB2.osdPosition.bottomCenter:
                    oldPosition = 'bottom-center';
                    break;
                case EVWEB2.osdPosition.bottomRight:
                    oldPosition = 'bottom-right';
                    break;
                case EVWEB2.osdPosition.topLeft:
                    oldPosition = 'top-left';
                    break;
                case EVWEB2.osdPosition.topCenter:
                    oldPosition = 'top-center';
                    break;
                case EVWEB2.osdPosition.topRight:
                    oldPosition = 'top-right';
                    break;
                default:
                    oldPosition = 'none';
            }
            return oldPosition;
        };

        /* TODO The camera.web endpoint exposes a lot of this information from a single endpoint
         * there should be a higher level function that can be called to update all of the configuration
         * state at once (osd info, average frame size, etc). Each get method should call that higher level
         * function which updates all of the configuration state at once instead of each function re-querying
         * the server
         */

        /**
         * Retrieves the OSD information for a camera from the web service.
         * @param {Function} callback Callback function to be executed when the call completes. The function gets
         * passed a {@link EVWEB2.ResponseStatus} instance with the details of the response, an instance of
         * {@link EVWEB2.CameraOsdInfo}, and the camera {@link EVWEB2.Camera} instance it belongs to.
         * @param {Boolean} [forceUpdate=false] Flag to use cached OSD information or not. By default if OSD information
         * has already been fetched and is available this function will return that. When true this function will always
         * query the server for the latest OSD information.
         */
        this.getOsdInfo = function(callback, forceUpdate) {
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            if(forceUpdate === undefined){
                forceUpdate = false;
            }

            var instance = this;

            if(osdInfo !== null && !forceUpdate){
                // use cached value
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, osdInfo, instance.camera);
                return;
            }

            var onGetCameraOsdError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetCameraOsdSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                if(osdInfo === null) {
                    osdInfo = new EVWEB2.CameraOsdInfo();
                }

                osdInfo.position = data.camera.osdInfo.position;
                /* eslint-disable no-bitwise */
                osdInfo.name = Boolean(data.camera.osdInfo.display & EVWEB2.osdDisplay.name);
                osdInfo.time = Boolean(data.camera.osdInfo.display & EVWEB2.osdDisplay.time);
                osdInfo.date = Boolean(data.camera.osdInfo.display & EVWEB2.osdDisplay.date);
                osdInfo.timezone = Boolean(data.camera.osdInfo.display & EVWEB2.osdDisplay.timezone);
                /* eslint-enable no-bitwise */
                osdInfo.font = data.camera.osdInfo.fontName;
                osdInfo.fontSize = data.camera.osdInfo.fontSize;
                osdInfo.fontColor = data.camera.osdInfo.evFontColor;
                osdInfo.fontStyle = data.camera.osdInfo.evFontStyle;
                osdInfo.fontFamily = data.camera.osdInfo.evFontFamily;
                osdInfo.fontWeight = data.camera.osdInfo.evFontWeight;
                osdInfo.backgroundEnabled = data.camera.osdInfo.backgroundEnabled;
                osdInfo.backgroundColor = data.camera.osdInfo.backgroundColor;
                osdInfo.backgroundAlpha = data.camera.osdInfo.backgroundAlpha;


                // update deprecated osd information
                instance.camera.osd.position = generateDeprecatedOsdPosition(osdInfo.position);
                instance.camera.osd.name = osdInfo.name;
                instance.camera.osd.time = osdInfo.time;
                instance.camera.osd.date = osdInfo.date;
                instance.camera.osd.timezone = osdInfo.timezone;

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, osdInfo, instance.camera);
            };

            var params = {
                s: this.camera.server.sessionId,
                camera: this.camera.id
            };

            var settings = {
                success: onGetCameraOsdSuccess,
                error: onGetCameraOsdError,
                url: this.camera.server.service.url() + EVWEB2.urls.camera,
                data: params
            };

            EVWEB2.ajax(settings, this.camera.server.service);
        };


        /**
         * Retrieves the average frame size received for a camera from the web service.
         * @param {Function} callback Callback function to be executed when the call completes. The function gets
         * passed a {@link EVWEB2.ResponseStatus} instance with the details of the response, the average frame size,
         * and the {@link EVWEB2.Camera} instance
         */
        this.getAverageFrameSize = function(callback) {

            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var instance = this;

            var onGetAvgFrameSizeError= function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetAvgFrameSizeSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                averageFrameSize = data.camera.averageFrameSize;

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, averageFrameSize, instance.camera);
            };

            var params = {
                s: this.camera.server.sessionId,
                camera: this.camera.id
            };

            var settings = {
                success: onGetAvgFrameSizeSuccess,
                error: onGetAvgFrameSizeError,
                url: this.camera.server.service.url() + EVWEB2.urls.camera,
                data: params
            };

            EVWEB2.ajax(settings, this.camera.server.service);
        };
    };

    /**
     * Definitions for the types of digital PTZ available to cameras.
     * @enum {number}
     * @category Camera
     * @readonly
     */
    EVWEB2.digitalPtzTypes = {
        /**
         * Normal
         */
        normal: 1,
        /**
         * Dewarp
         */
        dewarp: 2,
        /**
         * Panorama
         */
        panorama: 4,
        /**
         * Dual-View
         */
        dualView: 8
    };

    /**
     * Definitions for the basic types of PTZ available to cameras.
     * @enum {string}
     * @category Camera
     * @readonly
     */
    EVWEB2.ptzTypes = {
        /**
         * None
         */
        none: 'none',
        /**
         * Standard (Mechanical)
         */
        standard: 'standard',
        /**
         * Digital
         */
        digital: 'digital'
    };

    /**
     * Definitions for the ptz directions used by {@link EVWEB2.Camera.ptzMove}
     * @enum {string}
     * @readonly
     * @category Camera
     */
    EVWEB2.ptzDirections = {
        /**
         * Up-Left
         */
        upLeft: 'ul',
        /**
         * Up
         */
        up: 'u',
        /**
         * Up-Right
         */
        upRight: 'ur',
        /**
         * Left
         */
        left: 'l',
        /**
         * None
         */
        none: 'n',
        /**
         * Right
         */
        right: 'r',
        /**
         * Down-Left
         */
        downLeft: 'dl',
        /**
         * Down
         */
        down: 'd',
        /**
         * Down-Right
         */
        downRight: 'dr',
        /**
         * Zoom-In
         */
        zoomIn: 'i',
        /**
         * Zoom-Out
         */
        zoomOut: 'o'
    };


    /**
     * Definitions for the available camera formats.
     * @enum {number}
     * @readonly
     * @category Camera
     */
    EVWEB2.cameraFormats = {
        /**
         * JPEG
         */
        jpeg: 0,
        /**
         * MPEG 1
         */
        mpeg1: 1,
        /**
         * MPEG 2
         */
        mpeg2: 2,
        /**
         * h.263
         */
        h263: 3,
        /**
         * MPEG 4
         */
        mpeg4: 4,
        /**
         * h.264 (avc)
         */
        h264: 5,
        /**
         * Transcoded JPEG
         */
        transcodedJpeg: 6,
        /**
         * h.265 (hevc)
         */
        h265: 7
    };

    /**
     * Definitions for the available streaming formats.
     * @enum {string}
     * @readonly
     * @category Camera
     */
    EVWEB2.streamFormat = {
        /**
         * Direct streaming / requesting of native camera frames
         */
        native: "native",
        /**
         * Direct streaming / requesting of transcoded camera frames
         */
        transcode: "transcode"
    };

    /**
     * Definitions of the available thumbnail sizes.
     * @enum {number}
     * @readonly
     * @category Camera
     */
    EVWEB2.cameraThumbnailSizes = {
        /**
         * 80x80 thumbnail
         */
        size80x80: 0,
        /**
         * 128x128 thumbnail
         */
        size128x128: 1,
        /**
         * 200x200 thumbnail
         */
        size200x200: 2
    };

    /**
     * A digital PTZ rectangle.
     * @param {Number} [x=0] The x-coordinate of the rectangle.
     * @param {Number} [y=0] The y-coordinate of the rectangle.
     * @param {Number} [width=0] The width of the rectangle.
     * @param {Number} [height=0] The height of the rectangle.
     * @constructor
     * @class
     * @category Camera
     */
    EVWEB2.DigitalPtzRectangle = function(x, y, width, height) {
        /**
         * The x-coordinate of the rectangle.
         * @type Number
         */
        this.x = 0;

        /**
         * The y-coordinate of the rectangle.
         * @type Number
         */
        this.y = 0;

        /**
         * The width of the rectangle.
         * @type Number
         */

        this.width = 0;

        /**
         * The height of the rectangle.
         * @type Number
         */
        this.height = 0;

        //Assign the constructor values
        if(typeof x !== 'undefined') {
            this.x = x;
        }
        if(typeof y !== 'undefined') {
            this.y = y;
        }
        if(typeof width !== 'undefined') {
            this.width = width;
        }
        if(typeof height !== 'undefined') {
            this.height = height;
        }
    };


    /**
     * A PTZ preset retrieved from {@link EVWEB2.Camera.getPtzPresets}
     * @param {String} [id=''] The ID of the PTZ preset.
     * @param {String} [name='Undefined'] The name of the PTZ preset.
     * @constructor
     * @class
     * @category Camera
     */
    EVWEB2.PtzPreset = function(id, name) {
        /**
         * Unique ID for this PTZ preset
         * @type String
         */
        this.id = '';

        /**
         * Name of this PTZ preset
         * @type String
         */
        this.name = 'Undefined';

        //Assign the constructor values
        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof name !== 'undefined') {
            this.name = name;
        }
    };

    /**
     * A camera resolution.
     * @param {Number} [width=0] The width, in pixels, of the resolution.
     * @param {Number} [height=0] The height, in pixels, of the resolution.
     * @constructor
     * @class
     * @category Camera
     */
    EVWEB2.CameraResolution = function(width, height) {
        /**
         * The width, in pixels, of the resolution.
         * @type Number
         */
        this.width = 0;

        /**
         * The height, in pixels, of the resolution.
         * @type Number
         */
        this.height = 0;

        //Assign the constructor values
        if(typeof width !== 'undefined') {
            this.width = width;
        }
        if(typeof height !== 'undefined') {
            this.height = height;
        }
    };

    /**
     * The camera object acts as a large container for all the camera feed operations and information.
     * It is initially populated from the information retrieved in the {@link EVWEB2.Server.getCameras} function and
     * holds the unique information for an individual camera on an exacqVision server.  The information
     * can be used to then retrieve images or searching information from the server specific to this camera
     * device.
     * @param {EVWEB2.Server} [server=null] Server instance this camera is associated with.
     * @param {String} [id=''] ID of the camera according to the web service.
     * @param {String} [ctx=''] Context ID for this camera.
     * @param {String} [name='Undefined'] Name of this camera.
     * @param {Boolean} [ptz=false] Boolean flag for whether PTZ is attached to this camera.
     * @param {Boolean} [disabled=true] Boolean flag for whether the camera is disabled.
     * @param {Boolean} [hasVideo=false] Boolean flag for whether the camera gets video.
     * @param {Object} [osd={}] Object containing all OSD information.
     * @param {String} [osd.position='none'] The position of the OSD.
     * @param {Boolean} [osd.name=false] Boolean flag for whether the camera name should be displayed on the OSD.
     * @param {Boolean} [osd.time=false] Boolean flag for whether the time should be displayed on the OSD.
     * @param {Boolean} [osd.date=false] Boolean flag for whether the date should be displayed on the OSD.
     * @param {Boolean} [osd.timezone=false] Boolean flag for whether the timezone should be displayed on the OSD.
     * @param {EVWEB2.ptzTypes} [ptzType=EVWEB2.ptzTypes.none] The type of PTZ of this camera.
     * @param {EVWEB2.digitalPtzTypes[]} [digitalPtzTypes=[]] Array of {@link EVWEB2.digitalPtzTypes} detailing the
     * digital ptz types the camera supports.
     * @param {EVWEB2.cameraFormats[]} [formats=[EVWEB2.cameraFormats.transcodedJpeg]] The formats available for
     * retrieiving video for the camera.
     * @param {EVWEB2.CameraResolution} [resolution=null] The resolution of the camera.
     * @param {Number} [quality=-1] The quality of the camera, ranging from 0-10.  For cameras with no quality
     * setting, this value will be -1.
     * @param {Number} [frameRate=-1] The frame rate of the camera.  For cameras with no frame rate setting, this
     * value will be -1.
     * @param {String} [parentId=id] If camera is a sub-context, the ID of the parent camera. Equal to its own ID if
     * otherwise.
     * @param {Number} [rotation=0] The rotation, in degrees, of the camera.
     * @param {EVWEB2.streamFormat[]} [streamFormats=[EVWEB2.streamFormat.native]] The streaming formats supported for
     * this camera.
     * @param {Boolean} [isSearchOnly=false] Boolean flag for whether or not the camera is search only.
     * @class
     * @category Camera
     */
    EVWEB2.Camera = function (server, id, ctx, name, ptz, disabled, hasVideo, osd, ptzType, digitalPtzTypes,
        formats, resolution, quality, frameRate, parentId, rotation, streamFormats, isSearchOnly) {
        /**
         * Unique ID for this camera
         * @type string
         */
        this.id = '';

        /**
         * An instance of the source camera for this camera.  Used only for digital PTZ
         * cameras, which are based off another camera.
         * @type {EVWEB2.Camera}
         */
        this.sourceCamera = this;

        /**
         * Context ID for this camera
         * @private
         * @type String
         */
        this.ctx = '';

        /**
         * Name of this camera
         * @type String
         */
        this.name = 'Undefined';

        /**
         * Server instance this camera is attached to
         * @type EVWEB2.Server
         */
        this.server = null;

        /**
         * Boolean flag for whether PTZ is attached to this camera
         * @type Boolean
         */
        this.ptz = false;

        /**
         * The type of PTZ that is attached to this camera
         * @type {EVWEB2.ptzTypes}
         */
        this.ptzType = EVWEB2.ptzTypes.none;

        /**
         * The digital PTZ types the camera supports
         * @type {Array}
         */
        this.digitalPtzTypes = [];

        /**
         * The current digital PTZ type of this camera
         * @type {EVWEB2.digitalPtzTypes}
         */
        this.digitalPtzType = null;

        /**
         * Boolean flag for whether the camera is disabled
         * @type Boolean
         */
        this.disabled = true;

        /**
         * Boolean flag for whether the camera gets video
         * @type Boolean
         */
        this.video = false;

        /**
         * Object containing all OSD information.
         * Deprecated in favor of new {@link EVWEB2.CameraConfig} API which includes
         * more exhaustive OSD information.
         * @type Object
         * @deprecated
         */
        this.osd = {
            /**
             * String for OSD position
             * @type String
             */
            position: 'none',

            /**
             * Boolean flag for the OSD display for name
             * @type Boolean
             */
            name: false,

            /**
             * Boolean flag for the OSD display for time
             * @type Boolean
             */
            time: false,

            /**
             * Boolean flag for the OSD display for date
             * @type Boolean
             */
            date: false,

            /**
             * Boolean flag for the OSD display for timezone
             * @type Boolean
             */
            timezone: false
        };

        /**
         * The formats available for retrieiving video for the camera.
         * @type {EVWEB2.cameraFormats[]}
         */
        this.formats = [
            EVWEB2.cameraFormats.transcodedJpeg
        ];

        /**
         * The resolution of the camera.
         * @type {EVWEB2.CameraResolution}
         */
        this.resolution = null;

        /**
         * The quality of the camera, ranging from 0-10.  For cameras with no quality setting, this value will be -1.
         * @type {Number}
         */
        this.quality = -1;

        /**
         * The frame rate of the camera.  For cameras with no frame rate setting, this value will be -1.
         * @type {Number}
         */
        this.frameRate = -1;


        /**
         * The configuration settings for the camera.
         * @type {EVWEB2.CameraConfig}
         */
        this.config = new EVWEB2.CameraConfig(this);


        /**
         * Flag used internally by panel to decide if it should try to instantiate a native (H264) decoder.
         * If a decoder was instantiated for this camera previously it can 'mark' the camera so the panel
         * knows to not try again during the current session.
         * @internal
         * @private
         * @type {boolean}
         */
        this.nativeDecodingFailed = false;

        /**
         * Unique ID of the parent camera
         * @type {string}
         */
        this.parentId = typeof id !== 'undefined' ? id : '';

        /**
         * The rotation, in degrees, of the camera.
         * @type {Number}
         */
        this.rotation = 0;

        /**
         * The streaming formats supported for this camera.
         * @type {EVWEB2.streamFormat[]}
         */
        this.streamFormats = streamFormats || [EVWEB2.streamFormat.native, EVWEB2.streamFormat.transcode];

        /**
         * The search only status for this camera. If true, the camera can not
         * be used for live streaming.
         * @type {boolean}
         */
        this.isSearchOnly = false;

        /**
         * Internal value of the PTZ camera's speed.  Defaults to 50.
         * @private
         * @type Number
         */
        var ptzSpeed = 50;

        /**
         * Internal value specifiying whether the formats of the camera support getFrame requests.  This is used
         * to cache the value of {@link EVWEB2.Camera.supportsGetFrame}.
         * @private
         * @internal
         * @type {Boolean}
         */
        var formatsSupportGetFrame;

        /**
         * Internal value specifiying whether the formats of the camera support getVideo requests.  This is used
         * to cache the value of {@link EVWEB2.Camera.supportsGetVideo}.
         * @private
         * @internal
         * @type {Boolean}
         */
        var formatsSupportGetVideo;

        //Assign the constructor values
        if(server !== undefined) {
            this.server = server;
        }
        if(id !== undefined) {
            this.id = id;
        }
        if(ctx !== undefined) {
            this.ctx = ctx;
        }
        if(name !== undefined) {
            this.name = name;
        }
        if(ptz !== undefined) {
            this.ptz = ptz;
        }
        if(ptzType !== undefined) {
            this.ptzType = ptzType;
        }
        if(disabled !== undefined) {
            this.disabled = disabled;
        }
        if(hasVideo !== undefined) {
            this.video = hasVideo;
        }
        if(osd !== undefined) {
            if(osd.position !== undefined) {
                this.osd.position = osd.position;
            }
            if(osd.name !== undefined) {
                this.osd.name = osd.name;
            }
            if(osd.time !== undefined) {
                this.osd.time = osd.time;
            }
            if(osd.date !== undefined) {
                this.osd.date = osd.date;
            }
            if(osd.timezone !== undefined) {
                this.osd.timezone = osd.timezone;
            }
        }
        if(digitalPtzTypes !== undefined) {
            this.digitalPtzTypes = digitalPtzTypes;
        }
        if(formats !== undefined) {
            this.formats = formats;
        }
        if(resolution !== undefined) {
            this.resolution = resolution;
        }
        if(quality !== undefined) {
            this.quality = quality;
        }
        if(frameRate !== undefined) {
            this.frameRate = frameRate;
        }
        if(parentId !== undefined) {
            this.parentId = parentId;
        }
        if(rotation !== undefined) {
            this.rotation = rotation;
        }
        if(isSearchOnly !== undefined) {
            this.isSearchOnly = isSearchOnly;
        }

        // Update the digital PTZ info if transcoding is not available.
        if($.inArray(EVWEB2.cameraFormats.transcodedJpeg, this.formats) === -1) {
            this.digitalPtzType = null;
            this.digitalPtzTypes = [];
        }

        /**
         * Generates a stream ID for a video.web or pull.web request based off of the provided ID.
         * @param {String} streamId The stream ID to process.
         * @return {String} A stream ID
         */
        var generateStreamId = function(streamId) {
            if (typeof streamId === "undefined") {
                if (EVWEB2.config.defaultStreamId === null) {
                    EVWEB2.config.defaultStreamId = EVWEB2.util.generateStreamId();
                }
                streamId = EVWEB2.config.defaultStreamId;
            }
            return streamId;
        };

        /**
         * Determines whether the formats of the camera support getFrame requests.
         * @return {Boolean} Whether the formats of the camera support getFrame requests.
         */
        this.supportsGetFrame = function() {
            if(typeof formatsSupportGetFrame === 'undefined') {

                var supportsJpeg = $.inArray(EVWEB2.cameraFormats.jpeg, this.formats) !== -1;
                var supportsTranscodedJpeg = $.inArray(EVWEB2.cameraFormats.transcodedJpeg, this.formats) !== -1;
                formatsSupportGetFrame = supportsJpeg || supportsTranscodedJpeg;
            }
            return formatsSupportGetFrame;
        };

        /**
         * Determines whether the formats of the camera support getVideo requests.
         * @return {Boolean} Whether the formats of the camera support getVideo requests.
         */
        this.supportsGetVideo = function() {
            if(typeof formatsSupportGetVideo === 'undefined') {
                var streamableFormats = [
                    EVWEB2.cameraFormats.mpeg1,
                    EVWEB2.cameraFormats.mpeg2,
                    EVWEB2.cameraFormats.h263,
                    EVWEB2.cameraFormats.mpeg4,
                    EVWEB2.cameraFormats.h264
                ];
                formatsSupportGetVideo = false;
                var i, len;
                for(i=0, len=streamableFormats.length; i<len; i++) {
                    if($.inArray(streamableFormats[i], this.formats) !== -1) {
                        formatsSupportGetVideo = true;
                        return formatsSupportGetVideo;
                    }
                }
            }
            return formatsSupportGetVideo;
        };

        /**
         * Generates the legacy pull.web request for a frame.
         * @private
         * @param {EVWEB2.Camera} instance The camera instance for the request.
         * @param {Number} width The width of the image in pixels
         * @param {Number} height The height of the image in pixels
         * @param {Number} quality Quality between 1 and 10 with the level of quality of the image (1 lowest, 10
         * highest)
         * @param {String} [searchId] The unique search ID for the feed
         * @param {String} [streamId] The unique stream ID for the feed
         * @return {String} The pull.web URL to request the desired frame from this Camera
         */
        var legacyGetFrame = function(instance, width, height, quality, searchId, streamId) {
            var url = instance.server.service.url() + EVWEB2.urls.legacyGetFrame;
            var params = [
                's=' + instance.server.sessionId,
                'camera=' + instance.id,
                'q=' + quality,
                'w=' + width,
                'h=' + height
            ];

            if (typeof searchId !== 'undefined') {
                params.push('search_id=' + searchId);
            }

            if (typeof streamId === "undefined") {
                if (EVWEB2.config.defaultStreamId === null) {
                    EVWEB2.config.defaultStreamId = EVWEB2.util.generateStreamId();
                }
                streamId = EVWEB2.config.defaultStreamId;
            }
            params.push('stream='+streamId);

            url += '?' + params.join(';') + ';';

            var date = new Date();
            url += date.getTime();
            return url;
        };

        /**
         *	The camera object, once set, has all the information needed to retrieve a frame (an image) from the web
         *	service for it.  Since this image requires a specific URL, each Camera instance contains a method
         *	to generate the URL for retrieving frames.  If the search ID parameter is set, the returned URL will be
         *	pulling from an already initialized search session.  This ID will point to the requested history feed
         *	from the camera.
         *	@param {Number} width The width of the image in pixels
         *	@param {Number} height The height of the image in pixels
         *	@param {Number} quality Quality between 1 and 10 with the level of quality of the image (1 lowest, 10
         *	highest)
         *	@param {String} [searchId] The unique search ID for the feed
         *	@param {String} [streamId] The unique stream ID for the feed
         *
         *	@return {String} The URL to request the desired frame from this Camera
         */
        this.getFrame = function (width, height, quality, searchId, streamId) {
            var testCamera = this;
            if(this.sourceCamera !== this) {
                testCamera = this.sourceCamera;
            }
            if(testCamera.formats.length === 1 && testCamera.formats[0] === EVWEB2.cameraFormats.transcodedJpeg) {
                // If only transcoded JPEG is available, this service doesn't provide video.web.
                return legacyGetFrame(this, width, height, quality, searchId, streamId);
            }
            if(!testCamera.supportsGetFrame()) {
                return '';
            }

            var url = this.server.service.url() + EVWEB2.urls.video;
            var params = [
                's=' + this.server.sessionId,
                'camera=' + this.id,
                'stream=' + generateStreamId(streamId)
            ];
            if (typeof searchId !== 'undefined') {
                params.push('search_id=' + searchId);
            }

            var useNativeJpeg = false;
            var forwardingSettings = this.server.service.jpegForwarding;
            if(forwardingSettings.enabled && $.inArray(EVWEB2.cameraFormats.jpeg, this.formats) !== -1) {
                useNativeJpeg = this.quality * (forwardingSettings.qualityThreshold/100) < quality &&
                                (this.resolution.width * (forwardingSettings.sizeThreshold/100) < width ||
                                this.resolution.height * (forwardingSettings.sizeThreshold/100) < height);
            }

            var format = EVWEB2.cameraFormats.transcodedJpeg;
            if(useNativeJpeg || $.inArray(EVWEB2.cameraFormats.transcodedJpeg, this.formats) === -1) {
                format = EVWEB2.cameraFormats.jpeg;
            }
            if(format !== EVWEB2.cameraFormats.jpeg) {
                params.push('w='+width);
                params.push('h='+height);
                params.push('q='+quality);
            }
            params.push('format='+format);

            url += '?' + params.join(';') + ';';

            var date = new Date();
            url += date.getTime();
            return url;
        };

        /**
         * Generates the legacy pull.web request for a frame download.
         * @param {EVWEB2.Camera} instance The camera instance for the request.
         * @param {String} fileName The requested name for the file download.
         * @param {Number} quality Quality between 1 and 10 with the level of quality of the image (1 lowest, 10
         * highest)
         * @param {String} [searchId] The unique search ID for the feed
         * @param {String} [streamId] The unique stream ID for the feed
         * @return {String} The pull.web URL to request the desired frame from this Camera
         * @private
         */
        var legacyGetDownloadFrame = function(instance, fileName, quality, searchId, streamId) {
            var url = instance.server.service.url() + EVWEB2.urls.legacyGetFrame;
            var params = [
                's=' + instance.server.sessionId,
                'camera=' + instance.id,
                'q=' + quality,
                'download=' + fileName,
                'stream=' + generateStreamId(streamId)
            ];

            if (typeof searchId !== 'undefined') {
                params.push('search_id=' + searchId);
            }

            url += '?' + params.join(';') + ';';

            var date = new Date();
            url += date.getTime();
            return url;
        };

        /**
         * Generates a URL to download the current frame.
         * @param {String} fileName Name of the file to be downloaded
         * @param {Number} [quality] Quality between 1 and 10 with the level of quality of the image (1 lowest,
         * 10 highest)
         * @param {String} [searchId] The unique search ID for the feed
         * @param {String} [streamId] The unique stream ID for the feed
         *
         * @return {String} The URL to request the desired frame from this Camera
         */
        this.getDownloadFrame = function (fileName, quality, searchId, streamId) {
            if(this.formats.length === 1 && this.formats[0] === EVWEB2.cameraFormats.transcodedJpeg) {
                // If only transcoded JPEG is available, this service doesn't provide video.web.
                return legacyGetDownloadFrame(this, fileName, quality, searchId, streamId);
            }
            if(!this.supportsGetFrame()) {
                return '';
            }

            var url = this.server.service.url() + EVWEB2.urls.video;
            var params = [
                's=' + this.server.sessionId,
                'camera=' + this.id,
                'download=' + fileName,
                'stream=' + generateStreamId(streamId)
            ];

            if (typeof searchId !== 'undefined') {
                params.push('search_id=' + searchId);
            }

            var useNativeJpeg = false;
            var forwardingSettings = this.server.service.jpegForwarding;
            if(forwardingSettings.enabled && $.inArray(EVWEB2.cameraFormats.jpeg, this.formats) !== -1) {
                useNativeJpeg = this.quality * (forwardingSettings.qualityThreshold/100) < quality;
            }

            var format = EVWEB2.cameraFormats.transcodedJpeg;
            if(useNativeJpeg) {
                format = EVWEB2.cameraFormats.jpeg;
            }
            else {
                params.push('q='+quality);
            }
            params.push('format='+format);

            url += '?' + params.join(';') + ';';

            var date = new Date();
            url += date.getTime();
            return url;
        };

        /**
         * DEPRECATED: This method is deprecated by {@link EVWEB2.Camera.getVideoStream}.
         *
         * Generates a URL to retrieve a video stream for the camera.  For the formats
         * {@link EVWEB2.cameraFormats.jpeg} and {@link EVWEB2.cameraFormats.transcodedJpeg}, the generated URL will
         * provide the current frame (functionally the same as {@link EVWEB2.Camera.getFrame}).  For all other formats,
         * a stream will be opened.
         * If the requested format is not available, an empty string will be returned.
         * @deprecated
         * @param {EVWEB2.cameraFormat} format The video format to be requested.
         * @param {String} [searchId] The unique search ID for the feed
         * @param {String} [streamId] The unique stream ID for the feed
         * @param {String} [downloadFileName] The file name to set for the HTTP Content-Dispositon: Attachment header.
         * Note: If this value is not set, the content disposition will not be set.
         * @param {Number} [width] The width of the image in pixels. This value is only processed for the format
         * {@link EVWEB2.cameraFormats.transcodedJpeg}
         * @param {Number} [height] The height of the image in pixels. This value is only processed for the format
         * {@link EVWEB2.cameraFormats.transcodedJpeg}
         * @param {Number} [quality] Quality between 1 and 10 with the level of quality of the image (1 lowest, 10
         * highest). This value is only processed for the format {@link EVWEB2.cameraFormats.transcodedJpeg}
         * @param {Boolean} [multipartEncoding=false] Use multi-part encoding in the response stream.  The multi-part
         * encoding will mark a boundary at each frame, providing frame-specific information:
         *     Content-Type: The content-type of the frame data
         *     DataLen: The length of the current frame
         *     Iframe: Whether the frame is an iframe.  Present only if the frame is an iframe.
         *     Frame: (Search only) The frame number in the context of the entire search
         *     TimeOffset: (Search only) The time offset, in ms, in the context of the entire search.
         *
         * @return {String} The URL to request the video frame for this camera.
         */
        this.getVideo = function (format, searchId, streamId, downloadFileName, width, height, quality,
                                  multipartEncoding) {
            if($.inArray(format, this.formats) === -1) {
                return '';
            }
            if(this.formats.length === 1 && this.formats[0] === EVWEB2.cameraFormats.transcodedJpeg) {
                // If only transcoded JPEG is available, this service doesn't provide video.web.
                return '';
            }

            if(typeof multipartEncoding === 'undefined') {
                multipartEncoding = false;
            }

            var url = this.server.service.url() + EVWEB2.urls.video;
            var params = [
                's=' + this.server.sessionId,
                'camera=' + this.id,
                'format=' + format,
                'stream=' + generateStreamId(streamId)
            ];
            if (typeof searchId !== 'undefined') {
                params.push('search_id=' + searchId);
            }
            if(format === EVWEB2.cameraFormats.transcodedJpeg) {
                params.push('w='+width);
                params.push('h='+height);
                params.push('q='+quality);
            }

            if(typeof downloadFileName !== 'undefined') {
                params.push('download='+downloadFileName);
            }

            if(multipartEncoding) {
                params.push('multipart_encode=1');
            }
            url += '?' + params.join(';') + ';';

            var date = new Date();
            url += date.getTime();
            return url;
        };

        /**
         * The getVideoStream function generates a configured stream instance for this camera. Once returned, consumers
         * call {@link EVWEB2.VideoStream#start|EVWEB2.VideoStream.start()} to begin receiving frames.
         * @param {Number} format The video format. One of the camera's supported {@link EVWEB2.cameraFormats}.
         * @param {Number} [streamId=generateStreamId()] A stream id.
         * @param {Number} [width] Transcoded image width. Ignored for native formats.
         * @param {Number} [height] Transcoded image height. Ignored for native formats.
         * @param {Number} [quality] Transcoded image quality on the interval [1,10]. Ignored for native formats.
         * @return {EVWEB2.VideoStream} A stream instance.
         */
        this.getVideoStream = function(format, streamId, width, height, quality) {
            var url = this.server.service.url();
            if (url.indexOf('http://') === 0) {
                url = url.replace('http://', 'ws://');
            } else {
                url = url.replace('https://', 'wss://');
            }

            url += EVWEB2.urls.video;
            var params = [
                's=' + this.server.sessionId,
                'camera=' + this.id,
                'format=' + format,
                'stream=' + generateStreamId(streamId)
            ];
            if (format === EVWEB2.cameraFormats.transcodedJpeg) {
                params.push('w=' + width);
                params.push('h=' + height);
                params.push('q=' + quality);
            }

            url += '?' + params.join('&');
            return new EVWEB2.VideoStream(url, format);
        };

        /**
         * The getSearchSnapshot method allows the caller to retrieve a single, previously-recorded frame from a camera.
         * Note that due to the overhead involved with retrieving a single frame from the server, this method should NOT
         * be used to perform stored video playback. If you wish to conduct playback of recorded video, do so by
         * creating a {@link EVWEB2.getSearch|search}.
         * @param {Date} time The time for which to retrieve a frame.
         * @param {EVWEB2.cameraFormats} format The desired frame format. Note that since this method retrieves a single
         * frame, you MUST request either {@link EVWEB2.cameraFormats.jpeg|native} or
         * {@link EVWEB2.cameraFormats.transcodedJpeg|transcoded JPEG}.
         * @param {Number} [width] Transcoded image width if requesting transcoded JPEG.
         * @param {Number} [height] Transcoded image height if requesting transcoded JPEG.
         * @param {Number} [quality] Transcoded image quality on the interval [1,10] if requesting transcoded JPEG.
         * @return {String} A URL that points to a frame for the camera at the given time.
         */
        this.getSearchSnapshot = function(time, format, width, height, quality) {
            var params = [
                's=' + this.server.sessionId,
                'camera=' + this.id,
                'time=' + EVWEB2.util.Date2IETF(time, true),
                'format=' + format
            ];

            if (format === EVWEB2.cameraFormats.transcodedJpeg &&
                this.server.service.jpegForwarding.enabled &&
                this.server.service.jpegForwarding.shouldForward(this, width, height, quality)) {
                format = EVWEB2.cameraFormats.jpeg;
            }
            if (format === EVWEB2.cameraFormats.transcodedJpeg) {
                if (width) {
                    params.push('w=' + width);
                }
                if (height) {
                    params.push('h=' + height);
                }
                if (quality) {
                    params.push('q=' + quality);
                }
            }
            return this.server.service.url() + EVWEB2.urls.searchSnapshot + '?' + params.join('&');
        };

        /**
         * Retrieves the PTZ presets for this camera
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         *  {@link EVWEB2.PtzPreset} instances.
         */
        this.getPtzPresets = function(callback) {
            if(!this.ptz) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'Camera does not support PTZ.');
                callback(errorResponse);
            }

            var camera = this;
            var onGetPtzPresetsError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onGetPtzPresetsSuccess = function(data/*, textStatus, xhr*/) {
                if(data === EVWEB2.errors.ptz) {
                    //Call the error callback
                    onGetPtzPresetsError();
                }

                // v2.0 web services don't return a proper JSON object, as no callback wraps the response.  For these
                // responses, attempt to manually parse the JSON.
                if(typeof data === 'string') {
                    try {
                        data = JSON.parse(data);
                    }
                    catch(err) {
                        onGetPtzPresetsError();
                        return;
                    }
                }

                //Return the server list
                var successResponse = new EVWEB2.ResponseStatus(true);

                var presets = $.map(data.Presets, function(element) {
                    return new EVWEB2.PtzPreset(element.id, element.name);
                });

                callback(successResponse, camera, presets);
            };

            var settings = {
                success: onGetPtzPresetsSuccess,
                error: onGetPtzPresetsError,
                url: server.service.url() + EVWEB2.urls.ptz,
                data: {
                    s: this.server.sessionId,
                    camera: this.id
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Sets the camera to a PTZ preset
         * @param {String} presetId The ID of the preset.
         */
        this.recallPtzPreset = function(presetId) {
            if(!this.ptz) {
                throw new Error('Camera does not support PTZ.');
            }

            var params = {
                s: this.server.sessionId,
                camera: this.id,
                preset: presetId
            };

            if (this.server.requiresResourceKey()) {
                if (this.server.service.resourceKey === '') {
                    throw new Error("CSRF enforced, passthrough will not work.");
                }
                params.key = this.server.service.resourceKey;
            }

            var service = this.server.service;

            var onVersionCallback = function(response, version) {
                // Version 2.0 did not support POST PTZ requests.  As such, only perform a
                // POST action on newer methods.
                var isGetMethod = version === '2.0.0';

                var settings = {
                    url: service.url() + EVWEB2.urls.ptz,
                    type: isGetMethod ? 'GET' : 'POST',
                    dataType: 'text',
                    data: params
                };

                EVWEB2.ajax(settings, service, true);
            };
            this.server.service.version(onVersionCallback);
        };

        /**
         * Moves the camera in a direction.
         * @param {EVWEB2.ptzDirections} direction The direction to move the camera.
         */
        this.ptzMove = function(direction) {
            if(!this.ptz) {
                throw new Error('Camera does not support PTZ.');
            }

            var params = {
                s: this.server.sessionId,
                camera: this.id,
                dir: direction
            };

            if (this.server.requiresResourceKey()) {
                if (this.server.service.resourceKey === '') {
                    throw new Error("CSRF enforced, passthrough will not work.");
                }
                params.key = this.server.service.resourceKey;
            }

            var service = this.server.service;

            var onVersionCallback = function(response, version) {
                // Version 2.0 did not support POST PTZ requests.  As such, only perform a
                // POST action on newer methods.
                var isGetMethod = version === '2.0.0';

                var settings = {
                    url: service.url() + EVWEB2.urls.ptz,
                    type: isGetMethod ? 'GET' : 'POST',
                    dataType: 'text',
                    data: params
                };

                EVWEB2.ajax(settings, service, true);
            };
            this.server.service.version(onVersionCallback);
        };

        /**
         * Sets the PTZ speed of the camera
         * @param {Number} speed The PTZ speed for the camera (0-100).
         */
        this.setPtzSpeed = function(speed) {
            if(!this.ptz) {
                throw new Error('Camera does not support PTZ.');
            }

            ptzSpeed = speed;

            var params = {
                s: this.server.sessionId,
                camera: this.id,
                zpeed: speed,
                tspeed: speed,
                pspeed: speed
            };

            if (this.server.requiresResourceKey()) {
                if (this.server.service.resourceKey === '') {
                    throw new Error("CSRF enforced, passthrough will not work.");
                }
                params.key = this.server.service.resourceKey;
            }

            var settings = {
                url: this.server.service.url() + EVWEB2.urls.ptz,
                type: 'POST',
                dataType: 'text',
                data: params
            };
            EVWEB2.ajax(settings, this.server.service, true);
        };

        /**
         * Gets the PTZ speed of the camera
         * @return {Number} The PTZ speed
         */
        this.getPtzSpeed = function() {
            if(!this.ptz) {
                throw new Error('Camera does not support PTZ.');
            }

            return ptzSpeed;
        };


        /**
         * Checks to see if digital PTZ of the camera can move in a direction.
         * @param {Function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response, the digital PTZ ID, and a
         *  Boolean indicating whether the move can be made.
         * @param {EVWEB2.ptzDirections} direction The direction to move the camera.
         */
        this.ptzCanMove = function(callback, direction) {
            if(!this.ptz) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'Camera does not support PTZ.');
                callback(errorResponse);
            }

            if(this.ptzType === EVWEB2.ptzTypes.standard) {
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, true);
                return;
            }

            var onDigitalPtzCanMoveError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onDigitalPtzCanMoveSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Call the error callback
                    onDigitalPtzCanMoveError();
                    return;
                }

                //Return the server list
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, data.canMove);
            };

            var settings = {
                success: onDigitalPtzCanMoveSuccess,
                error: onDigitalPtzCanMoveError,
                url: server.service.url() + EVWEB2.urls.digitalPtz,
                data: {
                    s: this.server.sessionId,
                    ptz: this.id,
                    dir: direction
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Clones a camera
         * @internal
         * @return {EVWEB2.Camera} The cloned instance
         */
        this.cloneCamera = function() {
            var ptzTypes = this.digitalPtzTypes.slice(0);
            var formats = this.formats.slice(0);
            var resolution;
            if(this.resolution !== null) {
                resolution = new EVWEB2.CameraResolution(this.resolution.width, this.resolution.height);
            }
            var clonedCamera = new EVWEB2.Camera(this.server, this.id, this.ctx, this.name, this.ptz, this.disabled,
                this.video, this.osd, this.ptzType, ptzTypes, formats, resolution, this.quality);
            clonedCamera.sourceCamera = this.sourceCamera;
            clonedCamera.digitalPtzType = this.digitalPtzType;
            clonedCamera.isSearchOnly = this.isSearchOnly;
            return clonedCamera;
        };

        /**
         * The last used cache break time, used to avoid sending the same cache break parameter twice.  See
         * {@link generateCacheBreakParameter} for more details.
         * @internal
         * @type {Number}
         */
        var lastCacheBreakTime = 0;

        /**
         * The count of the number of times the lastCacheBreakTime has been used.  Used to avoid sending the same cache
         * break parameter twice.  See {@link generateCacheBreakParameter} for more details.
         * @internal
         * @type {Number}
         */
        var lastCacheBreakCount = 0;

        /**
         * Chrome has a tendency to cache requests, even if the cache-control headers are set to no-store, no-cache.
         * This comes into play primarily when creating multiple digital PTZ cameras from the same source camera in a
         * short interval (such as when loading a custom view).  In this situation, only one request is made, such that
         * the multiple digital PTZ cameras all share the same ID.  To get around this, we're appending a timestamp as
         * a cache breaker on create digital PTZ requests.  However, requests can be trigger more than once per ms, so
         * store the previous requests, and if an identical request is present, increment it by one.
         * @internal
         * @return {String} The cache break parameter
         */
        var generateCacheBreakParameter = function() {
            var cacheBreak = (new Date()).getTime();
            if(lastCacheBreakTime === cacheBreak) {
                lastCacheBreakCount++;
            }
            else {
                lastCacheBreakTime = cacheBreak;
                lastCacheBreakCount = 0;
            }
            return lastCacheBreakTime.toString() + lastCacheBreakCount.toString();
        };

        /**
         * Creates a digital PTZ rectangle
         * @param {Function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance, the {@link EVWEB2.Camera} instance, the generated digital PTZ ID,
         *  and a {@link EVWEB2.DigitalPtzRectangle} instance describing the current rectangle.
         * @param {EVWEB2.digitalPtzTypes} digitalPtzType The type of digital PTZ rectangle to create.
         * @param {String} [searchId] The search ID for this camera.
         * @param {EVWEB2.View} [view] A view for this camera to apply any view-specific digital PTZ.  {@link slotIndex}
         *  is required if this parameter is present.
         * @param {Number} [slotIndex] The slot index for the view.  {@link view} is required if this parameter is
         *  present.
         */
        this.createDigitalPtzCamera = function(callback, digitalPtzType, searchId, view, slotIndex) {
            if(this.digitalPtzTypes.length === 0) {
                throw new Error('Camera does not support digital PTZ.');
            }
            if($.inArray(digitalPtzType, this.digitalPtzTypes) === -1) {
                throw new Error('Camera does not support this type of digital PTZ.');
            }

            var sessionId = this.server.sessionId;
            if(searchId !== undefined) {
                sessionId = searchId;
            }

            var camera = this;
            var onCreateDigitalPtzRectangleError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onCreateDigitalPtzRectangleSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Call the error callback
                    onCreateDigitalPtzRectangleError();
                    return;
                }

                //Assign the digital PTZ ID
                var digitalPtzId = data.ptzId;

                var successResponse = new EVWEB2.ResponseStatus(true);

                //Create the digital PTZ camera
                var digitalPtzCam = camera.cloneCamera();
                digitalPtzCam.id = digitalPtzId;
                digitalPtzCam.ptz = true;
                digitalPtzCam.sourceCamera = camera;
                digitalPtzCam.digitalPtzType = digitalPtzType;
                digitalPtzCam.ptzType = EVWEB2.ptzTypes.digital;

                // Digital PTZ is only available as transcoded JPEG
                digitalPtzCam.formats = [EVWEB2.cameraFormats.transcodedJpeg];

                if(searchId !== undefined) {
                    // Create a new server with the session ID set to the source camera
                    // var s = camera.server;
                    // digitalPtzCam.server = new EVWEB2.Server(s.service, s.name, s.id, s.login, s.restricted,
                    //     sessionId, s.gmtOffset, s.osd);
                    digitalPtzCam.server = $.extend({}, camera.server, {sessionId: sessionId});
                }

                digitalPtzCam.setPtzSpeed(50);

                // Create the rectangle instance
                var rectangle = new EVWEB2.DigitalPtzRectangle(data.x, data.y, data.width, data.height);

                callback(successResponse, digitalPtzCam, rectangle);
            };

            var settings = {
                success: onCreateDigitalPtzRectangleSuccess,
                error: onCreateDigitalPtzRectangleError,
                url: server.service.url() + EVWEB2.urls.digitalPtz,
                data: {
                    s: sessionId,
                    camera: this.id,
                    type: digitalPtzType,
                    cacheBreak: generateCacheBreakParameter()
                }
            };

            if(view !== undefined && slotIndex !== undefined) {
                if(view.id)
                    settings.data.viewid = view.id;
                else
                    settings.data.view = view.name;
                settings.data.slot = slotIndex;
            }

            EVWEB2.ajax(settings, server.service);
        };


        /**
         * Retrieves the current digital PTZ rectangle
         * @param {Function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response, the the {@link EVWEB2.Camera}
         *  instance, the digital PTZ ID, and a {@link EVWEB2.DigitalPtzRectangle} instance describing the current
         *  rectangle.
         */
        this.getDigitalPtzRectangle = function(callback) {
            if(this.digitalPtzTypes.length === 0) {
                throw new Error('Camera does not support digital PTZ.');
            }
            if(this.sourceCamera === this) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'This camera is not a digital PTZ camera.');
                callback(errorResponse);
                return;
            }

            var camera = this;
            var onGetDigitalPtzRectangleError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onGetDigitalPtzRectangleSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Call the error callback
                    onGetDigitalPtzRectangleError();
                    return;
                }

                //Return the server list
                var successResponse = new EVWEB2.ResponseStatus(true);

                var rectangle = new EVWEB2.DigitalPtzRectangle(data.x, data.y, data.width, data.height);

                callback(successResponse, camera, rectangle);
            };

            var settings = {
                success: onGetDigitalPtzRectangleSuccess,
                error: onGetDigitalPtzRectangleError,
                url: server.service.url() + EVWEB2.urls.digitalPtz,
                data: {
                    s: this.server.sessionId,
                    ptz: this.id
                }
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * Sets the current digital PTZ rectangle.
         * Due to XSS restrictions, the POST request can not deliver a response.  As such, this will internally call
         * getPtzRectangle() before returning the response in these situations which will increase latency.  If this
         * behavior is not desired, leave callback undefined and the call will not be made.
         * @param {Function} [callback] Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance with the details of the response, the {@link EVWEB2.Camera}
         * instance, the digital PTZ ID, and a {@link EVWEB2.DigitalPtzRectangle} instance describing the resultant
         * rectangle.
         * @param {Number} x Number x-coordinate of the rectangle
         * @param {Number} y Number y-coordinate of the rectangle
         * @param {Number} width Number width of the rectangle
         * @param {Number} height Number height of the rectangle
         */
        this.setDigitalPtzRectangle = function(callback, x, y, width, height) {
            if(this.digitalPtzTypes.length === 0) {
                throw new Error('Camera does not support digital PTZ.');
            }
            if(this.sourceCamera === this) {
                if(typeof callback === 'function') {
                    var errorResponse = new EVWEB2.ResponseStatus(false, 'This camera is not a digital PTZ camera.');
                    callback(errorResponse);
                }
                return;
            }

            var camera = this;
            var onSetDigitalPtzRectangleError = function(/*xhr, textStatus, errorThrown*/) {
                if(typeof callback === 'function') {
                    var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                    callback(errorResponse);
                }
            };

            var onSetDigitalPtzRectangleSuccess = function(data/*, textStatus, xhr*/) {
                if(typeof callback !== 'function') {
                    return;
                }

                if(!data.success) {
                    //Call the error callback
                    onSetDigitalPtzRectangleError();
                    return;
                }

                if(data.xssPost) {
                    if(typeof callback !== 'undefined') {
                        camera.getDigitalPtzRectangle(callback);
                    }
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                var rectangle = new EVWEB2.DigitalPtzRectangle(data.x, data.y, data.width, data.height);

                callback(successResponse, camera, rectangle);
            };

            var params = {
                s: this.server.sessionId,
                ptz: this.id,
                x: x,
                y: y,
                w: width,
                h: height
            };

            if (this.server.requiresResourceKey()) {
                if (this.server.service.resourceKey === '') {
                    throw new Error("CSRF enforced, passthrough will not work.");
                }
                params.key = this.server.service.resourceKey;
            }

            var settings = {
                url: this.server.service.url() + EVWEB2.urls.digitalPtz,
                success: onSetDigitalPtzRectangleSuccess,
                error: onSetDigitalPtzRectangleError,
                type: 'POST',
                data: params
            };
            EVWEB2.ajax(settings, this.server.service, true);
        };

        /**
         * Deletes the current digital PTZ camera.
         * @param {Function} [callback] Callback function to be executed when the call completes. Callback is
         * passed a {@link EVWEB2.ResponseStatus} instance with the details of the response and the original
         * {@link EVWEB2.Camera} instance the digital PTZ camera was generated from.
         *
         */
        this.deleteDigitalPtzCamera = function(callback) {
            if(this.digitalPtzTypes.length === 0) {
                throw new Error('Camera does not support digital PTZ.');
            }

            if(this.sourceCamera === this) {
                if(typeof callback === 'function') {
                    var errorResponse = new EVWEB2.ResponseStatus(false,'This camera is not a digital PTZ camera.');
                    callback(errorResponse);
                }
                return;
            }

            var instance = this;

            var params = {
                s: this.server.sessionId,
                ptz: this.id,
                action: 'delete'
            };

            if (this.server.requiresResourceKey()) {
                if (this.server.service.resourceKey === '') {
                    throw new Error("CSRF enforced, passthrough will not work.");
                }
                params.key = this.server.service.resourceKey;
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                if(typeof callback === 'function') {
                    var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                    callback(errorResponse);
                }
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(typeof callback === 'function') {
                    if(!data.success) {
                        var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                        callback(errorResponse);
                        return;
                    }

                    var successResponse = new EVWEB2.ResponseStatus(true);
                    callback(successResponse, instance.sourceCamera);
                }
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: this.server.service.url() + EVWEB2.urls.digitalPtz,
                type: 'POST',
                data: params
            };
            EVWEB2.ajax(settings, this.server.service, true);
        };

        /**
         * Initializes thumbnail search and retrieves the total frame count and frame timestamps for a given
         * search duration and specified interval.
         *
         * @param {Function} callback Callback function to be executed when the call
         * completes. Callback is passed a {@link EVWEB2.ResponseStatus} instance with
         * the details of the response and an {@link EVWEB2.ThumbnailSearch} instance.
         * @param {Date} start The start time of the thumbnail search.
         * @param {Date} end The end time of the thumbnail search.
         * @param {Number} interval The interval in seconds between frames for searching.
         */
        this.getThumbnailSearch = function (callback, start, end, interval) {
            var camera = this;

            var onGetThumbnailSearchError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onGetThumbnailSearchSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false,data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                if(data.frames === "0") {
                    callback(successResponse, null);
                    return;
                }

                var framesInfoList = $.map(data.frames_timestamps, function(element, i) {
                    return new EVWEB2.ThumbnailSearchInfo(data.session_id, camera, element, i);
                });


                var thumbnailSearch = new EVWEB2.ThumbnailSearch(data.session_id, camera, data.start, data.end,
                                                    framesInfoList);
                callback(successResponse, thumbnailSearch);
            };

            var server = camera.server;
            var url = server.service.url() + EVWEB2.urls.thumbnail;

            var params = [
                's=' + server.sessionId,
                'camera=' + camera.id,
                'start=' + EVWEB2.util.Date2IETF(start),
                'end=' + EVWEB2.util.Date2IETF(end),
                'interval=' + interval
            ];

            url += '?' + params.join(';');

            var settings = {
                success: onGetThumbnailSearchSuccess,
                error: onGetThumbnailSearchError,
                url: url,
                data: {
                    output: 'json'
                }
            };

            EVWEB2.ajax(settings, server.service);
        };


        /**
         * This function sets a new name for the camera on the server.
         * @param {Function} callback Callback function to be executed when the call completes. The function gets
         * passed a {@link EVWEB2.ResponseStatus} instance with the details of the response and the updated camera
         * {EVWEB2.Camera} instance as a convenience.
         * @param {String} name The name
         */
        this.setName = function(callback, name){
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            if(typeof name === 'undefined'){
                var errorResponse = new EVWEB2.ResponseStatus(false, 'New name required');
                callback(errorResponse);
                return;
            }

            var instance = this;

            var onSetCameraNameError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSetCameraNameSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                if(!data.xssPost) {
                    // update the camera instance
                    instance.name = name;
                }
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, instance);
            };

            var params = {
                s: this.server.sessionId,
                camera: this.id,
                name: name
            };

            var settings = {
                success: onSetCameraNameSuccess,
                error: onSetCameraNameError,
                url: this.server.service.url() + EVWEB2.urls.camera,
                data: params,
                type: 'POST'
            };
            EVWEB2.ajax(settings, this.server.service, true);
        };

        /**
         * Generates a URL for retrieving a thumbnail image of the camera's feed. This thumbnail
         * does not represent a live snapshot, but merely a representative value of the camera's feed.
         *
         * @param {EVWEB2.cameraThumbnailSizes} [size=EVWEB2.cameraThumbnailSizes.size80x80] The size
         * of the thumbnail to request.
         * @return {String} The URL to request the desired thumbnail image frame for this camera
         */
        this.getThumbnailUrl = function(size) {
            if (size === undefined){
                size = EVWEB2.cameraThumbnailSizes.size80x80;
            }

            var camera = this;
            var baseUrl = camera.server.service.url() + EVWEB2.urls.cachedThumbnail;
            var data = {
                s: camera.server.sessionId,
                camera: camera.id,
                size: size
            };

            var key, query_string = '';
            for (key in data) {
                if (data.hasOwnProperty(key)){
                    query_string += (query_string === ''? '' : '&') + key + '=' + data[key];
                }
            }

            return baseUrl + '?' + query_string;
        };


        /**
         * Retrieves the association info for this camera
         * @param {Function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an {@link EVWEB2.Association}
         *  object detailing all of the assocation items associated with the camera or null, if no association is
         *  present.
         */
        this.getAssociations = function(callback) {
            var camera = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                if(data.association === null) {
                    // Call back immediately as there is no association to return.
                    callback(successResponse, null);
                    return;
                }
                var raw = data.association;

                // Process the associations
                var associationItems = $.map(raw.items, function(element) {
                    return new EVWEB2.AssociationItem(element.id, element.type, element.position, element.statusOnly,
                        element.extra);
                });

                var fontInfo = new EVWEB2.FontInfo(raw.fontName, raw.fontSize, raw.fontStyle,
                    raw.fontColor, raw.fontFamily, raw.fontWeight);

                var association = new EVWEB2.Association(camera.server, camera, raw.guid, associationItems,
                    raw.label, raw.overlayStyle, raw.position, raw.backgroundColor,
                    raw.opacity, fontInfo);

                callback(successResponse, association);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: camera.server.service.url() + EVWEB2.urls.associationsCamera,
                data: {
                    s: camera.server.sessionId,
                    camera: camera.parentId
                }
            };

            EVWEB2.ajax(settings, this.server.service);
        };
    };

    /**
     *	The getCameras function is meant to act as a handler and parser for list retrieval from the exacqVision
     *	web service back-end.  It uses asynchronous javascript requests to the server for information on
     *	the available camera feeds available from the requested server.  The information received from this call
     *	is then parsed and properly formatted into {@link EVWEB2.Camera} objects that then provide the proper
     *	methods for viewing the camera feeds.
     *  @param {Function} callback Callback function to be executed when the call completes. The function gets passed
     *  three arguments: {@link EVWEB2.ResponseStatus} instance with the details of the response, an array of
     *  {@link EVWEB2.Camera} instances, and a modified instance of {@link EVWEB2.Server}. (Note: The instance passed
     *  into the call is modified as well.)
     *	@param {EVWEB2.Server} server Server object to retrieve cameras from
     *  @deprecated This method is superceded by {@link EVWEB2.Server.getCameras}.
     *  @category Camera
     */
    EVWEB2.getCameras = function (callback, server) {
        server.getCameras(callback);
    };
}());

/*globals EVWEB2:true*/
(function() {

    /**
     * @class
     * The SystemHardwareInfo object represents the basic hardware information of the system.
     * @param {String} [serialNumber=''] The serial number of the system.
     * @param {String} [modelNumber=''] The model number of the system.
     * @param {String} [motherboard=''] The system motherboard information.
     * @param {String} [bios=''] The system BIOS information.
     * @param {String} [processor=''] The processor information.
     * @param {String} [totalMemory=''] The total memory of the system in bytes.
     * @param {String} [os=''] The system OS information.
     * @param {Date} [runningSince=null] The timestamp since the system has been running.
     * @constructor
     * @category Server
     */
    EVWEB2.SystemHardwareInfo = function(serialNumber, modelNumber, motherboard, bios, processor, totalMemory,
                                                os, runningSince) {
        /**
         * The serial number of the system.
         * @type String
         */
        this.serialNumber = '';

        /**
         * The model number of the system.
         * @type String
         */
        this.modelNumber = '';

        /**
         * The system motherboard information.
         * @type String
         */
        this.motherboard = '';

        /**
         * The system BIOS information.
         * @type String
         */
        this.bios = '';

        /**
         * The processor information.
         * @type String
         */
        this.processor = '';

        /**
         * The total memory of the system in bytes.
         * @type String
         */
        this.totalMemory = '';

        /**
         * The system OS information.
         * @type String
         */
        this.os = '';

        /**
         * The timestamp since the system has been running.
         * @type Date
         */
        this.runningSince = null;

        //Assign the constructor values
        if(typeof serialNumber !== 'undefined') {
            this.serialNumber = serialNumber;
        }
        if(typeof modelNumber !== 'undefined') {
            this.modelNumber = modelNumber;
        }
        if(typeof motherboard !== 'undefined') {
            this.motherboard = motherboard;
        }
        if(typeof bios !== 'undefined') {
            this.bios = bios;
        }
        if(typeof processor !== 'undefined') {
            this.processor = processor;
        }
        if(typeof totalMemory !== 'undefined') {
            this.totalMemory = totalMemory;
        }
        if(typeof os !== 'undefined') {
            this.os = os;
        }
        if(typeof runningSince !== 'undefined') {
            this.runningSince = runningSince;
        }
    };

    /**
     * The SystemConfig object acts as a container for system configuration information.
     * @param {EVWEB2.Server} [server=null] The associated server.
     * @param {String} [systemName=''] The name of the system.
     * @param {EVWEB2.SystemHardwareInfo} [hardwareInfo=null] The hardware information of the system.
     * @param {Boolean} [isUtf8=false] Whether the system has utf-8 support enabled or not.
     * @constructor
     * @class
     * @category Server
     */
    EVWEB2.SystemConfig = function(server, systemName, hardwareInfo, isUtf8) {
        /**
         * The associated server.
         * @type EVWEB2.Server
         */
        this.server = null;

        /**
         * The system name.
         * @type String
         */
        this.systemName = '';

        /**
         * The system hardware information.
         * @type EVWEB2.SystemHardwareInfo
         */
        this.hardwareInfo = null;

        /**
         * Whether the system has utf-8 support enabled or not.
         * @type Boolean
         */
        this.isUtf8 = false;

        // Assign the constructor values
        if(typeof server !== 'undefined') {
            this.server = server;
        }
        if(typeof systemName !== 'undefined') {
            this.systemName = systemName;
        }
        if(typeof hardwareInfo !== 'undefined') {
            this.hardwareInfo = hardwareInfo;
        }
        if(typeof isUtf8 !== 'undefined') {
            this.isUtf8 = isUtf8;
        }

        /**
         * Set the new system name.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance with the details of the response and the new system name.
         * @param {String} systemName The new system name to set.
         */
        this.setSystemName = function(callback, systemName) {
            var server = this.server;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                server.name = systemName;

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, systemName);
            };

            var params = {
                s: server.sessionId,
                systemName: systemName
            };

            var settings = {
                url: server.service.url() + EVWEB2.urls.systemInfo,
                success: onSuccess,
                error: onError,
                type: 'POST',
                data: params
            };
            EVWEB2.ajax(settings, server.service, true);
        };

        /**
         * This method allows to enable UTF-8 support on the system. Note: Once UTF-8 support is enabled on a system,
         * it cannot be reversed.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance with the details of the response.
         */
        this.enableSystemUtf8 = function(callback) {
            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };
            if(this.isUtf8) {
                // UTF-8 is already enabled
                var errorResponse = new EVWEB2.ResponseStatus(false, 'UTF-8 is already enabled on this system.');
                callback(errorResponse);
                return;
            }

            var params = {
                s: this.server.sessionId,
                utf8Enabled: true
            };

            var settings = {
                url: this.server.service.url() + EVWEB2.urls.systemInfo,
                success: onSuccess,
                error: onError,
                type: 'POST',
                data: params
            };

            EVWEB2.ajax(settings, this.server.service, true);
        };
    };

}());
/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * Definitions for capabilities for VideoPush clients.
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.VideoPushCapabilities = {
        /**
         * Live Video
         */
        liveVideo : 0,
        /**
         * Live Audio
         */
        liveAudio: 1,
        /**
         * Live Serial
         */
        liveSerial: 2,
        /**
         * Live Digital PTZ
         */
        liveDigitalPtz: 3,
        /**
         * Live Tours
         */
        liveTours: 4,
        /**
         * Live Custom Layouts
         */
        liveCustomLayouts: 5,
        /**
         * Live Full Screen
         */
        liveFullScreen: 6,
        /**
         * Live Maps
         */
        liveMaps: 7
    };

    /**
     * Definitions for the types of VideoPush applications
     * @enum {Number}
     * @readonly
     * @category Server
     */
    EVWEB2.VideoPushApplications = {
        /**
         * Web
         */
        web: 0,
        /**
         * Mobile
         */
        mobile: 1
    };

    /**
     * Definitions for the types of VideoPush display settings
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.VideoPushDisplaySettings = {
        /**
         * Full screen
         */
        fullScreen: 0,
        /**
         * Hide toolbar
         */
        hideToolbar: 1,
        /**
         * Hide navigation bar
         */
        hideNavbar: 2
    };

    /**
     * Definitions for the types of VideoPush messages
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.VideoPushMessageTypes = {
        /**
         * Invalid
         */
        invalid: -1,
        /**
         * Display Settings
         */
        displaySettings: 0,
        /**
         * Live Views
         */
        liveViews: 1,
        /**
         * Live Tours
         */
        liveTours: 2
    };

    /**
     * Definitions for the statuses for VideoPush messages.
     * @enum {string}
     * @readonly
     * @category Server
     */
    EVWEB2.VideoPushStatuses = {
        /**
         * Not sent
         */
        notSent: '',
        /**
         * Pending
         */
        pending: 'Pending',
        /**
         * Sent
         */
        sent: 'Sent'
    };

    /**
     * The VideoPushTarget object acts as a container for all information about a VideoPush target.
     * @param {String} [id=''] The ID of this VideoPush target.
     * @param {String} [name=''] The display name of this VideoPush target.
     * @param {EVWEB2.Server[]} [servers=[]] The server instances associated with this target.
     * @param {EVWEB2.VideoPushCapabilities[]} [capabilities=[]] The capabilities associated with this target.  The
     * target will only respond to VideoPush messages falling into these capabilities.
     * @param {Number} [maxPanels=0] The maximum number of video panels this target supports.
     * @class
     * @constructor
     * @category Server
     */
    EVWEB2.VideoPushTarget = function(id, name, servers, capabilities, maxPanels) {

        /**
         * The ID of this VideoPush target.
         * @type {string}
         */
        this.id = '';

        /**
         * The display name of this VideoPush target.
         * @type {string}
         */
        this.name = '';

        /**
         * The server instances associated with this target.
         * @type {EVWEB2.Server[]}
         */
        this.servers = [];

        /**
         * The capabilities associated with this target.  The target will only respond to VideoPush messages falling
         * into these capabilities.
         * @type {EVWEB2.VideoPushCapabilities[]}
         */
        this.capabilities = [];

        /**
         * The maximum number of video panels this target supports.
         * @type {Number}
         */
        this.maxPanels = 0;

        if(typeof id !== 'undefined') {
            this.id = id;
        }
        if(typeof name !== 'undefined') {
            this.name = name;
        }
        if(typeof servers !== 'undefined') {
            this.servers = servers;
        }
        if(typeof capabilities !== 'undefined') {
            this.capabilities = capabilities;
        }
        if(typeof maxPanels !== 'undefined') {
            this.maxPanels = maxPanels;
        }
    };

    /**
     * The VideoPushMessageStatus object acts as a container for status information about a
     * {@link EVWEB2.VideoPushMessage} instance.
     * @param {EVWEB2.VideoPushStatuses} [status=EVWEB2.VideoPushStatuses.notSent] The current status of the message.
     * @param {EVWEB2.Server[]} [appliedServers=[]] The servers that the message has been applied to.
     * @class
     * @constructor
     * @category Server
     */
    EVWEB2.VideoPushMessageStatus = function(status, appliedServers) {

        /**
         * The ID of this VideoPush target.
         * @type {EVWEB2.VideoPushStatuses}
         */
        this.status = EVWEB2.VideoPushStatuses.notSent;

        /**
         * The servers that this message has been applied to.
         * @type {EVWEB2.Server[]}
         */
        this.appliedServers = [];

        if(typeof status !== 'undefined') {
            this.status = status;
        }
        if(typeof appliedServers !== 'undefined') {
            this.appliedServers = appliedServers;
        }
    };


    /**
     * The VideoPushMessage object acts as a container for all information about a VideoPush message.  This
     * object exposes the the ability to poll for the status of the sent message to this target.
     * @param {EVWEB2.VideoPushTarget} [target=null] The VideoPush target instance.
     * @param {String} [sender=''] The name of the client that sent the message.
     * @param {EVWEB2.VideoPushDisplaySettings[]|EVWEB2.View|EVWEB2.Tour} [content=''] The content of the message.  This can
     * be any one of the three specified types.
     * @param {EVWEB2.TourFolder[]} [tourContentFolders] The tour folders associated with the specified
     * {@link EVWEB2.Tour}. Note: This parameter is only necessary when sending a tour.
     * @class
     * @constructor
     * @category Server
     */
    EVWEB2.VideoPushMessage = function(target, sender, content, tourContentFolders) {

        /**
         * The type of VideoPush message.
         * @type {EVWEB2.VideoPushMessageTypes}
         */
        this.type = EVWEB2.VideoPushMessageTypes.invalid;

        /**
         * The VideoPush target instance.
         * @type {EVWEB2.VideoPushTarget}
         */
        this.target = null;

        /**
         * The name of the client that sent the message.
         * @type {String}
         */
        this.sender = '';

        /**
         * The content of the message.  This can be any one of the three specified types.
         * @type {EVWEB2.VideoPushDisplaySettings[]|EVWEB2.View|EVWEB2.Tour}
         */
        this.content = '';

        /**
         * The message ID associated with this message.  This value is generated and applied by
         * {@link EVWEB2.VideoPush.sendMessage()} and is used to check the status of a message in
         * {@link EVWEB2.VideoPushMessage.getStatus}.
         * @type {String}
         */
        this.messageId = '';


        /**
         * The servers associated with this message.  This value is generated and applied by
         * {@link EVWEB2.VideoPush.sendMessage()} and is used to check the status of a message in
         * {@link EVWEB2.VideoPushMessage.getStatus}.
         * @type {EVWEB2.Server[]}
         */
        this.servers = [];

        /**
         * The list of {EVWEB2.TourFolder} instances associated with the tour content specified for this message.
         * @type {EVWEB2.TourFolder[]}
         */
        this.tourFolders = [];

        if(typeof target !== 'undefined') {
            this.target = target;
        }
        if(typeof sender !== 'undefined') {
            this.sender = sender;
        }
        if(typeof content !== 'undefined') {
            this.content = content;
            if(content instanceof EVWEB2.View) {
                this.type = EVWEB2.VideoPushMessageTypes.liveViews;
            }
            else if(content instanceof EVWEB2.Tour) {
                this.type = EVWEB2.VideoPushMessageTypes.liveTours;
            }
            else if(content instanceof Array) {
                this.type = EVWEB2.VideoPushMessageTypes.displaySettings;
            }
        }
        if(typeof tourContentFolders !== 'undefined') {
            this.tourFolders = tourContentFolders;
        }

        /**
         * Determinmes the {@link EVWEB2.ViewSlotItemTypes} for a given {@link EVWEB2.ViewSlotItem} instance.
         * @param {EVWEB2.ViewSlotItem} viewSlotItem The view slot item to process
         * @returns {EVWEB2.ViewSlotItemTypes} The view slot item type.
         * @internal
         * @private
         */
        var getViewSlotItemType = function(viewSlotItem) {
            var type = EVWEB2.ViewSlotItemTypes.none;
            if(viewSlotItem.type === EVWEB2.Camera) {
                type = EVWEB2.ViewSlotItemTypes.camera;
            }
            else if(viewSlotItem.type === EVWEB2.Map) {
                type = EVWEB2.ViewSlotItemTypes.group;
            }
            else if(viewSlotItem.type === EVWEB2.AudioDevice) {
                type = EVWEB2.ViewSlotItemTypes.audio;
            }
            return type;
        };

        /**
         * Gets the tour folder instance from tourFolders matching the provided ID.
         * @param {String} id The tour folder ID to find.
         * @param {EVWEB2.TourFolder[]} tourFolders The list of tour folders to search.
         * @returns {EVWEB2.TourFolder} The tour folder with the specified ID.
         * @internal
         * @private
         */
        var getTourFolderById = function(id, tourFolders) {
            return $.grep(tourFolders, function(element) {
                return element.id === id;
            })[0];
        };

        /**
         * Generates the JSON-encoded string of the message content for use in sending the message.
         * @internal
         * @returns {String} The JSON-encoded string of the message content for the server.
         */
        this.generateContent = function() {
            var submissionContent = '';

            var instance = this;
            if(this.type === EVWEB2.VideoPushMessageTypes.displaySettings) {
                submissionContent = instance.content;
            }
            else if(this.type === EVWEB2.VideoPushMessageTypes.liveViews) {
                submissionContent = {
                    layout: instance.content.layout,
                    items: $.map(instance.content.items, function(element) {
                        return {
                            slot: element.slotIndex,
                            id: element.id,
                            server: element.server,
                            type: getViewSlotItemType(element)
                        };
                    })
                };
            }
            else if(this.type === EVWEB2.VideoPushMessageTypes.liveTours) {
                var folders = [];

                var tourFolder;


                if(this.content.folder !== null) {
                    tourFolder = getTourFolderById(instance.content.folder.id, instance.tourFolders);
                }

                if(tourFolder !== undefined) {
                    folders.push(tourFolder.name);
                }
                while(tourFolder !== undefined && tourFolder.id !== tourFolder.parentId) {
                    tourFolder = getTourFolderById(tourFolder.parentId, instance.tourFolders);
                    folders.unshift(tourFolder.name);
                }

                submissionContent = {
                    name: instance.content.name,
                    folders: folders
                };
            }
            return JSON.stringify(submissionContent);
        };

        /**
         * Queries the status of the message.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed
         * a {@link EVWEB2.ResponseStatus} instance with the details of the response and a
         * {@link EVWEB2.VideoPushMessageStatus} instance describing the status of the message.
         */
        this.getStatus = function(callback) {
            var message = this;
            var onGetStatusError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetStatusSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }


                var appliedServers = $.map(data.applied, function(element) {
                    return $.grep(message.target.servers, function(el) {
                        return el.id.toString() === element.toString();
                    })[0];
                });

                var status = new EVWEB2.VideoPushMessageStatus(data.status, appliedServers);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, status);
            };

            var service = this.target.servers[0].service;
            var serverIds = $.map(this.target.servers, function(element) {
                return element.sessionId;
            });
            var settings = {
                success: onGetStatusSuccess,
                error: onGetStatusError,
                url: service.url() + EVWEB2.urls.videopushMessage + '/' + this.messageId,
                traditional: true,
                data: {
                    s: serverIds
                }
            };

            EVWEB2.ajax(settings, service);
        };
    };


    /**
     * The VideoPush object acts as a container for all video push actions
     * performed on the server.  It exposes methods for both sending and receiving
     * VideoPush events.
     * @param {String} [clientGuid=''] The GUID of this VideoPush target.  When initially creating a VideoPush
     * client, this value will be generated and should be stored and re-used for the lifetime of the
     * client.  For example, a web client user should generate this GUID once, store it in Local Storage and,
     * on each reload, should provide this value to the constructor.
     * @param {String} [clientId=''] The ID of this VideoPush target.  When initially creating a VideoPush
     * client, this value will be generated and should be stored and re-used for the lifetime of the
     * client.  For example, a web client user should generate this ID once, store it in Local Storage and,
     * on each reload, should provide this value to the constructor.
     * @class
     * @category Server
     */
    EVWEB2.VideoPush = function(clientGuid, clientId) {

        /**
         * The GUID of this VideoPush target.  This value is initially created by a call to
         * {@link EVWEB2.VideoPush.updateClient}.  All uses afterward should have this value
         * applied as part of the constructor.
         * @private
         * @internal
         * @type {string}
         */
        var guid = '';

        if(typeof clientGuid !== 'undefined') {
            guid = clientGuid;
        }

        /**
         * The ID of this VideoPush target.  This value is initially created by a call to
         * {@link EVWEB2.VideoPush.updateClient}.  All uses afterward should have this value
         * applied as part of the constructor.
         * @private
         * @internal
         * @type {string}
         */
        var id = '';

        if(typeof clientId !== 'undefined') {
            id = clientId;
        }

        /**
         * The display name of the VideoPush client to be shown to other VideoPush clients.  When no capabilities are
         * present, this value is not used and can be an empty string.  This value is set by
         * {@link EVWEB2.VideoPush.updateClient}.
         * @type {String}
         * @private
         * @internal
         */
        var clientName = '';

        /**
         * The server instances associated with this client. This value is set by {@link EVWEB2.VideoPush.updateClient}.
         * @type {EVWEB2.Server[]}
         * @private
         * @internal
         */
        var clientServers = [];


        /**
         * The capabilities of the VideoPush client.  This value is set by {@link EVWEB2.VideoPush.updateClient}.
         * @type {EVWEB2.VideoPushCapabilities[]}
         * @private
         * @internal
         */
        var clientCapabilities = [];

        /**
         * The maximum number of video panels available to this client.  This value is set by
         * {@link EVWEB2.VideoPush.updateClient}.
         * @type {Number}
         * @private
         * @internal
         */
        var clientMaxPanels = 0;

        /**
         * The type of VideoPush application this client is.  This value is set by
         * {@link EVWEB2.VideoPush.updateClient}.
         * @type {EVWEB2.VideoPushApplications}
         * @private
         * @internal
         */
        var clientApplicationType = EVWEB2.VideoPushApplications.web;


        /**
         * Retrieves a list of all of the available VideoPush targets on the provided servers.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         * {@link EVWEB2.VideoPushTarget} instances.
         * @param {EVWEB2.Server[]} servers An array of {@link EVWEB2.Server} instances to query the video push targets.
         * from which to get targets.
         */
        this.getTargets = function(callback, servers) {
            var onGetTargetsError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetTargetsSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var targets = $.map(data.targets, function(targetData) {
                    if(id !== '' && targetData.id === id) {
                        return;
                    }
                    var sessionIds = $.map(targetData.sessionIds, function(element) {
                        return element.toString();
                    });

                    var targetServers = $.grep(servers, function(el) {
                        return $.inArray(el.id, sessionIds) !== -1;
                    });
                    return new EVWEB2.VideoPushTarget(targetData.id, targetData.name, targetServers,
                        targetData.capabilities, targetData.maxPanels);
                });
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, targets);
            };

            var service = servers[0].service;
            var serverIds = $.map(servers, function(element) {
                return element.sessionId;
            });
            var settings = {
                success: onGetTargetsSuccess,
                error: onGetTargetsError,
                url: service.url() + EVWEB2.urls.videopush,
                traditional: true,
                data: {
                    s: serverIds
                }
            };

            EVWEB2.ajax(settings, service);
        };


        /**
         * Update a client's VideoPush status, including the initial creation of a VideoPush target.  This
         * method is used to register a client with the server as being a sender and/or receiver of VideoPush
         * events.
         *
         * At the base level, a sender of VideoPush events is a client with no capabilities.  To receive events,
         * capabilities must be defined, each listing the types of content the client can receive.
         *
         * When initially creating a VideoPush target, a client GUID will be generated and returned in the callback.
         * This GUID should be stored externally and used in the constructor for all future instances of this client,
         * preserving the unique client connection. In addition, an external ID will be created and returned, and 
         * should be handled in the same way as the GUID.
         *
         * Note: When registering a client for receiving (i.e. setting any capabilities), it is important to unregister
         * those capabilities when finished listening.  This is done automatically after a set timeout period, but it is
         * highly recommended that a call to updateClient is made when finished listening to remove all capabilities.
         *
         * Note: Due to how the EV Server manages VideoPush connections, the same GUID cannot be used with multiple
         * separate logins on the same server.  In this situation, it is recommended that the original GUID is updated to
         * no capabilities and a new GUID is generated for the new login.  For example: A user has a client GUID is
         * generated for a user using the passthrough connection on the server. Later, that user receives personal
         * credentials to that same server and logs in.  In this situation, the original GUID must be set to no
         * capabilities and a new GUID must be generated.
         *
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and a string of the client's GUID.
         * @param {EVWEB2.Server[]} servers The server instances associated with this client.  In general, this value
         * should be all of the connected servers.
         * @param {String} name The display name of the VideoPush client to be shown to other VideoPush clients.  When
         * no capabilities are present, this value is not used and can be an empty string.
         * @param {EVWEB2.VideoPushCapabilities[]} capabilities The capabilities this VideoPush client supports.  When
         * no capabilities are present, this client is considered "send only" and will not be displayed to receive
         * any events.
         * @param {Number} maxPanels The maximum number of video panels available to this client.
         * @param {EVWEB2.VideoPushApplications} [applicationType=EVWEB2.VideoPushApplications.web] The type of
         * VideoPush application this client is.
         */
        this.updateClient = function(callback, servers, name, capabilities, maxPanels, applicationType) {
            if(typeof applicationType === 'undefined') {
                applicationType = EVWEB2.VideoPushApplications.web;
            }

            var onUpdateClientError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onUpdateClientSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                // Update the internal information
                guid = data.target.guid;
                id = data.target.id;
                clientServers = servers;
                clientName = name;
                clientCapabilities = capabilities;
                clientMaxPanels = maxPanels;
                clientApplicationType = applicationType;

                var successResponse = new EVWEB2.ResponseStatus(true);
                //Return the server list
                callback(successResponse, guid);
            };

            var service = servers[0].service;
            var serverIds = $.map(servers, function(element) {
                return element.sessionId;
            });

            var settings = {
                success: onUpdateClientSuccess,
                error: onUpdateClientError,
                url: service.url() + EVWEB2.urls.videopush,
                type: 'POST',
                traditional: true,
                data: {
                    s: serverIds,
                    name: name,
                    maxPanels: maxPanels,
                    capabilities: capabilities
                }
            };

            if(applicationType === EVWEB2.VideoPushApplications.mobile) {
                settings.data.mobile = 1;
            }

            if(guid !== '') {
                settings.data.guid = guid;
            }

            EVWEB2.ajax(settings, service);
        };

        /**
         * Sends a VideoPush message to the specified target.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed
         * a {@link EVWEB2.ResponseStatus} instance with the details of the response and a {@link EVWEB2.VideoPushMessage}
         * instance describing the sent message.
         * @param {EVWEB2.VideoPushMessage} message The VideoPush message to send.
         */
        this.sendMessage = function(callback, message) {
            var onSendMessageError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSendMessageSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                // Update the message info
                message.messageId = data.messageId;

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, message);
            };

            if(guid === '') {
                var guidError = new EVWEB2.ResponseStatus(false, 'GUID not specified for client.');
                callback(guidError);
            }

            if (message.target.servers.length === 0) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'No servers match the push target.');
                callback(errorResponse);
            }

            var service = message.target.servers[0].service;
            var serverIds = $.map(message.target.servers, function(element) {
                return element.sessionId;
            });

            var settings = {
                success: onSendMessageSuccess,
                error: onSendMessageError,
                url: service.url() + EVWEB2.urls.videopush + '/' + guid,
                type: 'POST',
                traditional: true,
                data: {
                    s: serverIds,
                    targetId: message.target.id,
                    type: message.type,
                    content: message.generateContent()
                }
            };

            EVWEB2.ajax(settings, service);
        };

        /**
         * Checks for incoming messages for this client.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed
         * a {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         * {@link EVWEB2.VideoPushMessage} instances describing the received messages.
         * Note: The {@link EVWEB2.View} and {@link EVWEB2.Tour} instances returned are not the same instances provided
         * by {@link EVWEB2.Service.getViews} and {@link EVWEB2.Service.getTours} and are not necessarily complete.
         * They only provide the minimum information to apply the message content.
         * @param {EVWEB2.Server[]} servers The server instances to check for messages.  Messages spanning servers will
         * be merged into one message.
         */
        this.checkMessages = function(callback, servers) {
            var onCheckMessagesError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onCheckMessagesSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var target = new EVWEB2.VideoPushTarget('', clientName, clientServers, clientCapabilities,
                    clientMaxPanels);

                var messages = $.map(data.events, function(element) {
                    var content;
                    var itemContent = element.content;
                    var tourFolders;

                    if(element.type === EVWEB2.VideoPushMessageTypes.displaySettings) {
                        content = itemContent;
                    }
                    else if(element.type === EVWEB2.VideoPushMessageTypes.liveViews) {
                        var items = $.map(itemContent.items, function(item) {
                            var server = $.grep(servers, function(el) {
                                return el.id.toString() === item.server.toString();
                            })[0];
                            var type = null;
                            if(item.type === EVWEB2.ViewSlotItemTypes.camera) {
                                type = EVWEB2.Camera;
                            }
                            else if(item.type === EVWEB2.ViewSlotItemTypes.group) {
                                type = EVWEB2.Map;
                            }
                            else if(item.type === EVWEB2.ViewSlotItemTypes.audio) {
                                type = EVWEB2.AudioDevice;
                            }
                            return new EVWEB2.ViewSlotItem(item.id, server, type, item.slot, item.digitalPtzType);
                        });

                        var layoutSlots = $.map(itemContent.layout_info.slots, function(slot) {
                            return new EVWEB2.LayoutSlot(slot.y, slot.x, slot.width, slot.height);
                        });

                        var layoutInfo = new EVWEB2.Layout(undefined, itemContent.layout_info.width,
                            itemContent.layout_info.height, itemContent.layout_info.length, layoutSlots);

                        // The folder for incoming views is always treated as the root folder.
                        var folder = new EVWEB2.ViewFolder('0', '', '0');

                        content = new EVWEB2.View(itemContent.name, folder, items, itemContent.layout, layoutInfo,
                                                    undefined, undefined, undefined, itemContent.id);
                    }
                    else if(element.type === EVWEB2.VideoPushMessageTypes.liveTours) {
                        tourFolders = $.map(itemContent.folders, function(folder, index) {
                            var parentIndex = index - 1;
                            if(parentIndex < 0) {
                                parentIndex = 0;
                            }
                            return new EVWEB2.TourFolder(index.toString(), folder, parentIndex.toString());
                        });
                        var tourFolder;
                        if(tourFolders.length > 0) {
                            tourFolder = tourFolders[tourFolders.length - 1];
                        }
                        var views = $.map(itemContent.views, function(view) {
                            return new EVWEB2.TourItem(view.index, view.dwell, view.view);
                        });

                        content = new EVWEB2.Tour(itemContent.name, tourFolder, views, itemContent.description);
                    }

                    var message = new EVWEB2.VideoPushMessage(target, element.sender, content, tourFolders);
                    message.type = element.type;
                    return message;
                });


                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, messages);
            };

            if(guid === '') {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'GUID not specified for client.');
                callback(errorResponse);
            }

            var service = servers[0].service;
            var serverIds = $.map(servers, function(element) {
                return element.sessionId;
            });

            var settings = {
                success: onCheckMessagesSuccess,
                error: onCheckMessagesError,
                url: service.url() + EVWEB2.urls.videopush + '/' + guid,
                type: 'GET',
                traditional: true,
                data: {
                    s: serverIds
                }
            };

            EVWEB2.ajax(settings, service);
        };
    };

}());

/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * The ServerConfig object acts as a container for configuration information for all devices on the specified server.
     * @param {EVWEB2.Server} [server=null] The associated server.
     * @class
     * @category Server
     */
    EVWEB2.ServerConfig = function(server) {
        /**
         * The associated server.
         * @type EVWEB2.Server
         */
        this.server = null;

        // Assign the constructor values
        if(server !== undefined) {
            this.server = server;
        }

        /**
         * Retrieve configuration information of all devices on the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.DeviceConfig} objects.
         */
        this.getDevicesConfiguration = function(callback) {
            var serverInstance = this.server;

            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onGetDevicesConfigError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetDevicesConfigSuccess = function(data/*, textStatus, xhr*/) {
                var devices = data.devices;

                var devicesList = $.map(devices, function(element) {
                    var cameraInfo = $.map(element.cameras, function(element) {
                        return new EVWEB2.DeviceConfigCameraInfo(element.cameraId.toString(),
                            element.parentCameraId.toString(), element.name, element.isPrimary);
                    });

                    return new EVWEB2.DeviceConfig(element.id, element.name, element.host, element.port, element.type,
                        element.model, element.macAddress, element.firmware, element.enabled, element.isConnected,
                        cameraInfo, element.user, serverInstance, element.serial, element.videoStandard);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, devicesList, serverInstance);
            };

            var settings = {
                success: onGetDevicesConfigSuccess,
                error: onGetDevicesConfigError,
                url: serverInstance.service.url() + EVWEB2.urls.devices,
                data: {
                    s: serverInstance.sessionId
                }
            };

            EVWEB2.ajax(settings, serverInstance.service);
        };

        /**
         * Retrieve the list of supported device types on the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.DeviceTypeInfo} objects.
         */
        this.getDeviceTypes = function(callback) {
            var serverInstance = this.server;

            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onGetDeviceTypesError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetDeviceTypesSuccess = function(data/*, textStatus, xhr*/) {
                var deviceTypes = data.deviceTypes;

                var deviceTypesList = $.map(deviceTypes, function(element) {
                    return new EVWEB2.DeviceTypeInfo(element.name, element.defaultUser, element.defaultPassword,
                        element.defaultPort);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, deviceTypesList);
            };

            var settings = {
                success: onGetDeviceTypesSuccess,
                error: onGetDeviceTypesError,
                url: serverInstance.service.url() + EVWEB2.urls.deviceTypes,
                data: {
                    s: serverInstance.sessionId
                }
            };

            EVWEB2.ajax(settings, serverInstance.service);
        };

        /* The addDevice is a method that adds a device to the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance with the details of the response.
         * @param {EVWEB2.DeviceConfig} deviceConfiguration The new device configuration to apply.
         * @param {String} [password] The password for connections to the device.
         */
        this.addDevice = function(callback, deviceConfiguration, password) {
            var serverInstance = this.server;

            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };

            var params = {
                s: serverInstance.sessionId,
                host: deviceConfiguration.hostName,
                port: deviceConfiguration.port,
                user: deviceConfiguration.username,
                enabled: deviceConfiguration.enabled,
                deviceType: deviceConfiguration.type
            };

            if(password !== undefined) {
                params.password = password;
            }

            var settings = {
                url: serverInstance.service.url() + EVWEB2.urls.devices,
                success: onSuccess,
                error: onError,
                type: 'POST',
                data: params
            };

            EVWEB2.ajax(settings, serverInstance.service, true);
        };

        /**
         * The getArchiveTargets method lists the archive targets configured on the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed an
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.ArchiveTarget} objects.
         */
        this.getArchiveTargets = function(callback) {
            if (typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var server = this.server;

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    callback(new EVWEB2.ResponseStatus(false, data.errorText));
                    return;
                }

                var archiveTargets = [];
                data.archiveTargets.forEach(function(target) {
                    var upload = new EVWEB2.ArchiveUploadConfig(target.upload.address, target.upload.hasBookmarks,
                        target.upload.percentToUse, target.upload.username, target.upload.password,
                        target.upload.mountPoint, target.upload.desiredContentAge, target.upload.expirationType,
                        target.upload.expirationDuration);
                    var search = new EVWEB2.ArchiveSearchConfig(target.search.enabled, target.search.address,
                        target.search.username, target.search.password);
                    var archiveTarget = new EVWEB2.ArchiveTarget(server, target.id, target.enabled, target.type, upload,
                        search);
                    archiveTargets.push(archiveTarget);
                });
                callback(new EVWEB2.ResponseStatus(true), archiveTargets);
            };

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                callback(new EVWEB2.ResponseStatus(false, 'An error occurred.'));
            };

            var settings = {
                url: server.service.url() + EVWEB2.urls.archiveTargets,
                type: 'GET',
                data: {
                    s: server.sessionId
                },
                success: onSuccess,
                error: onError
            };
            EVWEB2.ajax(settings, server.service, true);
        };
    };

}());

/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * Available video standards a device could possibly be reported as.
     * @enum {number}
     * @readonly
     * @category Device
     */
    EVWEB2.videoStandards = {
        /**
         * None
         */
        none: 0,
        /**
         * NTSC
         */
        ntsc: 1,
        /**
         * PAL
         */
        pal: 2,
        /**
         * Unknown
         */
        unknown: 3
    };

    /**
     * The DeviceConfigCameraInfo object acts as a container for camera information of a device.
     * @param {String} [id=''] The ID of the camera
     * @param {String} [parentId=''] The ID of the parent camera.  This will be equal to
     * {@link EVWEB2.DeviceConfigCameraInfo.id} if the camera is the primary camera.
     * @param {String} [name=''] The display name of the camera.
     * @param {Boolean} [isPrimary=false] Whether the camera is the primary camera.
     * @class
     * @constructor
     * @category Device
     */
    EVWEB2.DeviceConfigCameraInfo = function(id, parentId, name, isPrimary) {
        /**
         * The ID of the camera.
         * @type String
         */
        this.id = '';

        /**
         * The ID of the parent camera.  This will be equal to  {@link EVWEB2.DeviceConfigCameraInfo.id} if the camera
         * is the primary camera.
         * @type String
         */
        this.parentId = '';

        /**
         * The display name of the camera.
         * @type String
         */
        this.name = '';

        /**
         * Whether the camera is the primary camera.
         * @type Boolean
         */
        this.isPrimary = false;

        //Assign the constructor values
        if(id !== undefined) {
            this.id = id;
        }
        if(parentId !== undefined) {
            this.parentId = parentId;
        }
        if(name !== undefined) {
            this.name = name;
        }
        if(isPrimary !== undefined) {
            this.isPrimary = isPrimary;
        }
    };

    /**
     * The DeviceTypeInfo object acts as a container for configuration information related to supported device types.
     * @param {String} [name=''] The name of the device type.
     * @param {String} [username=''] The default username for connections to the device.
     * @param {String} [password=''] The default password for connections to the device.
     * @param {Number} [port=0] The default port for the device.
     * @class
     * @constructor
     * @category Device
     */
    EVWEB2.DeviceTypeInfo = function(name, username, password, port) {
        /**
         * The name of the device type.
         * @type String
         */
        this.name = '';

        /**
         * The default username for connections to the device.
         * @type String
         */
        this.username = '';

        /**
         * The default password for connections to the device.
         * @type String
         */
        this.password = '';

        /**
         * The default port for the device.
         * @type Number
         */
        this.port = 0;

        //Assign the constructor values
        if(name !== undefined) {
            this.name = name;
        }
        if(username !== undefined) {
            this.username = username;
        }
        if(password !== undefined) {
            this.password = password;
        }
        if(port !== undefined) {
            this.port = port;
        }
    };

    /**
     * The DeviceConfig object acts as a container for configuration information of a device.
     * @param {Number} [id=0] The device ID.
     * @param {String} [name=''] The name of the device.
     * @param {String} [hostName=''] The host name of the device.
     * @param {Number} [port=0] The port for the device.
     * @param {String} [type=''] The type of device.
     * @param {String} [model=''] The device model.
     * @param {String} [macAddress=''] The MAC address of the device.
     * @param {String} [firmware=''] The firmware information of the device.
     * @param {Boolean} [enabled=false] Whether the device is enabled or not.
     * @param {Boolean} [connectionStatus=false] The connection status of the device.
     * @param {EVWEB2.DeviceConfigCameraInfo[]} [cameraInfo=[]] Information about the cameras associated with this
     * device.
     * @param {String} [username=''] The username for connections to the device.
     * @param {EVWEB2.Server} [server=null] The server associated with the device.
	 * @param {String} [serial=''] The serial number of the device.
     * @param {Number} [videoStandard=EVWEB2.videoStandards.none] The device video standard.
     * @class
     * @category Device
     */
    EVWEB2.DeviceConfig = function(id, name, hostName, port, type, model, macAddress, firmware, enabled,
                                   connectionStatus, cameraInfo, username, server, serial, videoStandard) {
        /**
         * The name of the device.
         * @type String
         */
        this.name = '';

        /**
         * The host name of the device.
         * @type String
         */
        this.hostName = '';

        /**
         * The device port.
         * @type Number
         */
        this.port = 0;

        /**
         * The username for connections to the device.
         * @type String
         */
        this.username = '';

        /**
         * The device type.
         * @type String
         */
        this.type = '';

        /**
         * The device ID.
         * @type Number
         */
        this.id = 0;

        /**
         * Whether the device is enabled or not.
         * @type Boolean
         */
        this.enabled = false;

        /**
         * The device model.
         * @type String
         */
        this.model = '';

        /**
         * The device MAC address.
         * @type String
         */
        this.macAddress = '';

        /**
         * The device serial number .
         * @type String
         */
        this.serial = '';

        /**
         * The firmware information of the device.
         * @type String
         */
        this.firmware = '';

        /**
         * The connection status of the device.
         * @type Boolean
         */
        this.connectionStatus = false;

        /**
         * Information about the cameras associated with this device.
         * @type EVWEB2.DeviceConfigCameraInfo[]
         */
        this.cameraInfo = [];

        /**
         * The server instance associated with the device.
         * @type EVWEB2.Server
         */
        this.server = null;

        /**
         * The video standard of the device.
         * @type EVWEB2.videoStandards
         */
        this.videoStandard = EVWEB2.videoStandards.none;

        //Assign the constructor values
        if(name !== undefined) {
            this.name = name;
        }
        if(hostName !== undefined) {
            this.hostName = hostName;
        }
        if(port !== undefined) {
            this.port = port;
        }
        if(username !== undefined) {
            this.username = username;
        }
        if(type !== undefined) {
            this.type = type;
        }
        if(id !== undefined) {
            this.id = id;
        }
        if(enabled !== undefined) {
            this.enabled = Boolean(enabled);
        }
        if(model !== undefined) {
            this.model = model;
        }
        if(macAddress !== undefined) {
            this.macAddress = macAddress;
        }
        if(firmware !== undefined) {
            this.firmware = firmware;
        }
        if(connectionStatus !== undefined) {
            this.connectionStatus = connectionStatus;
        }
        if(cameraInfo !== undefined) {
            this.cameraInfo = cameraInfo;
        }
        if(server !== undefined) {
            this.server = server;
        }

        if(serial !== undefined) {
            this.serial = serial;
        }

        if(videoStandard !== undefined) {
            this.videoStandard = videoStandard;
        }

        /**
         * The deleteDevice is a method that deletes a device from the server. Note: Deleting a device will make
         * any recorded video non-searchable.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance with the details of the response.
         */
        this.deleteDevice = function(callback) {
            var server = this.server;

            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onDeleteDeviceError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onDeleteDeviceSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };

            var params = {
                s: server.sessionId,
                id: this.id
            };

            var settings = {
                success: onDeleteDeviceSuccess,
                error: onDeleteDeviceError,
                url: server.service.url() + EVWEB2.urls.devices,
                type: 'DELETE',
                data: params
            };

            EVWEB2.ajax(settings, server.service);

        };

        /**
         * The updateDevice is a method that helps to update the device configuration on the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance.
         * @param {String} [password] The password for connections to the device.
         */
        this.updateDevice = function(callback, password) {
            var server = this.server;

            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onUpdateDeviceError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onUpdateDeviceSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };

            var params = {
                s: server.sessionId,
                id: this.id,
                host: this.hostName,
                port: this.port,
                user: this.username,
                enabled: this.enabled
            };

            if(password !== undefined) {
                params.password = password;
            }

            var settings = {
                success: onUpdateDeviceSuccess,
                error: onUpdateDeviceError,
                url: server.service.url() + EVWEB2.urls.devices,
                type: 'PUT',
                data: params
            };

            EVWEB2.ajax(settings, server.service);
        };
    };

}());
/*globals EVWEB2:true*/

(function() {
    "use strict";

    /**
     * The LiveUserPermissions object represents the permissions for live playback on the specified server.
     * @param {Boolean} [base=false] Permission to view the live tab.  Note: If this parameter is false,
     * all other parameters will be ignored and set to false.
     * @deprecated This object is deprecated in favor of {@link EVWEB2.UserGroup} which includes information
     * about a group and all its permissions.
     * @param {Boolean} [groups=false] Permission to view groups.
     * @param {Boolean} [maps=false] Permission to view maps.
     * @param {Boolean} [views=false] Permission to view views.
     * @param {Boolean} [quickReplay=false] Permission to view quickReplay.
     * @param {Boolean} [ptz=false] Permission to perform PTZ actions.
     * @param {Boolean} [twoWayAudio=false] Permission to interact with two-way audio.
     * @param {Boolean} [eventMonitor=false] Permission to view event monitor.
     * @param {Boolean} [saveImage=false] Permission to save images.
     * @param {Boolean} [printImage=false] Permission to print images.
     * @param {Boolean} [cameras=false] Permission to view cameras.
     * @param {Boolean} [videoPush=false] Permission to perform video push.
     * @class
     * @category Server
     */
    EVWEB2.LiveUserPermissions = function(base, groups, maps, views, quickReplay, ptz, twoWayAudio, eventMonitor,
                                                   saveImage, printImage, cameras, videoPush) {
        /**
         * Permission to view the live tab.  Note: If this parameter is false, all other parameters will be ignored
         * and set to false.
         * @type Boolean
         */
        this.base = false;

        /**
         * Whether the user has permission to view groups.
         * @type Boolean
         */
        this.groups = false;

        /**
         * Whether the user has permission to view maps.
         * @type Boolean
         */
        this.maps = false;

        /**
         * Whether the user has permission to view views.
         * @type Boolean
         */
        this.views = false;

        /**
         * Whether the user has permission to view quickReplay.
         * @type Boolean
         */
        this.quickReplay = false;

        /**
         * Whether the user has permission to perform ptz actions.
         * @type Boolean
         */
        this.ptz = false;

        /**
         * Whether the user has permission to interact with two-way audio.
         * @type Boolean
         */
        this.twoWayAudio = false;

        /**
         * Whether the user has permission to view event monitor.
         * @type Boolean
         */
        this.eventMonitor = false;

        /**
         * Whether the user has permission to save images.
         * @type Boolean
         */
        this.saveImage = false;

        /**
         * Whether the user has permission to print images.
         * @type Boolean
         */
        this.printImage = false;

        /**
         * Whether the user has permission to view cameras.
         * @type Boolean
         */
        this.cameras = false;

        /**
         * Whether the user has permission to perform video push.
         * @type Boolean
         */
        this.videoPush = false;

        //Assign the constructor values
        if(base !== undefined) {
            this.base = base;
            if(!this.base) {
                // If the base level isn't supported, all the others will stay at the default false.
                return;
            }
        }
        if(groups !== undefined) {
            this.groups = groups;
        }
        if(maps !== undefined) {
            this.maps = maps;
        }
        if(views !== undefined) {
            this.views = views;
        }
        if(quickReplay !== undefined) {
            this.quickReplay = quickReplay;
        }
        if(ptz !== undefined) {
            this.ptz = ptz;
        }
        if(twoWayAudio !== undefined) {
            this.twoWayAudio = twoWayAudio;
        }
        if(eventMonitor !== undefined) {
            this.eventMonitor = eventMonitor;
        }
        if(saveImage !== undefined) {
            this.saveImage = saveImage;
        }
        if(printImage !== undefined) {
            this.printImage = printImage;
        }
        if(cameras !== undefined) {
            this.cameras = cameras;
        }
        if(videoPush !== undefined) {
            this.videoPush = videoPush;
        }
    };

    /**
     * The SearchUserPermissions object represents the permissions for search playback on the specified server.
     * @param {Boolean} [base=false] Permission to view the search tab.  Note: If this parameter is false,
     * all other parameters will be ignored and set to false.
     * @deprecated This object is deprecated in favor of {@link EVWEB2.UserGroup} which includes information
     * about a group and all its permissions.
     * @param {Boolean} [groups=false] Permission to search groups.
     * @param {Boolean} [maps=false] Permission to search maps.
     * @param {Boolean} [views=false] Permission to search views.
     * @param {Boolean} [events=false] Permission to search events.
     * @param {Boolean} [saveImage=false] Permission to save images.
     * @param {Boolean} [printImage=false] Permission to print images.
     * @param {Boolean} [burnDisc=false] Permission to burn discs.
     * @param {Boolean} [exportVideo=false] Permission to export video.
     * @param {Boolean} [smartSearch=false] Permission to perform smart search.
     * @param {Boolean} [cases=false] Permission to search cases.
     * @param {Boolean} [cameras=false] Permission to search cameras.
     * @class
     * @category Server
     */
    EVWEB2.SearchUserPermissions = function(base, groups, maps, views, events, saveImage, printImage, burnDisc,
                                                                    exportVideo, smartSearch, cases, cameras) {
        /**
         * Permission to view the search tab.  Note: If this parameter is false, all other parameters will be ignored
         * and set to false.
         * @type Boolean
         */
        this.base = false;

        /**
         * Whether the user has permission to search groups.
         * @type Boolean
         */
        this.groups = false;

        /**
         * Whether the user has permission to search maps.
         * @type Boolean
         */
        this.maps = false;

        /**
         * Whether the user has permission to search views.
         * @type Boolean
         */
        this.views = false;

        /**
         * Whether the user has permission to search events.
         * @type Boolean
         */
        this.events = false;

        /**
         * Whether the user has permission to save images.
         * @type Boolean
         */
        this.saveImage = false;

        /**
         * Whether the user has permission to print images.
         * @type Boolean
         */
        this.printImage = false;

        /**
         * Whether the user has permission to view burn discs.
         * @type Boolean
         */
        this.burnDisc = false;

        /**
         * Whether the user has permission to export video.
         * @type Boolean
         */
        this.exportVideo = false;

        /**
         * Whether the user has permission to perform smart search.
         * @type Boolean
         */
        this.smartSearch = false;

        /**
         * Whether the user has permission to search cases.
         * @type Boolean
         */
        this.cases = false;

        /**
         * Whether the user has permission to search cameras.
         * @type Boolean
         */
        this.cameras = false;

        //Assign the constructor values
        if(base !== undefined) {
            this.base = base;
            if(!this.base) {
                // If the base level isn't supported, all the others will stay at the default false.
                return;
            }
        }
        if(groups !== undefined) {
            this.groups = groups;
        }
        if(maps !== undefined) {
            this.maps = maps;
        }
        if(views !== undefined) {
            this.views = views;
        }
        if(events !== undefined) {
            this.events = events;
        }
        if(saveImage !== undefined) {
            this.saveImage = saveImage;
        }
        if(printImage !== undefined) {
            this.printImage = printImage;
        }
        if(burnDisc !== undefined) {
            this.burnDisc = burnDisc;
        }
        if(exportVideo !== undefined) {
            this.exportVideo = exportVideo;
        }
        if(smartSearch !== undefined) {
            this.smartSearch = smartSearch;
        }
        if(cases !== undefined) {
            this.cases = cases;
        }
        if(cameras !== undefined) {
            this.cameras = cameras;
        }
    };

    /**
     * The ConfigUserPermissions object represents the user permissions for configuring the specified server.
     * @deprecated This object is deprecated in favor of {@link EVWEB2.UserGroup} which includes information
     * about a group and all its permissions.
     * @param {Boolean} [userAdmin=false] Permission to administrate users.
     * @param {Boolean} [viewAdmin=false] Permission to administrate views.
     * @class
     * @category Server
     */
    EVWEB2.ConfigUserPermissions = function(userAdmin, viewAdmin) {
        /**
         * Permission to administrate users.
         * @type Boolean
         */
        this.userAdmin = false;

        /**
         * Permission to administrate views.
         * @type Boolean
         */
        this.viewAdmin = false;

        //Assign the constructor values
        if(userAdmin !== undefined) {
            this.userAdmin = userAdmin;
        }
        if(viewAdmin !== undefined) {
            this.viewAdmin = viewAdmin;
        }
    };

    /**
     * The UserPermissions object represents the user permissions for the logged in user on the specified server.
     * @deprecated This object is deprecated in favor of {@link EVWEB2.UserGroup} which includes information
     * about a group and all its permissions.
     * @param {EVWEB2.LiveUserPermissions} [livePermissions=null] The live permissions for the user on the provided server.
     * @param {EVWEB2.SearchUserPermissions} [searchPermissions=null] The search permissions for the user on the
     * provided server.
     * @param {EVWEB2.ConfigUserPermissions} [configPermissions=null] The configuration permissions for the user on the
     * provided server.
     * @param {EVWEB2.accessLevelType} [accessLevel=EVWEB2.accessLevelType.unknown] The access level of the user.
     * @class
     * @category Server
     */
    EVWEB2.UserPermissions = function(livePermissions, searchPermissions, configPermissions, accessLevel) {
        /**
         * The live permissions for the user on the provided server.
         * @type EVWEB2.LiveUserPermissions
         */
        this.livePermissions = null;

        /**
         * The live permissions for the user on the provided server.
         * @type EVWEB2.SearchUserPermissions
         */
        this.searchPermissions = null;

        /**
         * The permissions for the user to configure the provided server.
         * @type EVWEB2.ConfigUserPermissions
         */
        this.configPermissions = null;

        /**
         * The access level of the user.
         * @type EVWEB2.accessLevelType
        */
        this.accessLevel = EVWEB2.accessLevelType.unknown;

        //Assign the constructor values
        if(livePermissions !== undefined) {
            this.livePermissions = livePermissions;
        }
        if(searchPermissions !== undefined) {
            this.searchPermissions = searchPermissions;
        }
        if(configPermissions !== undefined) {
            this.configPermissions = configPermissions;
        }
        if(accessLevel !== undefined) {
            this.accessLevel = accessLevel;
        }
    };
}());
/*globals EVWEB2:true*/

(function() {
    "use strict";

    /**
     * The account type of the user.
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.accountTypes = {
        /**
         * Local User
         */
        local: 0,
        /**
         * LDAP User
         */
        ldap: 1
    };

    /**
     * The User object represents a single user account on the server.
     * @param {EVWEB2.Server} [server=null] The server the user is associated with.
     * @param {String} [username=''] The user's login username.
     * @param {String} [groupName=''] The name of the group the user belongs to.
     * @param {EVWEB2.accountTypes} [accountType=EVWEB2.accountTypes.local] The type of user account.
     * @param {Boolean} [isOrphaned=false] Whether the account is orphaned or not. This flag is set only for LDAP accounts.
     * @param {Boolean} [isManaged=false] Whether the account is managed or not. If this flag is set, the user is
     * managed by an external third-party and can not be edited by users of the server.
     * @class
     * @constructor
     * @category Server
     */
    EVWEB2.User = function(server, username, groupName, accountType, isOrphaned, isManaged) {
        /**
         * The erver associated with the user.
         * @type EVWEB2.Server
         */
        this.server = null;

        /**
         * The user's login username.
         * @type String
         */
        this.username = '';

        /**
         * The group name the user belongs to.
         * @type ''
        */
        this.groupName = '';

        /**
         * The type of user account.
         * @type EVWEB2.accountTypes
        */
        this.accountType = EVWEB2.accountTypes.local;

        /**
         * Whether the account is managed or not. If this flag is set, the user is managed by an
         * external third-party and can not be edited by users of the server.
         * @type {boolean}
         */
        this.isManaged = false;

        //Assign the constructor values
        if(server !== undefined) {
            this.server = server;
        }
        if(username !== undefined) {
            this.username = username;
        }
        if(groupName !== undefined) {
            this.groupName = groupName;
        }
        if (accountType !== undefined) {
            this.accountType = accountType;
        }
        if(accountType === EVWEB2.accountTypes.ldap && isOrphaned !== undefined) {
            this.isOrphaned = isOrphaned;
        }
        if(isManaged !== undefined) {
            this.isManaged = isManaged;
        }

        /**
         * Store the original username to detect name changes
         * @type {String}
         */
        var originalUsername = this.username;

        /**
         * Delete a user from the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed
         * a {@link EVWEB2.ResponseStatus} instance
         */
        this.deleteUser = function(callback) {
            var server = this.server;

            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onDeleteUserError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onDeleteUserSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };

            var params = {
                s: server.sessionId,
                user: this.username
            };

            var settings = {
                success: onDeleteUserSuccess,
                error: onDeleteUserError,
                url: server.service.url() + EVWEB2.urls.users,
                type: 'DELETE',
                data: params
            };

            EVWEB2.ajax(settings, server.service);
        };

        /**
         * This method updates an existing user on the server. This function is also used to update a group by making
         * changes to the user's group.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed
         * a {@link EVWEB2.ResponseStatus} instance.
         * @param {EVWEB2.UserGroup} [userGroup] The user group information.
         * @param {String} [password=''] The password for the user account, password left untouched if not given.
         */
        this.update = function(callback, userGroup, password) {
            var server = this.server;
            var user = this;

            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }

            var onUpdateUserError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onUpdateUserSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                if (user.username !== originalUsername){
                    // reset original name for subsequent updates
                    originalUsername = user.username;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };

            var params = {
                s: server.sessionId,
                name: this.username,
                role: userGroup.accessLevel,
                accountType: this.accountType
            };

            if (userGroup !== undefined) {
                var bitmask = EVWEB2.util.internal.generatePermissionsBitmask(userGroup.permissions);
                params['guid'] = userGroup.guid;
                params['grpName'] = userGroup.name;
                params['grpGroupPermission'] = bitmask.group;
                params['grpUserPermission'] = bitmask.user;
                params['grpAdminPermission'] = bitmask.admin;
                params['grpCameras'] = userGroup.customGroupPermissions.cameras.join(",");
                params['grpAudios'] = userGroup.customGroupPermissions.audios.join(",");
                params['grpSerials'] = userGroup.customGroupPermissions.serials.join(",");
                params['grpSoftTriggers'] = userGroup.customGroupPermissions.softTriggers.join(",");
            }

            if (originalUsername !== '' && originalUsername !== this.username){
                params['originalName'] = originalUsername;
            }

            if (password !== undefined && password !== ''){
                params['password'] = password;
            }

            var priority = userGroup.getPriority(EVWEB2.groupPriorityTypes.ptz);
            if (priority !== undefined){
                params['grpPtzPriority'] = priority.value;
            }

            priority = userGroup.getPriority(EVWEB2.groupPriorityTypes.twoWayAudio);
            if (priority !== undefined){
                params['grpAudioPriority'] = priority.value;
            }

            priority = userGroup.getPriority(EVWEB2.groupPriorityTypes.client);
            if (priority !== undefined){
                params['grpRemotePriority'] = priority.value;
            }

            var settings = {
                success: onUpdateUserSuccess,
                error: onUpdateUserError,
                url: server.service.url() + EVWEB2.urls.users,
                type: 'PUT',
                data: params
            };

            EVWEB2.ajax(settings, server.service);
        };
    };
}());
/* globals EVWEB2:true */

(function() {
    /**
     * In server arbitration cases, a user with priority can override those without
     * @enum {number}
     * @readonly
     * @category Server
     */
    EVWEB2.groupPriorityTypes = {
        /**
         * None.  User always loses arbitration
         */
        none: 0,
        /**
         * PTZ. User can take over PTZ controls from those with lower priority
         */
        ptz: 1,
        /**
         * Two-way Audio. User can take over sound sent out of a device from those with lower priority
         */
        twoWayAudio: 2,
        /**
         * Client. User can override other pushed video from those with lower priority
         */
        client: 3
    };

    /**
     * The UserGroupPermissions object represents the permissions associated with a particular group on
     * the specified server.
     * @param {EVWEB2.userPermissions[]} [permissions=[]] An array of the available named permissions for
     * a group.
     * @constructor
     * @category Server
     */
    EVWEB2.UserGroupPermissions = function(permissions) {
        /**
         * An array of the available permissions for a group.
         * @type EVWEB2.userPermissions[]
         */
        this.permissions = [];

        //Assign the constructor values
        if (permissions !== undefined) {
            this.permissions = permissions;
        }

        /**
         * Determines whether the EVWEB2.UserGroupPermissions object has a specific permission.
         * @param {EVWEB2.userPermissions} permission The user permission to check.
         * @returns {Boolean} Whether the object has the specified permission.
         */
        this.hasPermission = function (permission) {
            if($.inArray(permission, this.permissions) !== -1) {
                return true;
            }

            return false;
        };

        /**
         * Determines whether the object has ANY of the permissions given.
         * @param {EVWEB2.userPermissions[]} permissions Array of permissions to check.
         * @returns {Boolean} Whether the object has at least one of the specified permissions.
         */
        this.hasAnyPermissions = function (permissions) {
            var permissionsArray = this.permissions;
            var i;

            for(i=0; i<permissions.length; i++) {
                if($.inArray(permissions[i], permissionsArray) !== -1) {
                    return true;
                }
            }
            return false;
        };

        /**
         * Determines whether the object has ALL of the permissions given.
         * @param {EVWEB2.userPermissions[]} permissions Array of permissions to check.
         * @returns {Boolean} Whether the object has ALL of the specified permissions.
         */
        this.hasAllPermissions = function (permissions) {
            var permissionsArray = this.permissions;
            var hasAllPermissions = true;

            $.each(permissions, function(index, element) {
                hasAllPermissions = $.inArray(element, permissionsArray) !== -1 && hasAllPermissions;
            });
            return hasAllPermissions;
        };
    };

    /**
     * The CustomGroupPermissions object represents the additional group permissions/restrictions for a
     * particular group on the specified server.
     * @param {Number[]} [cameras=[]] An array of camera id's the group has permissions for.
     * @param {Number[]} [audios=[]] An array of audio id's the group has permissions for.
     * @param {Number[]} [serials=[]] An array of serial id's the group has permissions for.
     * @param {Number[]} [softTriggers=[]] An array of soft trigger id's the group has permissions for.
     * @constructor
     * @category Server
     */
    EVWEB2.CustomGroupPermissions = function(cameras, audios, serials, softTriggers) {
        /**
         * An array of camera id's the group has permissions for.
         * @type Number[]
         */
        this.cameras = [];

        /**
         * An array of audio id's the group has permissions for.
         * @type Number[]
         */
        this.audios = [];

        /**
         * An array of serial id's the group has permissions for.
         * @type Number[]
         */
        this.serials = [];

        /**
         * An array of soft trigger id's the group has permissions for.
         * @type Number[]
         */
        this.softTriggers = [];

        //Assign the constructor values
        if(cameras !== undefined) {
            this.cameras = cameras;
        }
        if(audios !== undefined) {
            this.audios = audios;
        }
        if(serials !== undefined) {
            this.serials = serials;
        }
        if(softTriggers !== undefined) {
            this.softTriggers = softTriggers;
        }
    };

     /**
     * The UserGroupPriority represents a single priority for a group.
     * @param {EVWEB2.groupPriorityTypes} [priority=EVWEB2.groupPriorityTypes.none] The type of priority.
     * @param {Number} value The value to assign to the priority.
     * @constructor
      * @category Server
     */
    EVWEB2.UserGroupPriority = function(priority, value) {
        /**
         * The priority type.
         * @type EVWEB2.groupPriorityTypes
         */
        this.priority = EVWEB2.groupPriorityTypes.none;

        /**
         * The value to assign to the priority.
         * @type Number
         */
        this.value = -1;

        //Assign the constructor values
        if(priority !== undefined) {
            this.priority = priority;
        }
        if(value !== undefined) {
            this.value = value;
        }
    };

    /**
     * The UserGroup object represents a server side group and all of it's permissions.
     * @param {String} [name=''] The name of the group.
     * @param {EVWEB2.accessLevelType} [accessLevel=EVWEB2.accessLevelType.unknown] The access level of the user.
     * @param {EVWEB2.UserGroupPermissions} [permissions=null] The permissions associated with the built-in group.
     * @param {EVWEB2.UserGroupPriority[]} [priorities=[]] An array of the priorities assigned to the group.
     * @param {String} [guid=''] The guid of a custom group.  This value is null for built-in groups (i.e. accessLevel
     * other than {@link EVWEB2.accessLevelType.none})
     * @param {EVWEB2.CustomGroupPermissions} [customGroupPermissions=null] The permissions associated with the custom group.
     * @param {Boolean} [isManaged=false] Whether the group is managed or not. If this flag is set, the group is
     * managed by an external third-party and can not be edited by users of the server.
     * @class
     * @constructor
     * @category Server
     */
    EVWEB2.UserGroup = function(name, accessLevel, permissions, priorities, guid, customGroupPermissions, isManaged) {
        /**
         * The group name.
         * @type String
         */
        this.name = '';

        /**
         * The access level of the user.
         * @type EVWEB2.accessLevelType
         */
        this.accessLevel = EVWEB2.accessLevelType.unknown;

        /**
         * The group permissions.
         * @type EVWEB2.UserGroupPermissions
         */
        this.permissions = null;

        /**
         * An array of the priorities assigned to the group.
         * @type EVWEB2.UserGroupPriority[]
        */
        this.priorities = [];

        /**
         * The guid of a custom group.
         * @type String
        */
        this.guid = '';

        /**
         * The permissions of the custom group.
         * @type EVWEB2.CustomGroupPermissions
        */
        this.customGroupPermissions = null;

        /**
         * Whether the group is managed or not. If this flag is set, the group is managed by an
         * external third-party and can not be edited by users of the server.
         * @type {boolean}
         */
        this.isManaged = false;

        //Assign the constructor values
        if(name !== undefined) {
            this.name = name;
        }
        if(accessLevel !== undefined) {
            this.accessLevel = accessLevel;
        }
        if(permissions !== undefined) {
            this.permissions = permissions;
        }
        if(priorities !== undefined) {
            this.priorities = priorities;
        }
        if(guid !== undefined) {
            this.guid = guid;
        }
        if(customGroupPermissions !== undefined) {
            this.customGroupPermissions = customGroupPermissions;
        }
        if(isManaged !== undefined) {
            this.isManaged = isManaged;
        }

        /**
         * Retrieve a specific priority type
         * @param {EVWEB2.groupPriorityTypes} priorityType The type of priority to retrive
         * @returns {EVWEB2.UserGroupPriority} The existing priority or null if none exists.
         */
        this.getPriority = function (priorityType){
            for(var i = 0; i < this.priorities.length; ++i){
                if (this.priorities[i].priority === priorityType){
                    return this.priorities[i];
                }
            }
            return undefined;
        };

        /**
         * Set a priority or create it if it does not already exist
         * @param {EVWEB2.groupPriorityTypes} priorityType The type of priority to set
         * @param {Number} value the value to assign to the priority
         */
        this.setPriority = function (priorityType, value){
            var existingPriority = this.getPriority(priorityType);
            if (existingPriority !== undefined){
                existingPriority.value = value;
            }else{
                this.priorities.push(new EVWEB2.UserGroupPriority(priorityType, value));
            }
        };
    };
}());
/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * Definitions for types of event monitor profiles.
     * @enum {number}
     * @readonly
     * @category Events
     */
    EVWEB2.EventMonitorProfileTypes = {
        /**
         * Unknown
         */
        Unknown: -1,
        /**
         * Video
         */
        Video: 0,
        /**
         * View
         */
        View: 1
    };

    /**
     * Definitions for types of event monitor source events.
     * @enum {number}
     * @readonly
     * @category Events
     */
    EVWEB2.EventMonitorLinkSourceTypes = {
        /**
         * None
         */
        None: 0,
        /**
         * Soft Trigger
         */
        SoftTrigger: 1,
        /**
         * Time Trigger
         */
        TimeTrigger: 2,
        /**
         * Input Trigger
         */
        InputTrigger: 3,
        /**
         * Video Loss
         */
        VideoLoss: 4,
        /**
         * Video Motion
         */
        VideoMotion: 5,
        /**
         * Disconnect Device
         */
        DisconnectDevice: 6,
        /**
         * Serial Port
         */
        SerialPort: 7,
        /**
         * Serial Profile
         */
        SerialProfile: 8,
        /**
         * Health
         */
        Health: 9,
        /**
         * Button
         */
        Button: 10,
        /**
         * Analytics
         */
        Analytics: 11,
        /**
         * Group
         */
        Group: 12,
        /**
         * Disconnect Video
         */
        DisconnectVideo: 13,
        /**
         * Disconnect Audio
         */
        DisconnectAudio: 14,
        /**
         * Auto-connection
         */
        AutoConnection: 15,
        /**
         * Default
         */
        Default: 16,
        /**
         * Security Integration
         */
        SecurityIntegration: 17,
        /**
         * Security Integration Connected
         */
        SecurityIntegrationConnected: 18,
        /**
         * Serial Port Connection
         */
        SerialPortConnection: 19
    };

    /**
     * Definitions for types of event monitor target events.
     * @enum {number}
     * @readonly
     * @category Events
     */
    EVWEB2.EventMonitorLinkTargetTypes = {
        /**
         * None
         */
        None: 0,
        /**
         * View
         */
        View: 1,
        /**
         * Sound
         */
        Sound: 2,
        /**
         * Tour
         */
        Tour: 3,
        /**
         * Video
         */
        Video: 4,
        /**
         * Log
         */
        Log: 5,
        /**
         * Digital PTZ Preset
         */
        DigitalPreset: 6,
        /**
         * Audio
         */
        Audio: 7
    };

    /**
     * An event monitor link event that has occurred.  Contains the triggered event monitor link, as well as
     * the associated server information.
     * @param {EVWEB2.EventMonitorLink} [eventLink=null] The triggered event link.
     * @param {String} [sourceId=''] The ID of the item that triggered the event link.
     * @param {String} [extraId=''] An extra ID to associate with triggering the event link.
     * @class
     * @constructor
     * @category Events
     */
    EVWEB2.EventMonitorLinkEvent = function(eventLink, sourceId, extraId) {

        /**
         * The triggered event link.
         * @type {EVWEB2.EventMonitorLink}
         */
        this.eventLink = null;

        /**
         * The ID of the item that triggered the event link.
         * @type {string}
         */
        this.sourceId = '';

        /**
         * An extra ID to associate with triggering the event link.
         * @type {string}
         */
        this.extraId = '';

        if(eventLink !== undefined) {
            this.eventLink = eventLink;
        }
        if(sourceId !== undefined) {
            this.sourceId = sourceId;
        }
        if(extraId !== undefined) {
            this.extraId = extraId;
        }
    };

    /**
     * The EventMonitorLinkSource object acts as a container for all information about an event monitor source.
     * @param {String} [server=''] The session ID of the server associated with this event monitor source.
     * @param {String} [id=''] The ID of the item.
     * @param {EVWEB2.EventMonitorLinkSourceTypes} [type=EVWEB2.EventMonitorLinkSourceTypes.None] The type of event
     * monitor source.
     * @param {String} [extraId=''] An extra ID to associate with the event monitor source. Note: This value is
     * currently only used for analytics rules IDs and for Health types.
     * @param {Boolean} [any=false] Whether any item will trigger this source.
     * @class
     * @constructor
     * @category Events
     */
    EVWEB2.EventMonitorLinkSource = function(server, id, type, extraId, any) {

        /**
         * The session ID of the server associated with this event monitor source.
         * @type {string}
         */
        this.server = '';

        /**
         * The ID of the item.
         * @type {string}
         */
        this.id = '';

        /**
         * The type of event monitor source.
         * @type {EVWEB2.EventMonitorLinkSourceTypes}
         */
        this.type = EVWEB2.EventMonitorLinkSourceTypes.None;

        /**
         * An extra ID to associate with the event monitor source. Note: This value is currently only used for
         * analytics rules IDs and Health types.
         * @type {string}
         */
        this.extraId = '';

        /**
         * Whether any item will trigger this source.
         * @type {boolean}
         */
        this.any = false;

        if(server !== undefined) {
            this.server = server;
        }
        if(id !== undefined) {
            this.id = id;
        }
        if(type !== undefined) {
            this.type = type;
        }
        if(extraId !== undefined) {
            this.extraId = extraId;
        }
        if(any !== undefined) {
            this.any = any;
        }
    };

    /**
     * The EventMonitorLinkTarget object acts as a container for all information about an event monitor target.
     * @param {String} [server=''] The session ID of the server associated with this event monitor target.
     * @param {String} [value=''] Either the ID or the name of the item.  This is dependent on the
     * {@link EVWEB2.EventMonitorLinkTarget.type} of the target.
     * @param {EVWEB2.EventMonitorLinkTargetTypes} [type=EVWEB2.EventMonitorLinkTargetTypes.None] The type of event
     * monitor target.
     * @param {String} [extraId=''] An extra ID to associate with the event monitor target. Note: This value is
     * currently only used for selecting a digital preset ID.
     * @param {string[]} [folders=[]] An array of the folders for the value.  Note: This value is used for types
     * that do no have IDs, such as views.
     * @class
     * @constructor
     * @category Events
     */
    EVWEB2.EventMonitorLinkTarget = function(server, value, type, extraId, folders) {

        /**
         * The session ID of the server associated with this event monitor target.
         * @type {string}
         */
        this.server = '';

        /**
         * Either the ID or the name of the item.  This is dependen {@link EVWEB2.EventMonitorLinkTarget.type} of
         * the target.
         * @type {string}
         */
        this.value = '';

        /**
         * The type of event monitor target.
         * @type {EVWEB2.EventMonitorLinkTargetTypes}
         */
        this.type = EVWEB2.EventMonitorLinkTargetTypes.None;

        /**
         * An extra ID to associate with the event monitor target. Note: This value is currently only used for
         * selecting a digital preset ID.
         * @type {string}
         */
        this.extraId = '';

        /**
         * An array of the folders for the value.  Note: This value is used for types that do no have IDs, such as
         * views.
         * @type {string[]}
         */
        this.folders = [];

        if(server !== undefined) {
            this.server = server;
        }
        if(value !== undefined) {
            this.value = value;
        }
        if(type !== undefined) {
            this.type = type;
        }
        if(extraId !== undefined) {
            this.extraId = extraId;
        }
        if(folders !== undefined) {
            this.folders = folders;
        }
    };

    /**
     * The EventMonitorLink object acts as a container for all information about an individual event monitor.
     * @param {EVWEB2.Service} [service=null] The service associated with this event monitor link.
     * @param {EVWEB2.EventMonitorProfile} [profile=null] The profile associated with this event monitor link.
     * @param {String} [guid=''] The GUID associated with this event monitor link.
     * @param {EVWEB2.EventMonitorLinkSource} [source=null] The source of the event monitor link.
     * @param {EVWEB2.EventMonitorLinkTarget} [target=null] The target of the event monitor link.
     * @param {Number} [priority=1] The priority of the event monitor link, in a scale between 1-10.
     * @param {Boolean} [confirm=false] Whether the user is required to manually clear the event (e.g. the event does
     * not timeout, independent of the value of the timeout parameter).
     * @param {Number} [timeout=0] The timeout duration of the event, in seconds.  Valid values are 0-60.
     * @param {String} [message=''] The message to display for this event monitor link.
     * @class
     * @constructor
     * @category Events
     */
    EVWEB2.EventMonitorLink = function(service, profile, guid, source, target, priority, confirm, timeout, message) {

        /**
         * The service associated with this event monitor link.
         * @type {EVWEB2.Service}
         */
        this.service = null;


        /**
         * The profile associated with this event monitor link.
         * @type {EVWEB2.EventMonitorProfile}
         */
        this.profile = null;

        /**
         * The GUID associated with this event monitor link.
         * @type {string}
         */
        this.guid = '';

        /**
         * The source of the event monitor link.
         * @type {EVWEB2.EventMonitorLinkSource}
         */
        this.source = null;

        /**
         * The target of the event monitor link.
         * @type {EVWEB2.EventMonitorLinkTarget}
         */
        this.target = null;

        /**
         * The priority of the event monitor link, in a scale between 1-10.
         * @type {number}
         */
        this.priority = 1;

        /**
         * Whether the user is required to manually clear the event (e.g. the event does not timeout, independent of
         * the value of the timeout parameter).
         * @type {boolean}
         */
        this.confirm = false;

        /**
         * The timeout duration of the event, in seconds.  Valid values are 0-60.
         * @type {number}
         */
        this.timeout = 0;

        /**
         * The message to display for this event monitor link.
         * @type {string}
         */
        this.message = '';

        if(service !== undefined) {
            this.service = service;
        }
        if(profile !== undefined) {
            this.profile = profile;
        }
        if(guid !== undefined) {
            this.guid = guid;
        }
        if(source !== undefined) {
            this.source = source;
        }
        if(target !== undefined) {
            this.target = target;
        }
        if(priority !== undefined) {
            this.priority = priority;
        }
        if(confirm !== undefined) {
            this.confirm = confirm;
        }
        if(timeout !== undefined) {
            this.timeout = timeout;
        }
        if(message !== undefined) {
            this.message = message;
        }

        /**
         * Updates the values of this event monitor link on the server.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance.
         */
        this.applyUpdate = function(callback) {
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var response = new EVWEB2.ResponseStatus(data.success, data.errorText);
                callback(response);
            };


            // Populate the parameters
            var params = {
                guid: this.guid,
                priority: this.priority,
                confirm: this.confirm,
                timeout: this.timeout,
                message: this.message
            };
            if(this.source !== null) {
                params.eventSourceId = this.source.id;
                params.eventSourceServer = this.source.server;
                params.eventSourceType = this.source.type;
                params.eventSourceExtra = this.source.extraId;
                params.eventSourceAny = this.source.any;
            }
            else {
                params.eventSourceServer = this.target.server;
                params.eventSourceType = EVWEB2.EventMonitorLinkSourceTypes.None;
            }
            if(this.target !== null) {
                params.eventTargetId = this.target.value;
                params.eventTargetServer = this.target.server;
                params.eventTargetType = this.target.type;
                params.eventTargetExtra = this.target.extraId;
                params.eventTargetFolderName = this.target.folders;
            }
            else {
                params.eventTargetServer = this.source.server;
                params.eventTargetType = EVWEB2.EventMonitorLinkTargetTypes.None;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                type: 'PUT',
                url: this.service.url() + EVWEB2.urls.eventMonitoring + '/' + this.profile.name,
                traditional: true,
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };
    };

    /**
     * The EventMonitorProfile object acts as a container for all information about an event monitoring profile.
     * @param {EVWEB2.Service} [service=null] The service associated with this event monitor link.
     * @param {String} [name=''] The name of this profile.
     * @param {EVWEB2.EventMonitorProfileTypes} [type=EVWEB2.EventMonitorProfileTypes.unknown] The type of this profile.
     * @param {String} [description=''] The description of this profile.
     * @param {Boolean} [showEventsList=false] Whether to show the events list on triggering of a link.
     * @param {Boolean} [showNewest=false] Whether to show the newest events.
     * @param {EVWEB2.EventMonitorLink[]} [events=[]] The event monitoring links associated with this profile.
     * @class
     * @constructor
     * @category Events
     */
    EVWEB2.EventMonitorProfile = function(service, name, type, description, showEventsList, showNewest, events) {

        /**
         * The service associated with this event monitor link.
         * @type {EVWEB2.Service}
         */
        this.service = null;

        /**
         * The name of this profile.
         * @type {string}
         */
        this.name = '';

        /**
         * The type of this profile
         * @type {EVWEB2.EventMonitorProfileTypes}
         */
        this.type = EVWEB2.EventMonitorProfileTypes.unknown;

        /**
         * The description of this profile.
         * @type {string}
         */
        this.description = '';

        /**
         * Whether to show the events list on triggering of a link.
         * @type {boolean}
         */
        this.showEventsList = false;

        /**
         * Whether to show the newest events.
         * @type {boolean}
         */
        this.showNewest = false;

        /**
         * The event monitoring links associated with this profile.
         * @type {Array}
         */
        this.events = [];

        if(service !== undefined) {
            this.service = service;
        }
        if(name !== undefined) {
            this.name = name;
        }
        if(type !== undefined) {
            this.type = type;
        }
        if(description !== undefined) {
            this.description = description;
        }
        if(showEventsList !== undefined) {
            this.showEventsList = showEventsList;
        }
        if(showNewest !== undefined) {
            this.showNewest = showNewest;
        }
        if(events !== undefined) {
            this.events = events;
        }

        /**
         * Generates an array of all associated session IDs by checking the source and target of each event link.
         * @param {EVWEB2.EventMonitorLink[]} links The list of links to use to generate the session IDs.
         * @returns {string[]} Array of session IDs.
         * @private
         */
        var generateSessionIdList = function(links) {
            var sessionIds = [];
            $.each(links, function(index, element) {
                if(element.source !== null
                        && element.source.type !== EVWEB2.EventMonitorLinkSourceTypes.None
                        && $.inArray(element.source.server, sessionIds) === -1) {
                    sessionIds.push(element.source.server);
                }
                if(element.target !== null
                        && element.target.type !== EVWEB2.EventMonitorLinkTargetTypes.None
                        && $.inArray(element.target.server, sessionIds) === -1) {
                    sessionIds.push(element.target.server);
                }
            });

            return sessionIds;
        };

        /**
         * Checks for whether any event links associated with this profile have been triggered.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.EventMonitorLinkEvent} instances
         * describing the triggered event links that have been triggered since the last request.
         * @param {number} [duration=3] The duration in the past, in seconds, to retrieve events. Triggered events are
         * not stored for more than 1 minute, so values greater than 60 are ignored.
         */
        this.checkEventLinks = function(callback, duration) {
            var instance = this;

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var links = data.triggeredEvents.reduce(function(acc, triggeredEvent) {
                    var eventLink = $.grep(instance.events, function(event) {
                        return event.guid === triggeredEvent.guid;
                    })[0];

                    if (eventLink) {
                        acc.push(new EVWEB2.EventMonitorLinkEvent(eventLink, triggeredEvent.id, triggeredEvent.extraId));
                    }

                    return acc;
                }, []);

                var response = new EVWEB2.ResponseStatus(data.success);
                callback(response, links);
            };

            if(duration === undefined) {
                duration = 3;
            }

            // Populate the parameters
            var params = {
                s: generateSessionIdList(this.events),
                duration: duration
            };

            var settings = {
                success: onSuccess,
                error: onError,
                traditional: true,
                url: this.service.url() + EVWEB2.urls.eventMonitoring + '/' + this.name,
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Updates an event monitor profile.  Note: {@link EVWEB2.EventMonitorProfile.events} is not modified by
         * this method.  To modify the event monitor links, see the {@link EVWEB2.EventMonitorLink.update},
         * {@link EVWEB2.EventMonitorProfile.addLink}, and {@link EVWEB2.EventMonitorProfile.removeLink}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance.
         */
        this.update = function(callback) {
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var response = new EVWEB2.ResponseStatus(data.success, data.errorText);
                callback(response);
            };


            // Populate the parameters
            var params = {
                name: this.name,
                description: this.description,
                type: this.type,
                showEventsList: this.showEventsList,
                showNewestEvent: this.showNewest,
                s: generateSessionIdList(this.events)
            };

            var settings = {
                success: onSuccess,
                error: onError,
                type: 'PUT',
                traditional: true,
                url: this.service.url() + EVWEB2.urls.eventMonitoring,
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Adds an event monitor link.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance and a copy of the updated {@link EVWEB2.EventMonitorLink}
         * instance.
         * @param {EVWEB2.EventMonitorLink} link The event monitor link to add.
         */
        this.addLink = function(callback, link) {
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    callback(new EVWEB2.ResponseStatus(data.success, data.errorText));
                    return;
                }

                var updateLink = data.event;
                var source = updateLink.source;
                link.source = new EVWEB2.EventMonitorLinkSource();
                if(source !== null) {
                    link.source = new EVWEB2.EventMonitorLinkSource(source.server, source.id, source.type,
                        source.extra, source.any);
                }

                var target = updateLink.target;
                link.target = new EVWEB2.EventMonitorLinkTarget();
                if(target !== null) {
                    link.target = new EVWEB2.EventMonitorLinkTarget(target.server, target.value, target.type,
                        target.extra, target.folders);
                }

                link.guid = updateLink.guid;
                link.priority = updateLink.priority;
                link.confirm = updateLink.confirm;
                link.timeout = updateLink.timeout;
                link.message = updateLink.message;

                var response = new EVWEB2.ResponseStatus(data.success);
                callback(response, link);
            };

            // Populate the parameters
            var params = {
                eventConfirm: link.confirm,
                eventMessage: link.message,
                eventTimeout: link.timeout,
                eventPriority: link.priority
            };
            if(link.source !== null) {
                params.eventSourceId = link.source.id;
                params.eventSourceServer = link.source.server;
                params.eventSourceType = link.source.type;
                params.eventSourceExtra = link.source.extraId;
                params.eventSourceAny = link.source.any;
            }
            else {
                params.eventSourceServer = link.target.server;
                params.eventSourceType = EVWEB2.EventMonitorLinkSourceTypes.None;
            }
            if(link.target !== null) {
                params.eventTargetValue = link.target.value;
                params.eventTargetServer = link.target.server;
                params.eventTargetType = link.target.type;
                params.eventTargetExtra = link.target.extraId;
                params.eventTargetFolders = link.target.folders;
            }
            else {
                params.eventTargetServer = link.source.server;
                params.eventTargetType = EVWEB2.EventMonitorLinkTargetTypes.None;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                type: 'POST',
                url: this.service.url() + EVWEB2.urls.eventMonitoring + '/' + this.name,
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Removes an event monitor link.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance.
         * @param {EVWEB2.EventMonitorLink} link The event monitor link to remove.
         */
        this.removeLink = function(callback, link) {
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var response = new EVWEB2.ResponseStatus(data.success, data.errorText);
                callback(response);
            };


            // Populate the parameters
            var params = {
                s: generateSessionIdList([link]),
                guid: link.guid
            };


            var settings = {
                success: onSuccess,
                error: onError,
                type: 'DELETE',
                traditional: true,
                url: this.service.url() + EVWEB2.urls.eventMonitoring + '/' + this.name,
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Deletes this event monitor profile on the associated servers.
         * @param {Function} callback Callback function to be executed when the call completes. Callback is passed a
         * {@link EVWEB2.ResponseStatus} instance.
         */
        this.deleteProfile = function(callback) {
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var response = new EVWEB2.ResponseStatus(data.success, data.errorText);
                callback(response);
            };

            // Populate the parameters
            var params = {
                s: generateSessionIdList(this.events),
                name: this.name
            };


            var settings = {
                success: onSuccess,
                error: onError,
                type: 'DELETE',
                traditional: true,
                url: this.service.url() + EVWEB2.urls.eventMonitoring,
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Registers a push notification client to receive notifications for events on this profile.  Once
         * subscribed, push notifications will be sent to the client until the client unsubscribes using
         * {@link EVWEB2.EventMonitorProfile.pushNotificationUnsubscribe} or until the client is unregistered
         * using {@link EVWEB2.PushNotification.unregisterClient}.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance.
         * @param {string} clientId The client ID to update.  This value was generated in a previous call
         * to {@EVWEB2.PushNotification.registerClient}.
         * @param {EVWEB2.EventMonitorLink} link The link to receive notifications on.
         */
        this.pushNotificationSubscribe = function(callback, clientId, link) {
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var response = new EVWEB2.ResponseStatus(data.success, data.errorText);
                callback(response);
            };

            var params = {
                id: clientId,
                profile: this.name,
                guid: link.guid
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: this.service.url() + EVWEB2.urls.eventMonitoringPush,
                type: 'POST',
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Unregisters a push notification client to receive notifications for events on this profile.  Once
         * unsubscribed, push notifications will no longer be sent to the client until the client re-subscribes using
         * {@link EVWEB2.EventMonitorProfile.pushNotificationSubscribe}.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.ResponseStatus} instance.
         * @param {string} clientId The client ID to update.  This value was generated in a previous call
         * to {@EVWEB2.PushNotification.registerClient}.
         * @param {EVWEB2.EventMonitorLink} link The link to receive notifications on.
         */
        this.pushNotificationUnsubscribe = function(callback, clientId, link) {
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var response = new EVWEB2.ResponseStatus(data.success, data.errorText);
                callback(response);
            };

            var params = {
                id: clientId,
                profile: this.name,
                guid: link.guid
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: this.service.url() + EVWEB2.urls.eventMonitoringPush,
                type: 'DELETE',
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };

    };

}());
/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * Definitions for the types of push notification clients.  These values correspond to the different
     * push notification networks.
     * @enum {number}
     * @readonly
     * @category Service
     */
    EVWEB2.PushNotificationClientType = {
        /**
         * Apple Push Notification Service
         */
        APNS: 0,
        /**
         * Google Cloud Messaging
         */
        GCM: 1,
        /**
         * Microsoft Push Notification Service
         */
        MPNS: 2
        //ADM: 3
    };

    /**
     * Base container for Push Notification actions for mobile clients.  This class exposes
     * the different methods required to configure a mobile client to receive push
     * notifications from the server.
     * Note: Do not instantiate this class directly.  This functionality is exposed through
     * {@link EVWEB2.Service.pushNotification} and should be used there.
     * @param {EVWEB2.Service} [service=null] A reference to the parent service instance.
     * @class
     * @constructor
     * @category Service
     */
    EVWEB2.PushNotification = function(service) {

        /**
         * A reference to the parent service instance.
         * @type {EVWEB2.Service}
         */
        this.service = null;


        if(service !== undefined) {
            this.service = service;
        }

        /**
         * Retrieves the RSA PKCS1-OAEP public key for encrypting client tokens sent to the web
         * service. Note: This encryption only necessary when sending MPNS (Windows Phone 8)
         * tokens over unencrypted protocols and is not recommended to be used in any other
         * situations.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.Server.ResponseStatus} instance and a string of
         * the encryption key.
         */
        this.getPublicKey = function(callback) {
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var response;
                if(!data.success) {
                    response = new EVWEB2.ResponseStatus(data.success, data.errorText);
                    callback(response);
                    return;
                }

                response = new EVWEB2.ResponseStatus(true);
                callback(response, data.key);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: this.service.url() + EVWEB2.urls.pushNotification
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Registers a client to receive push notifications.  Each client must use this call to register
         * as a client at least once and use the response client ID to register for receiving individual
         * push notifications.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.Server.ResponseStatus} instance and the generated client
         * ID used in subsequent push notification functions.
         * @param {EVWEB2.PushNotificationClientType} type The type of client being registered.
         * @param {string} token The registration token of the client.  The format of each depends on the
         * device type.  Reference the vendor documentation for the push notification network on generating
         * this value.
         * @param {boolean} [encrypted=false] Whether the provided token is encrypted using RSA PKCS1-OAEP encyrption.
         * Note: This is only necessary when sending MPNS (Windows Phone 8) tokens over unencrypted protocols and is
         * not recommended to be used in any other situations.
         */
        this.registerClient = function(callback, type, token, encrypted) {
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var response;
                if(!data.success) {
                    response = new EVWEB2.ResponseStatus(data.success, data.errorText);
                    callback(response);
                    return;
                }

                response = new EVWEB2.ResponseStatus(true);
                callback(response, data.id);
            };

            var params = {
                type: type,
                token: token
            };
            if(encrypted !== undefined) {
                params.encrypted = encrypted;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: this.service.url() + EVWEB2.urls.pushNotification,
                type: 'POST',
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Updates an existing client ID with a new token.  Similar to registering a device, some push
         * notification networks provide new tokens after an error.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.Server.ResponseStatus} instance and the generated client
         * ID used in subsequent push notification functions.  Note: The client ID will be the same as
         * passed in as a parameter, it is provided here for convenience.
         * @param {string} clientId The client ID to update.  This value was generated in a previous call
         * to {@EVWEB2.PushNotification.registerClient}.
         * @param {string} newToken The new registration token of the client.  The format of each depends on the
         * device type.  Reference the vendor documentation for the push notification network on generating
         * this value.
         * @param {boolean} [encrypted=false] Whether the provided token is encrypted using RSA PKCS1-OAEP encyrption.
         * Note: This is only necessary when sending MPNS (Windows Phone 8) tokens over unencrypted protocols and is
         * not recommended to be used in any other situations.
         */
        this.updateClientToken = function(callback, clientId, newToken, encrypted) {
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var response;
                if(!data.success) {
                    response = new EVWEB2.ResponseStatus(data.success, data.errorText);
                    callback(response);
                    return;
                }

                response = new EVWEB2.ResponseStatus(true);
                callback(response, data.id);
            };

            var params = {
                id: clientId,
                newtoken: newToken
            };
            if(encrypted !== undefined) {
                params.encrypted = encrypted;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: this.service.url() + EVWEB2.urls.pushNotification,
                type: 'PUT',
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };

        /**
         * Unregisters a client from receiving push notifications.  This will remove all push notification
         * subscriptions for this device, as well as unregistering the device.  After this call, a device
         * must re-register using {@link EVWEB2.PushNotification.registerClient} before any subscriptions
         * can be made.
         * @param {Function} callback Callback function to be executed when the call completes.
         * Callback is passed a {@link EVWEB2.Server.ResponseStatus} instance.
         * @param {string} clientId The client ID to unregister.  This value was generated in a previous call
         * to {@EVWEB2.PushNotification.registerClient}.
         */
        this.unregisterClient = function(callback, clientId) {
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                var response = new EVWEB2.ResponseStatus(data.success, data.errorText);
                callback(response);
            };

            var params = {
                id: clientId
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: this.service.url() + EVWEB2.urls.pushNotification,
                type: 'DELETE',
                data: params
            };

            EVWEB2.ajax(settings, this.service);
        };
    };
}());
/*globals EVWEB2:true, uuid:true, ArrayBuffer:false, DataView:true, WebSocket:false, Blob:false*/
(function() {
    "use strict";

    /**
     * The protocol message type.
     * @enum {number}
     * @readonly
     * @deprecated Web Socket functionality has been removed from the web API in 9.6.0.
     * @category Service
     */
     var protocolMessageType = {
        publish: 1,
        published: 2,
        subscribe: 3,
        subscribed: 4,
        unsubscribe: 5,
        unsubscribed: 6
    };

    /**
     * The possible error enum values set on EVWEB2.ResponseStatus objects for websocket calls
     * @enum {number}
     * @readonly
     * @deprecated Web Socket functionality has been removed from the web API in 9.6.0.
     * @category Service
     */
    EVWEB2.websocketErrorCodes = {
        /**
         * Unknown Topic
         */
        unknownTopic: -1,
        /**
         * Unknown Subscription
         */
        unknownSubscription: -2,
        /**
         * Disabled
         */
        disabled: -3,
        /**
         * Connection Lost
         */
        connectionLost: -4,
        /**
         * Send Failed
         */
        sendFailed: -5,
        /**
         * Login Required
         */
        loginRequired: -6
    };

    /**
     * Helper method to replace the the topic string with the item ids.
     * @param {String} string The topic string.
     * @param {Array} args an array of item ids.
     * @returns {String} The formatted string
     * @internal
     */
    var formatString = function(string, args) {
        var result = string;
        var i = args.length;

        while (i--) {
            result = result.replace(new RegExp('\\{' + i + '\\}', 'gm'), args[i]);
        }
        return result;
    };

    /**
     * Format the session Id topic with the item ids passed.
     * @param {String} topic The topic string.
     * @param {Array} ids An array of either EVWEB2 types or strings.
     * @returns {String} The formatted topic
     * @internal
     */
    var formatTopic = function(topic, ids) {
        var formatStr = topic.rawTopicStr;
        var requiredTypes = topic.idTypes;
        var formattedIds = [];

        var instanceOfAny = function(obj, types) {
            for (var i=0; i < types.length; ++i){
                if (obj instanceof types[i]){
                    return true;
                }
            }
            return false;
        };

        var getId = function(obj){
            if (instanceOfAny(obj, [EVWEB2.Camera, EVWEB2.DeviceConfig, EVWEB2.Trigger])) {
                return obj.id;
            }
            // default case
            return obj.toString();
        };

        for(var i = 0; i < requiredTypes.length; ++i){
            formattedIds.push(getId(ids[i]));
        }

        return formatString(formatStr, formattedIds);
    };

    /**
     * The available EVWEB2 publish/subscribe topics
     * @type Object
     * @readonly
     */
    EVWEB2.pubSubTopic = {
        server: {
            rawTopicStr: "nvr.config.server",
            idTypes: []
        },
        serverStatus: {
            rawTopicStr: "nvr.status.server",
            idTypes: []
        },
        devices: {
            rawTopicStr: "nvr.config.devices",
            idTypes: []
        },
        cameraOsd: {
            rawTopicStr: "nvr.config.cameras.settings.osd",
            idTypes: []
        },
        users: {
            rawTopicStr: "nvr.config.users",
            idTypes: []
        },
        userGroups: {
            rawTopicStr: "nvr.config.userGroups",
            idTypes: []
        },
        cameras: {
            rawTopicStr: "nvr.config.cameras",
            idTypes: []
        },
        activeUsers: {
            rawTopicStr: "nvr.config.users.active",
            idTypes: []
        },
        triggers: {
            rawTopicStr: "nvr.status.softtriggers",
            idTypes: []
        },
        motion: {
            rawTopicStr: "nvr.status.camera.motion",
            idTypes: []
        },
        loss: {
            rawTopicStr: "nvr.status.camera.loss",
            idTypes: []
        },
        cameraConnection: {
            rawTopicStr: "nvr.status.camera.connection",
            idTypes: []
        },
        deviceConnection: {
            rawTopicStr: "nvr.status.device.connection",
            idTypes: []
        },
        plugins: {
            rawTopicStr: "nvr.config.plugins",
            idTypes: []
        },
        avgFrameSize: {
            rawTopicStr: "nvr.video.camera.{0}.stats.avg_frame_size",
            idTypes: [EVWEB2.Camera]
        },
        videoH264: {
            rawTopicStr: "nvr.video.camera.{0}.native",
            idTypes: [EVWEB2.Camera]
        },
        videoJPEG: {
            rawTopicStr: "nvr.video.camera.{0}.jpeg",
            idTypes: [EVWEB2.Camera]
        },
        securityIntegrationDevices: {
            rawTopicStr: "nvr.config.securityintegrations.devices",
            idTypes: []
        },
        securityIntegrationSensors: {
            rawTopicStr: "nvr.config.securityintegrations.sensors",
            idTypes: []
        },
        securityIntegrationSensorStatus: {
            rawTopicStr: "nvr.status.securityintegrations.sensors",
            idTypes: []
        },
        securityIntegrationDeviceConnection: {
            rawTopicStr: "nvr.status.securityintegrations.devices.connection",
            idTypes: []
        },
        associations: {
            rawTopicStr: "nvr.config.associations",
            idTypes: []
        }
    };

    /**
     * Protocol flag bitmasks
     * @type {object}
     * @internal
     */
    var protoFlags = {
        ackBitmask : 0x0001,
        bigEndianBitmask: 0x0002,
        binaryBitmask : 0x0004,
        versionBitmask: 0x00E0
    };

    /**
     * Container for protocol flags
     * @param {Boolean} [ack=false] flag to acknowledge the request
     * @param {Boolean} [binary=false] flag if the serialiation format is binary
     * @param {Boolean} [bigEndian=false] flag for endianess
     * @param {Number} [version=0] the protocol version number
     * @constructor
     * @this ProtocolFlags
     * @internal
     */
    var ProtocolFlags = function(ack, binary, bigEndian, version) {

        /**
         * Flag for acknowledgement
         * @type {boolean}
         */
        this.ack = false;

        /**
         * Flag if serialization format is binary
         * @type {boolean}
         */
        this.isBinary = false;

        /**
         * Flag if big endian
         * @type {boolean}
         */
        this.isBigEndian = false;

        /**
         * The protocol version number
         * @type {number}
         */
        this.version = 0;

        if (ack !== undefined){
            this.ack = ack;
        }
        if (binary !== undefined){
            this.isBinary = binary;
        }
        if (bigEndian !== undefined){
            this.isBigEndian = bigEndian;
        }
        if (version !== undefined){
            this.version = version;
        }

        /**
         * Retrieve the bitmask value for inclusion in header
         * @returns {number} The bitmask value
         */
        this.bitmask = function() {
            var bitmask = 0x0000;
			/* eslint-disable no-bitwise */
            bitmask |= this.ack ? protoFlags.ackBitmask : 0;
            bitmask |= this.isBinary ? protoFlags.binaryBitmask : 0;
            bitmask |= this.isBigEndian ? protoFlags.bigEndianBitmask: 0;
            bitmask |= (this.version & 0x0007) << 5;
			/* eslint-enable no-bitwise */
            return bitmask;
        };

        /**
         * Set the instance flags/values from a bitmask
         * @param {Number} bitmask the bitmask value to set flags from
         */
        this.setFromBitmask = function(bitmask) {
			/* eslint-disable no-bitwise */
            this.ack = Boolean(bitmask & protoFlags.ackBitmask);
            this.isBinary = Boolean(bitmask & protoFlags.binaryBitmask);
            this.isBigEndian = Boolean(bitmask & protoFlags.bigEndianBitmask);
            this.version = (bitmask & protoFlags.versionBitmask) >> 5;
			/* eslint-enable no-bitwise */
        };
    };

    /**
     * Container for header information for protocol messages
     * @param requestId
     * @param topic
     * @param messageType
     * @param flags
     * @constructor
     * @this ProtocolHeader
     * @internal
     */
    var ProtocolHeader = function(requestId, topic, messageType, flags){

        /**
         * The request ID of the message.
         * @type String
         */
        this.requestId = requestId;

        /**
         * The topic.
         * @type String
         */
        this.topic = topic;

        /**
         * The protocol message type
         * @type {number}
         */
        this.messageType = messageType;

        /**
         * The protocol options/flags
         * @type {ProtocolFlags}
         */
        this.flags = flags;

        this.marshal = function() {
            var hdr = this;
            return {
                request: hdr.messageType,
                rid: hdr.requestId,
                topic: hdr.topic,
                flags: hdr.flags.bitmask(),
                // TODO add in JS support for sub protocols
                subProtocol: 0x00,
                subProtocolFlags: 0x00
            };
        };
    };

    /**
     * PubSub 'Unsubscribe' protocol message, sent to the server to unsubscribe completely from a topic.
     * @param {ProtocolHeader} header The header for this request.
     * @param {String} subscriptionId The subscription id to unsubscribe.
     * @internal
     * @constructor
     * @this UnsubscribeMessage
     */
    var UnsubscribeMessage = function(header, subscriptionId) {
        // ensure the header is correct
        header.messageType = protocolMessageType.unsubscribe;

        /**
         * The message header
         * @type {ProtocolHeader}
         */
        this.hdr = header;

        /**
         * The subscription id
         * @type {string}
         */
        this.subscriptionId = subscriptionId;

        this.marshal = function() {
            var message = this;

            return {
                'header': message.hdr.marshal(),
                'payload': {
                    'subscriptionId': message.subscriptionId
                }
            };
        };
    };

    /**
     * Pending un-subscribe request object, used to hold state in-between unsubscribe and server acknowledgement
     * @param {EVWEB2.Subscription} subscription The subscription to unsubscribe
     * @param {$.Deferred} onAcknowledge The deferred to resolve when the request is completed
     * @private
     * @constructor
     * @this UnsubscribeRequest
     */
    var UnsubscribeRequest = function(subscription, onAcknowledge) {

        /**
         * The subscription to unsubscribe
         * @type {EVWEB2.Subscription}
         */
        this.subscription = subscription;

        /**
         * The deferred object to resolve when unsubscribed completely
         * @type {$.Deferred}
         */
        this.onAcknowledge = onAcknowledge;

    };

    /**
     * PubSub 'Subscribe' protocol message, sent to the server to request a new subscription be made
     * @param {ProtocolHeader} header The header for this request
     * @param {String} [requestedSid=''] Request a particular subscription ID from the server
     * @this SubscribeMessage
     * @class
     */
    var SubscribeMessage = function(header, requestedSid) {
        // ensure the header is correct
        header.messageType = protocolMessageType.subscribe;

        /**
         * The message header
         * @type {ProtocolHeader}
         */
        this.hdr = header;

        /**
         * A specific subscription id to request the server use
         * @type {string}
         */
        this.requestedSid = '';

        if(requestedSid !== undefined && requestedSid !== '') {
            this.requestedSid = requestedSid;
        }

        this.marshal = function() {
            var message = this;
            var options = {
            };

            if(message.requestedSid !== ''){
                options['requestedSID'] = message.requestedSid;
            }

            return {
                'header': message.hdr.marshal(),
                'payload': {
                    'options': options
                }
            };
        };
    };

    /**
     * JSON serializer
     * @constructor
     * @deprecated Web Socket functionality has been removed from the web API in 9.6.0.
     * @category Service
     */
    EVWEB2.JsonSerializer = function() {

        /**
         * Flag for protocol flags
         * @type {boolean}
         */
        this.isBinary = false;

        this.serialize = function(data) {
            return JSON.stringify(data);
        };

        this.unserialize = function(payload) {
            return JSON.parse(payload);
        };
    };

    /**
     * Composite Binary serializer. The composite serializer includes a binary header with a
     * serialized payload and an optional binary payload.
     *
     * Wire Format of a composite serialized message:
     *
     *  0...2...........7...............15.............23...............31
     *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *  | protoMsgType  | uint16_t flags       VVVSSBEA | SubProtocol   |
     *  +---------------+---------------+-------------------------------+
     *  |    spf flags  | Reserved      |                               |
     *  +---------------+---------------+                               |
     *  |                                                               |
     *  |                           UUID  requestId   (16 bytes)        |
     *  |                                                               |
     *  |                                ---------------+---------------+
     *  |                               |   uint16_t  topic length      |
     *  +---------------+---------------+---------------+---------------+
     *  |     uint32_t      dataLength                                  |
     *  +---------------+---------------+---------------+---------------+
     *  |     uint32_t      blobLength                                  |
     *  +---------------+---------------+---------------+---------------+
     *  |     String        topic   (ascii)                             |
     *  +---------------+---------------+---------------+---------------+
     *  |     Serialized Payload                                        |
     *  +---------------+---------------+---------------+---------------+
     *  |     Binary payload                                            |
     *  +---------------+---------------+---------------+---------------+
     *
     * @constructor
     * @deprecated Web Socket functionality has been removed from the web API in 9.6.0.
     * @category Service
     */
    EVWEB2.CompositeSerializer = function () {

        /**
         * Flag for protocol flags / sendMessage
         * @type {boolean}
         */
        this.isBinary = true;

        var jsonSerializer = new EVWEB2.JsonSerializer();
        var serializerMap = {
            0x00: jsonSerializer
        };

        /**
         * Get the serializer from the flag bitmask that should be used to
         * decode any serialized content
         * @param {number} flags The bitmask
         * @returns {Object} The decoded object
         */
        var serializer_from_bitmask = function (flags) {
            /* eslint-disable no-bitwise */
            var stype = (flags & 0x18) >> 3;
            /* eslint-enable no-bitwise */
            var mappedSerializer = serializerMap[stype];
            return mappedSerializer === undefined ? jsonSerializer : mappedSerializer;
        };

        /**
         * Encapsulates the logic to encode a marshalled message to a binary buffer
         * @private
         * @constructor
         * @this MessageEncoder
         */
        var MessageEncoder = function () {

            /**
             * The current view offset
             * @type {number}
             */
            this.offset = 0;

            /**
             * Write the bytes of a string to a data view. Expected to be ASCII strings only. The
             * encoder offset is advanced by the string length.
             * @param {DataView} view The view object to write the string to
             * @param {String} str The string to encode as bytes into the view
             */
            this.writeString = function (view, str) {
                var encoder = this;
                var offset = encoder.offset;
                for (var i = 0; i < str.length; ++i, ++offset) {
                    var byte = str.charCodeAt(i);
                    view.setUint8(offset, byte);
                }
                encoder.offset = offset;
            };

            /**
             * Write the bytes of a UUID to a data view. The encoder offset is advanced by
             * 16 (the byte length of a UUID)
             * @param {DataView} view the view object to write UUID bytes to
             * @param {String} uuidStr The hex UUID string in 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' format
             */
            this.writeUUID = function (view, uuidStr) {
                var encoder = this;
                var bytes = uuid.parse(uuidStr);
                for (var i = 0; i < bytes.length; ++i) {
                    view.setUint8(encoder.offset, bytes[i]);
                    encoder.offset += 1;
                }
            };

            /**
             * Encode the header information into a data view. The enocder offset is advanced by the
             * fixed header length + topic length
             * @param {DataView} view the dataview to encode the header to
             * @param {Object} header the marshalled header information
             * @param {Number} dataLength The length of the (serialized) data
             * @param {Number} blobLength The length of any binary data
             */
            this.writeHeader = function (view, header, dataLength, blobLength) {
                var encoder = this;
                view.setUint8(encoder.offset++, header.request);
                view.setUint16(encoder.offset, header.flags);
                encoder.offset += 2;

                // TODO add in JS support for subprotocols
                view.setUint8(encoder.offset++, 0);
                view.setUint8(encoder.offset++, 0);

                // reserved byte
                view.setUint8(encoder.offset++, 0);

                encoder.writeUUID(view, header.rid);

                var topicLength = header.topic.length;
                view.setUint16(encoder.offset, topicLength);
                encoder.offset += 2;

                view.setUint32(encoder.offset, dataLength);
                encoder.offset += 4;

                view.setUint32(encoder.offset, blobLength);
                encoder.offset += 4;

                encoder.writeString(view, header.topic);
            };

            /**
             * Encode a marshalled PubSub message to an array buffer
             * @param {Object} value instance of a marshalled pubsub message
             * @returns {ArrayBuffer} The encoded array buffer
             */
            this.encode = function (value) {
                var encoder = this;
                var fixedHeaderLength = 32;
                var serializer = serializer_from_bitmask(value.header.flags);
                var serializedContent = serializer.serialize(value.payload);
                var header = value.header;
                var blob = '';
                if (value.blob !== undefined && value.blob !== '') {
                    blob = value.blob;
                }

                var dataLength = 0, blobLength = 0;
                if (serializer.isBinary){
                    dataLength = serializedContent.byteLength;
                    blobLength = blob.byteLength;
                }else{
                    dataLength = serializedContent.length;
                    blobLength = blob.length;
                }

                var bufsize = fixedHeaderLength + header.topic.length + dataLength + blobLength;
                var buffer = new ArrayBuffer(bufsize);
                var view = new DataView(buffer);
                encoder.writeHeader(view, header, dataLength, blobLength);

                if(serializer.isBinary){
                    // TODO join array buffers (assumes arraybuffer is returned by binary serializers 'serialize' method)
                }else{
                    encoder.writeString(view, serializedContent);
                    encoder.writeString(view, blob);
                }

                return buffer;
            };
        };

        /**
         * Encapsulates the logic to decode a single pubsub message serialized in the expected format.
         * @param {DataView} view the dataview around the received array buffer to be decoded
         * @param {Number} [offset=0] The offset into the view to start decoding
         * @private
         * @constructor
         * @this MessageDecoder
         */
        var MessageDecoder = function (view, offset) {
            this.view = view;
            this.offset = offset || 0;

            /**
             * Read a string from the view. ASCII only. The decoder offset is advanced by the
             * string length
             * @param {Number} offset the offset into the view to begin reading a string
             * @param {Number} length the expected string length (number of bytes to read)
             * @returns {string} The read string
             */
            this.readString = function (offset, length) {
                var decoder = this;
                var string = "";
                for (var i = offset, end = offset + length; i < end; ++i) {
                    // UTF8??
                    var byte = decoder.view.getUint8(i);
                    string += String.fromCharCode(byte);
                    decoder.offset += 1;
                }
                return string;
            };

            /**
             * Read the bytes of a UUID and reconstruct into the hex string format
             * e.g. 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'. The decoder offset is advanced
             * by 16 bytes.
             * @param {Number} offset the offset into the view to begin reading UUID bytes
             * @returns {String} The UUID
             */
            this.readUUID = function (offset) {
                var decoder = this;
                var uuidLength = 16;
                var buf = new Array(uuidLength);
                for (var i = offset, end = offset + uuidLength; i < end; ++i) {
                    buf[i - offset] = decoder.view.getUint8(i);
                }

                decoder.offset += uuidLength;
                return uuid.unparse(buf);
            };

            /**
             * Read a PubSub message header and construct an equivalent marshalled header
             * object. The decoder offset is advanced by the fixed header length + the
             * topic string length.
             * @returns {Object} A marshalled PubSub message header with additional
             * 'dataLength' and 'blobLength' attributes for further processing.
             */
            this.readHeader = function() {
                var decoder = this;
                var header = {
                    request: 0,
                    rid: '',
                    flags: 0,
                    topic: '',
                    subProtocol: 0,
                    subProtocolFlags: 0,
                    dataLength: 0,  // these keys are added for further processing
                    blobLength: 0
                };

                header.request = view.getUint8(decoder.offset++);
                header.flags = view.getUint16(decoder.offset);
                decoder.offset += 2;

                header.subProtocol = view.getUint8(decoder.offset++);
                header.subProtocolFlags = view.getUint8(decoder.offset++);

                // skip the reserved byte
                decoder.offset++;

                header.rid = decoder.readUUID(decoder.offset);
                var topicLength = view.getUint16(decoder.offset);
                decoder.offset += 2;

                header.dataLength = view.getUint32(decoder.offset);
                decoder.offset += 4;

                header.blobLength = view.getUint32(decoder.offset);
                decoder.offset += 4;

                header.topic = decoder.readString(decoder.offset, topicLength);
                return header;
            };


            /**
             * Parse a PubSub message into its marshalled form
             * @returns {{header: Object, payload: Object}} The pubsub message
             */
            this.parse = function () {
                var decoder = this;
                var header = decoder.readHeader();

                var serializer = serializer_from_bitmask(header.flags);

                var serializedContent;
                if (serializer.isBinary){
                    serializedContent = decoder.view.buffer.slice(decoder.offset, decoder.offset + header.dataLength);
                    decoder.offset += header.dataLength;
                } else {
                    serializedContent = decoder.readString(decoder.offset, header.dataLength);
                }
                var content = serializer.unserialize(serializedContent);

                var obj = {
                    header: header,
                    payload: content
                };

                var blob;
                if (header.blobLength > 0){
                    blob = view.buffer.slice(decoder.offset, decoder.offset + header.blobLength);
                    decoder.offset += header.blobLength;
                    obj['payload']['data']['blob'] = blob;
                }

                // remove extra properties
                delete obj.header['blobLength'];
                delete obj.header['dataLength'];

                return obj;
            };
        };

        /**
         * Serialize a marshalled object to a binary buffer
         * @param {Object} data The marshalled object
         * @returns {ArrayBuffer} The serialized buffer
         */
        this.serialize = function (data) {
            var encoder = new MessageEncoder();
            return encoder.encode(data);
        };

        /**
         * Unserialize a binary buffer to a marshalled pubsub object
         * @param {ArrayBuffer} buf The binary buffer
         * @returns {Object} Marshalled pubsub object
         */
        this.unserialize = function (buf) {
            var view = new DataView(buf);
            var decoder = new MessageDecoder(view);
            return decoder.parse();
        };
    };


    /**
     * Internal callback for topic 'triggers'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onSoftTriggerUpdated = function(subscriptions, data){
        var args = data.args;
        var triggerId = args[0];
        var name = args[1];
        var state = args[2];

        var trigger = new EVWEB2.Trigger(subscriptions[0].server, triggerId, name, state);
        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], trigger);
        }
    };

    /**
     * Internal callback for topic 'activeUsers'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onActiveUsersChanged = function(subscriptions, data){
        var args = data.args;
        var users = args[0];

        var usersList = $.map(users, function(element) {
            return new EVWEB2.SystemUsageInfo(element.username, element.level, element.address,
                element.streams, element.audit, element.instanceName);
        });

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], usersList);
        }
    };

    /**
     * Internal callback for topic 'plugins'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onPluginsChanged = function(subscriptions, data) {
        var args = data.args;
        var plugins = args[0];

        var pluginsList = $.map(plugins, function(element) {
            return new EVWEB2.SystemPluginInfo(element.name, element.filename, element.version, element.isOpen,
                                                 element.openCode);
        });
        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], pluginsList);
        }
    };

    /**
     * Internal callback for topic 'motion'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onMotionChanged = function(subscriptions, data){
        var args = data.args;
        var cameraId = args[0];
        var hasMotion = args[1];

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], cameraId, hasMotion);
        }
    };

    /**
     * Internal callback for topic 'loss'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onLossChanged = function(subscriptions, data){
        var args = data.args;
        var cameraId = args[0];
        var state = args[1];

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], cameraId, state);
        }
    };

    /**
     * Internal callback for topic 'cameraConnection' and 'deviceConnection'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onConnectionChanged = function(subscriptions, data){
        var args = data.args;
        var uniqueId = args[0];
        var state = args[1];

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], uniqueId, state);
        }
    };

    var responseToCameraInstance = function(response, server) {
        var disabled = response.disabled !== 0;
        var video = response.state === 0;

        var ptz = response.ptz === 1;
        var ptzType = EVWEB2.ptzTypes.none;
        if(ptz) {
            ptzType = EVWEB2.ptzTypes.standard;
        }

        if(response.id === undefined) {
            // Generate the ID from the plugin, interface, device, and context IDs.
            response.id = EVWEB2.util.pidToCameraId(response.p, response.i, response.d, response.ctx);
        }

        var resolution;
        if(response.resolution !== undefined) {
            resolution = new EVWEB2.CameraResolution(response.resolution.width, response.resolution.height);
        }

        return new EVWEB2.Camera(server, response.id, response.ctx, response.name, ptz, disabled, video,
            response.OSD, ptzType, response.digitalPtz, response.formats, resolution, response.quality,
            response.frameRate);
    };


    /**
     * Internal callback for topic 'cameras'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onCameraListChanged = function(subscriptions, data){
        var args = data.args;
        var resultList = args[0];

        var server = subscriptions[0].server;
        var cameraList = $.map(resultList, function(element) {
            return responseToCameraInstance(element, server);
        });

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], cameraList);
        }
    };

    /**
     * Internal callback for topic 'users'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onUserListChanged = function(subscriptions, data){
        var args = data.args;
        var usersList = args[0];

        var server = subscriptions[0].server;

        var users = $.map(usersList, function(element) {
            return new EVWEB2.User(server, element.name, element.groupName, element.accountType, element.isOrphaned);
        });

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], users);
        }
    };

    /**
     * Internal callback for topic 'userGroups'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onUserGroupListChanged = function(subscriptions, data){
        var args = data.args;
        var customGroupsList = args[0];

        var customUserGroups = $.map(customGroupsList, function(element) {
            var accessLevel = element.role;

            var permissions = EVWEB2.util.internal.processUserGroupPermissions(element.permissions);

            var priorities = $.map(element.priorities, function(elem) {
                return new EVWEB2.UserGroupPriority(elem.priority, elem.value);
            });

            var customGroupPermissions = new EVWEB2.CustomGroupPermissions(element.cameras, element.audios,
                element.serials, element.softTriggers);

            return new EVWEB2.UserGroup(element.name, accessLevel, permissions, priorities, element.guid,
                customGroupPermissions);
        });

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], customUserGroups);
        }
    };

    /**
     * Internal callback for topic 'devices'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onDeviceListChanged = function(subscriptions, data){
        var args = data.args;
        var devices = args[0];

        var server = subscriptions[0].server;
        var devicesList = $.map(devices, function(element) {
            var cameraInfo = $.map(element.cameras, function(element) {
                return new EVWEB2.DeviceConfigCameraInfo(element.cameraId.toString(),
                    element.parentCameraId.toString(), element.name, element.isPrimary);
            });

            return new EVWEB2.DeviceConfig(element.id, element.name, element.host, element.port, element.type,
                element.model, element.macAddress, element.firmware, element.enabled, element.isConnected,
                cameraInfo, element.user, server, element.serial);
        });

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], devicesList);
        }
    };

    /**
     * Internal callback for topic 'cameraOsd'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onCameraOsdChanged = function(subscriptions, data){
        var args = data.args;
        var cameraInfos = args[0];
        var osdInfos = $.map(cameraInfos, function(element){
            var osdInfo = EVWEB2.util.internal.formatOsdInfo(element.osdInfo);
            return {
                osdInfo: osdInfo,
                cameraId: element.cameraId
            };
        });

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], osdInfos);
        }
    };

    /**
     * Internal callback for topic 'server'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onServersUpdated = function(subscriptions, data){
        var args = data.args;
        var element = args[0];

        var serverId = element.id;
        if(serverId !== undefined) {
            serverId = serverId.toString();
        }

        var serverInfo = EVWEB2.util.internal.processServerDetails(element);
        var licenseInfo = EVWEB2.util.internal.processServerLicense(element);

        var customGroupPermissions;
        var userGroup, passthroughGroup;

        if (element.group !== undefined && element.group !== null) {
            var group = element.group;

            var groupPermissions = EVWEB2.util.internal.processUserGroupPermissions(group.permissions);

            customGroupPermissions = new EVWEB2.CustomGroupPermissions(group.cameras, group.audios,
                group.serials, group.softTriggers);
            userGroup = new EVWEB2.UserGroup(group.name, group.role, groupPermissions, group.priorities,
                group.guid, customGroupPermissions);

        }
        else {
            userGroup = EVWEB2.util.processServerPermissions(element);
        }

        if (!element.login){
            passthroughGroup = userGroup;
            userGroup = undefined;
        }

        var service = subscriptions[0].server.service;
        var sessionId = subscriptions[0].server.sessionId;
        var server = new EVWEB2.Server(service, element.name, serverId, element.login, element.restricted,
            sessionId, undefined, undefined, serverInfo, licenseInfo, userGroup, passthroughGroup);

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], server);
        }
    };

    /**
     * Internal callback for topic 'serverStatus'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onServerStatusChanged = function(subscriptions, data){
        var args = data.args;
        var status = args[0];

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], status);
        }
    };

    /**
     * Internal callback for topic 'avgFrameSize'
     * @param {Array} subscriptions The list of available subscriptions for this topic.
     * @param {Object} data The data received for this topic.
     */
    var onAvgFrameSize = function(subscriptions, data){
        var args = data.args;
        var cameraId = args[0].toString();
        var frameSize = args[1];

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], cameraId, frameSize);
        }
    };

    var onH264Frame = function(subscriptions, data){
        var args = data.args;
        var cameraId = args[0].toString();
        var isIframe = args[1];
        var timestamp = EVWEB2.util.IETF2Date(args[2]);
        var flags = args[3];

        var frameData = data.blob;

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], cameraId, frameData, isIframe, timestamp, flags);
        }
    };

    var onJPEGFrame = function(subscriptions, data){
        var args = data.args;
        var cameraId = args[0].toString();
        var timestamp = EVWEB2.util.IETF2Date(args[1]);
        var flags = args[2];
        var frameData = data.blob;

        //var view = new Uint8Array(frameData);
        var blob = new Blob([frameData], {type: 'image/jpeg'});

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], cameraId, blob, timestamp, flags);
        }
    };

    var onAccessControlDevicesUpdated = function(subscriptions, data){
        var server = subscriptions[0].server;
        var rawDevices = data.args[0];

        // Process the devices
        var devices = $.map(rawDevices, function(element) {
            return new EVWEB2.SecurityIntegrationsDevice(server, element.id, element.name, element.host, element.port,
                element.type, element.enabled, element.connectionStatus, element.firmware, element.serial,
                element.user, element.auth);
        });

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], devices);
        }

    };

    var onAccessControlSensorsUpdated = function(subscriptions, data){
        var deviceId = data.args[0];
        var rawSensors = data.args[1];

        // Process the sensors
        var sensors = $.map(rawSensors, function(element) {
            var timestamp = element.statusTimestamp ?
                EVWEB2.util.IETF2Date(element.statusTimestamp) : undefined;

            var persistedStatuses = element.persistedStatus ? element.persistedStatus.map(function(obj){
                obj.statusTimestamp = EVWEB2.util.IETF2Date(obj.statusTimestamp);
                return obj;
            }) : undefined;

            return new EVWEB2.SecurityIntegrationsDeviceSensor(undefined, element.sensorId, element.name, element.type,
                element.direction, element.availableActions, element.inputs, element.defaultActionTimeout,
                element.maxActionTimeout, element.status, element.alarm,
                timestamp, element.statusMessage, persistedStatuses);
        });

        for (var i = 0; i < subscriptions.length; ++i){
            // We do not have a reference to the device object for each sensor,
            // user is required to lookup the device object and set it themselves.
            subscriptions[i].externalCallback(subscriptions[i], deviceId, sensors);
        }
    };

    var onAccessControlSensorStatusChanged = function(subscriptions, data){
        var sensorStatusObj = data.args[0];
        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], sensorStatusObj);
        }
    };

    var onAccessControlDeviceConnectionChanged = function(subscriptions, data){
        var deviceId = data.args[0];
        var deviceStatus = data.args[1];

        for (var i = 0; i < subscriptions.length; ++i){
            subscriptions[i].externalCallback(subscriptions[i], deviceId, deviceStatus);
        }
    };


    var onAssociationsUpdated = function(subscriptions, data){
        var args = data.args;
        var associationsByCameraId = {};

        $.each(args[0], function(index, raw){
            // Process the associations
            var associationItems = $.map(raw.items, function(element) {
                return new EVWEB2.AssociationItem(element.id, element.type, element.position, element.statusOnly,
                    element.extra);
            });

            var fontInfo = new EVWEB2.FontInfo(raw.fontName, raw.fontSize, raw.fontStyle,
                raw.fontColor, raw.fontFamily, raw.fontWeight);

            var association = new EVWEB2.Association(subscriptions[0].server, undefined, raw.guid, associationItems,
                raw.label, raw.overlayStyle, raw.position, raw.backgroundColor,
                raw.opacity, fontInfo);

            associationsByCameraId[raw.cameraId] = association;
        });

        for (var i = 0; i < subscriptions.length; ++i){

            for(var key in associationsByCameraId){
                if (associationsByCameraId.hasOwnProperty(key)) {
                    var cameraId = parseInt(key, 10);
                    // We do not have a reference to the camera objects for each association,
                    // user is required to lookup the camera object and set it themselves.
                    subscriptions[i].externalCallback(subscriptions[i], cameraId, associationsByCameraId[cameraId]);
                }
            }
        }
    };

    /**
     * The internal callback functions associated with each topic.
     * @private
     * @type Object
     */
    var internalCallbacks = {
        'nvr.status.softtriggers': onSoftTriggerUpdated,
        'nvr.status.camera.motion': onMotionChanged,
        'nvr.status.camera.loss': onLossChanged,
        'nvr.config.users.active': onActiveUsersChanged,
        'nvr.status.camera.connection': onConnectionChanged,
        'nvr.status.device.connection': onConnectionChanged,
        'nvr.config.cameras': onCameraListChanged,
        'nvr.config.users': onUserListChanged,
        'nvr.config.userGroups': onUserGroupListChanged,
        'nvr.config.devices': onDeviceListChanged,
        'nvr.config.cameras.settings.osd': onCameraOsdChanged,
        'nvr.config.plugins': onPluginsChanged,
        'nvr.config.server': onServersUpdated,
        'nvr.status.server': onServerStatusChanged,
        'nvr.video.camera.{0}.stats.avg_frame_size': onAvgFrameSize,
        'nvr.video.camera.{0}.native': onH264Frame,
        'nvr.video.camera.{0}.jpeg': onJPEGFrame,
        'nvr.config.securityintegrations.devices': onAccessControlDevicesUpdated,
        'nvr.config.securityintegrations.sensors': onAccessControlSensorsUpdated,
        'nvr.status.securityintegrations.sensors': onAccessControlSensorStatusChanged,
        'nvr.status.securityintegrations.devices.connection': onAccessControlDeviceConnectionChanged,
        'nvr.config.associations': onAssociationsUpdated
    };

    /**
     * Pending subscribe request object, used to hold state in-between subscribe and server acknowledgement
     * @param {String} requestId The unique ID of the request.
     * @param {EVWEB2.Server} server The server associated with the request.
     * @param {String} topic The topic associated with the request.
     * @param {Function} internalCallback The internal callback function.
     * @param {Function} externalCallback The external callback function.
     * @param {$.Deferred} onReply The callback to call when a subscription is acknowledged
     * @param {Boolean} [acknowledge=false] Flag if the user wants the subscribe request acknowledged
     * @class
     * @this SubscribeRequest
     */
    var SubscribeRequest = function(requestId, server, topic, internalCallback, externalCallback, onReply,
                                    acknowledge) {
        /**
         * Unique request ID.
         * @type {String}
         */
        this.requestId = requestId;

        /**
         * Server instance associated with the request.
         * @type {EVWEB2.Server}
         */
        this.server = server;

        /**
         * Topic of the subscription request.
         * @type {String}
         */
        this.topic = topic;

        /**
         * The internal callback function.
         * @function
         */
        this.internalCallback = internalCallback;

        /**
         * The external callback function.
         * @function
         */
        this.externalCallback = externalCallback;

        /**
         * The callback to call when the subscription is successfully made/acknowledged.
         * @type {$.Deferred}
         */
        this.onReply = onReply;

        /**
         * Flag for if the subscription should be acknowledged once made.
         * @type {boolean}
         */
        this.acknowledge = false;

        // Assign constructor values
        if(acknowledge !== undefined){
            this.acknowledge = acknowledge;
        }
    };


    /**
     * The InternalSubscription is a placeholder for real subscriptions. It stores the internal callbacks
     * that pre-process the data before delivering the final published event (as EVWEB2 types).
     * @param {Function} handler The internal callback function called when an event is published to the topic
     * @param {String} topic The topic name associated with the internal callback
     * @private
     * @constructor
     * @this InternalSubscription
     */
    var InternalSubscription = function(handler, topic){
        /**
         * The internal callback function
         * @function
         */
        this.fn = handler;

        /**
         * The topic subscribed to
         * @type {String}
         */
        this.topic = topic;

        /**
         * The array of active subscriptions that are associated with this internal subscription
         * @type {EVWEB2.Subscription[]}
         */
        this.subscriptions = [];
    };


    /**
     * The Subscription object represents an active subscription.
     * @param {String} subscriptionId The unique ID of the subscription.
     * @param {EVWEB2.Server} server The server associated with the subscription.
     * @param {String} topic The topic associated with the subscription.
     * @param {function} externalCallback The external callback function
     * @class
     * @deprecated Web Socket functionality has been removed from the web API in 9.6.0.
     * @category Service
     */
    EVWEB2.Subscription = function(subscriptionId, server, topic, externalCallback) {
        /**
         * The unique ID of the subscription.
         * @type {String}
         */
        this.subscriptionId = '';

        /**
         * Server instance associated with the subscription.
         * @type {EVWEB2.Server}
         */
        this.server = null;

        /**
         * Topic of the subscription.
         * @type {String}
         */
        this.topic = '';

        /**
         * The external callback function.
         * @type {Function}
         */
        this.externalCallback = $.noop;

        /**
         * Flag that indicates the subscription state, an active subscription will receive publications
         * @type {boolean}
         */
        this.isActive = true;

        // Assign constructor values
        if(subscriptionId !== undefined) {
            this.subscriptionId = subscriptionId;
        }
        if(server !== undefined) {
            this.server = server;
        }
        if(topic !== undefined) {
            this.topic = topic;
        }
        if(externalCallback !== undefined) {
            this.externalCallback = externalCallback;
        }
    };

    /**
     * Generate a unique random id for protocol requests
     * @returns {String} The unique ID
     * @private
     */
    var generateId = function() {
        return uuid.v4();
    };

    /**
     * The available websocket handler states
     * @private
     * @enum {number}
     */
    var wsStates = {
        /**
         * Initializing
         */
        initializing: 0,
        /**
         * Connected
         */
        connected: 1,
        /**
         * Reconnecting
         */
        reconnecting: 2
    };

    /**
     * The WebsocketConfig object is a container for all configuration information related to the websocket connection.
     * @param {String} [host=''] The websocket host url
     * @param {Number} [port=0] The websocket port
     * @param {Number} [sslPort=0] The websocket SSL port (only valid if the service is configured to use SSL)
     * @class
     * @deprecated Web Socket functionality has been removed from the web API in 9.6.0.
     * @category Service
     */
    EVWEB2.WebsocketConfig = function(host, port, sslPort) {
        /**
         * The host url the websocket is configured to connect to
         * @type {string}
         */
        this.host = '';

        /**
         * The port the websocket is configured to connect to
         * @type {number}
         */
        this.port = 0;

        /**
         * The SSL port the websocket is configured to connect to
         * @type {number}
         */
        this.sslPort = 0;

        if (host !== undefined){
            var beginIdx = 0, endIdx = host.length;
            if (host.slice(0, 7) === "http://"){
                beginIdx = 7;
            }else if (host.slice(0, 8) === "https://"){
                beginIdx = 8;
            }
            if(host.slice(-1) === "/"){
                --endIdx;
            }

            this.host = host.slice(beginIdx, endIdx);

            if(this.host === '') {
                this.host = window.location.hostname;
            }
        }

        if (port !== undefined){
            this.port = port;
        }

        if (sslPort !== undefined){
            this.sslPort = sslPort;
        }

        /**
         * @returns {string} The formatted URL used to connect a WebSocket instance.
         */
        this.getUrl = function() {
            if (window.location.protocol === "https:") {
                return "wss://" + this.host + ":" + this.sslPort;
            } else {
                return "ws://" + this.host + ":" + this.port;
            }
        };
    };

    /**
     * Enum of type of connection events for websockets.
     * @enum {number}
     * @readonly
     * @deprecated Web Socket functionality has been removed from the web API in 9.6.0.
     * @category Service
     */
    EVWEB2.connectionEvent = {
        /**
         * Open
         */
        open: 0,
        /**
         * Timed out
         */
        timedOut: 1
    };

    /**
     * Enum values denoting state of the websocket connection
     * @enum {number}
     * @readonly
     */
    var readyStates = {
        connecting: 0,
        open: 1,
        closing: 2,
        closed: 3
    };

    /**
     * The WebSocketHandler object receives all websocket communication from the service end. It initiates a connection
     * and subscribes to incoming messages from the service. It then parses these messages to known
     * EVWEB2 types and publishes them.
     * @param {EVWEB2.Service} [service=null] The service instance.
     * @class
     * @deprecated Web Socket functionality has been removed from the web API in 9.6.0.
     * @category Service
     */
    EVWEB2.WebSocketHandler = function(service) {
        /**
         * Object to determine if legacy websockets are being used.
         * @type {Object}
         */
        this.isLegacy = false;

        /**
         * A reference to the service instance.
         * @type {EVWEB2.Service}
         */
        this.service = null;

        /**
         * The serializer to use when communicating with the service
         * @type {CompositeSerializer}
         */
        this.serializer = new EVWEB2.CompositeSerializer();

        var instance = this;

        /**
         * Pending subscription requests, indexed by request id
         * @private
         * @type {SubscribeRequest}
         */
        var pendingSubscribeRequests = {};

        /**
         * Active subscriptions, indexed by topic
         * @private
         * @type {EVWEB2.Subscription}
         */
        var activeSubscriptions = {};

        /**
         * Pending un-subscribe requests, indexed by request id
         * @private
         * @type {UnsubscribeRequest}
         */
        var pendingUnsubscribeRequests = {};

        /**
         * The WebSocket instance
         * @private
         * @type {WebSocket}
         */
        var sock = null;

        /**
         * The stored user callback to call when the websocket connection is open or timed out.
         * @private
         * @function
         */
        var onConnectionCallback = $.noop;

        /**
         * Flag indicating if we have already called the open callback so it isn't called twice
         * @type {boolean}
         */
        var onOpenCalled = false;

        /**
         * The current state of the websocket handler
         * @private
         * @type {wsStates}
         */
        var state = wsStates.initializing;

        /**
         * Cached websocket config
         * @type {EVWEB2.WebsocketConfig}
         */
        var wsConfig = null;

        /**
         * The slot time (discrete delay increments) to feed into exponential backoff algorithm
         * @type {number}
         */
        var reconnectSlotTime = 0.0125;

        /**
         * The number of reconnect attempts that have been made
         * @type {number}
         */
        var reconnectAttempts = 0;

        /**
         * constraint for the exponentiation term to give the desired max delay of ~10 seconds
         *
         * Follows the following formula
         *      (2^c-1)*reconnectSlotTime = DesiredMaxDelay
         *      c = ln((DesiredMaxDelay / reconnectSlotTime) + 1) / ln(2)
         *
         * NOTE: desired max delay expressed in ms for use with setTimeout
         * @private
         * @type {number}
         */
        var maxReconnectAttempts = 19.7;

        var timeoutHandle = null;
        /**
         * Boolean flag indicating if the set timeout was reached.
         * @type {Boolean}
         */
        var connectionTimeout = false;

        // Assign the values
        if(service !== undefined) {
            this.service = service;
        }

        /**
         * Re-subscribe/re-initialize the current set of subscriptions after a reconnect.
         */
        var resubscribe = function() {
            EVWEB2.log("Re-initializing currently active subscriptions");
            // clear active subscriptions
            var currentActive = $.extend(true, {}, activeSubscriptions);
            activeSubscriptions = {};

            // loop through active subscriptions and re-subscribe
            $.each(currentActive, function(topic, internalSubscription){
                $.each(internalSubscription.subscriptions, function(idx, subscription){
                    var requestId = generateId();
                    var onReply = $.Deferred();

                    // store the pending request
                    pendingSubscribeRequests[requestId] = new SubscribeRequest(requestId, subscription.server, topic,
                        internalSubscription.fn, subscription.externalCallback, onReply, true);

                    // send a subscribe protocol message to the server with the original subscription id
                    var header = new ProtocolHeader(requestId, topic, protocolMessageType.subscribe,
                        new ProtocolFlags(true, instance.serializer.isBinary));
                    var subscribeMsg = new SubscribeMessage(header, subscription.subscriptionId);
                    var payload = instance.serializer.serialize(subscribeMsg.marshal());

                    try {
                        sock.send(payload);
                    }catch(error){
                        EVWEB2.log("Error trying to resubscribe: " + error);
                        delete pendingSubscribeRequests[requestId];
                    }
                });
            });
        };

        /**
         * Callback for the 'onopen' event, fired when the websocket connection is established
         * @param {Event} e the websocket event
         * @private
         */
        var onOpen = function(e) {
            EVWEB2.log("WebsocketHandler::onOpen");

            if(!onOpenCalled){
                onConnectionCallback(EVWEB2.connectionEvent.open);
                onOpenCalled = true;
            }

            if(state === wsStates.reconnecting) {
                // reset
                reconnectAttempts = 0;
                resubscribe();
            }

            state = wsStates.connected;
        };

        /**
         * Callback for the 'onmessage' event, fired when the websocket receives a message
         * @param {Event} e the websocket event
         * @private
         */
        var onMessage = function(e) {
            var payload = e.data;
            var msg = instance.serializer.unserialize(payload);

            switch(msg.header.request) {
                case protocolMessageType.subscribed:
                    if(pendingSubscribeRequests[msg.header.rid] === undefined){
                        return;
                    }

                    var request = pendingSubscribeRequests[msg.header.rid];
                    delete pendingSubscribeRequests[msg.header.rid];

                    if (activeSubscriptions[msg.header.topic] === undefined) {
                        activeSubscriptions[msg.header.topic] = new InternalSubscription(request.internalCallback,
                                                                    msg.header.topic);
                    }

                    var subscription = new EVWEB2.Subscription(msg.payload.subscriptionId, request.server,
                                                            msg.header.topic, request.externalCallback);
                    activeSubscriptions[msg.header.topic].subscriptions.push(subscription);

                    // handle acknowledge
                    request.onReply.resolve(subscription);

                    break;
                case protocolMessageType.publish:
                    var internalSubscription = activeSubscriptions[msg.header.topic];

                    if (internalSubscription === undefined || internalSubscription.subscriptions.length === 0){
                        return;
                    }

                    internalSubscription.fn(internalSubscription.subscriptions, msg.payload.data);

                    break;
                case protocolMessageType.unsubscribed:
                    if(pendingUnsubscribeRequests[msg.header.rid] === undefined) {
                        return;
                    }

                    var unsubscribeRequest = pendingUnsubscribeRequests[msg.header.rid];
                    delete pendingUnsubscribeRequests[msg.header.rid];

                    unsubscribeRequest.subscription.isActive = false;
                    unsubscribeRequest.onAcknowledge.resolve(unsubscribeRequest.subscription);
                    break;
                default :
                    break;
            }

        };

        /**
         * Calculates the delay to use before attempting to reconnect
         * @returns {number} The calculated delay
         * @private
         */
        var calculateNextReconnectDelay = function() {
            // exponential backoff with max threshold
            // wait between [0, 2^c-1) slot times
            // first attempt 0 or 1 slots, second attempt 0-3 slots, etc
            var exponent = Math.min(reconnectAttempts, maxReconnectAttempts);
            var maxSlots = Math.pow(2, exponent) - 1;

            return Math.floor((Math.random() * maxSlots)) * reconnectSlotTime;
        };

        var onError = function(e) {
            // not used by sockjs
            EVWEB2.log("WebsocketHandler::onError: " + e.reason);
        };
		
		// Forward  declaring due to circular dependencies
		var onClose;
		
		/**
         * Initialize and bind a WebSocket connection
         * @private
         * @param {EVWEB2.WebsocketConfig} config The websocket configuration
         */
        var initSock = function(config) {
            var url = config.getUrl();
            EVWEB2.log("Initializing WebSocket: " + url);
            sock = new WebSocket(url);
            // bind the callbacks
            sock.onopen = onOpen;
            sock.onmessage = onMessage;
            sock.onclose = onClose;
            sock.onerror = onError;
            sock.binaryType = "arraybuffer";
        };
		
        /**
         * Callback for the 'onmclose' event, fired when the websocket connection is lost (or could not be established)
         * @param {Event} e the websocket event
         * @private
         */
        onClose = function(e) {
            EVWEB2.log("WebsocketHandler::onClose: reason=" + e.reason + ", code=" + e.code +
                ", wasClean=" + e.wasClean);

            // switch states and attempt reconnection with exponential backoff
            state = wsStates.reconnecting;

            if(connectionTimeout) {
                return;
            }

            var nextReconnectAttempt = calculateNextReconnectDelay();
            EVWEB2.log("Reconnect attempts: " + reconnectAttempts + ", reconnecting in " + nextReconnectAttempt);

            reconnectAttempts += 1;
            timeoutHandle = setTimeout(function() {
                initSock(wsConfig);
            }, nextReconnectAttempt);
        };

        /**
         * Retrieve the websocket configuration information
         * @param {Function} callback The callback function to call when the response completes. The callback is passed
         * an {@link EVWEB2.ResponseStatus} instance with the details of the response and (on success) an instance of
         * {@link EVWEB2.WebsocketConfig}.
         */
        this.getConfig = function(callback) {
            if(typeof callback !== 'function') {
                throw new Error('Callback required');
            }
            var websocket = this;

            var onGetConfigError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetConfigSuccess = function(data /*, textStatus, xhr*/){
                var successResponse = new EVWEB2.ResponseStatus(data.success, data.errorText);

                var hostUrl = websocket.service.hostUrl;
                if(hostUrl.substr(hostUrl.length - 1) !== "/"){
                    hostUrl = hostUrl.slice(0, hostUrl.length - 1);
                }
                var websocketConfig = new EVWEB2.WebsocketConfig(hostUrl, data.port, data.sslPort);

                callback(successResponse, websocketConfig);
            };

            var settings = {
                success: onGetConfigSuccess,
                error: onGetConfigError,
                url: websocket.service.url() + EVWEB2.urls.brokerConfig,
                data: {}
            };

            EVWEB2.ajax(settings, websocket.service);
        };

        var onConnectionTimeout = function() {
            if(sock !== undefined && sock.readyState === readyStates.connecting) {
                connectionTimeout = true;
                if(timeoutHandle !== null) {
                    clearTimeout(timeoutHandle);
                    timeoutHandle = null;
                }
                onConnectionCallback(EVWEB2.connectionEvent.timedOut);
            }
        };

        /**
         * This method initiates a websocket connection with the WebSocket server.
         * @param {Function} callback Callback function to be executed when the call completes.
         * @param {EVWEB2.WebsocketConfig} config The configuration information for the websocket connection
         * @param {Number} [timeout] Number of milliseconds to wait for websocket connection to be opened
         */
        this.init = function(callback, config, timeout) {
            if(typeof callback === 'function') {
                onConnectionCallback = callback;
            }
            if(timeout !== undefined) {
                setTimeout(onConnectionTimeout, timeout);
            }

            wsConfig = config;
            initSock(wsConfig);
        };

        /**
         * Subscribes to websocket messages and routes the event payload to the appropriate callbacks.
         * @param {EVWEB2.pubSubTopic} topic The topic to subscribe to.
         * @param {EVWEB2.Server} server The server associated with the subscription.
         * @param {Function} handler The callback responsible for handling events published to the given topic
         * @param {Object} [options] Additional available options.
         * @param {Array} [ids=[]] ids is an array of either EVWEB2 types or strings. The ids required by a topic
         * are documented as part of each {@link EVWEB2.pubSubTopic} topic.
         * @returns {Promise<EVWEB2.Subscription, EVWEB2.ResponseStatus>} A promise that returns the new subscription
         * instance to the caller when resolved, or an {@link EVWEB2.ResponseStatus} instance when rejected.
         */
        this.subscribe = function(topic, server, handler, options, ids) {
            var websocket = this;

            var onReply = $.Deferred();
            var response;
            if (sock === null){
                response = new EVWEB2.ResponseStatus(false,
                    "WebSocket support is not enabled.", EVWEB2.websocketErrorCodes.disabled);
                onReply.reject(response, topic, server, handler);
                return onReply.promise();
            }

            if (state === wsStates.reconnecting){
                response = new EVWEB2.ResponseStatus(false,
                    "Subscribe failed. Connection lost.", EVWEB2.websocketErrorCodes.connectionLost);
                onReply.reject(response, topic, server, handler);
                return onReply.promise();
            }

            if(topic === undefined) {
                response = new EVWEB2.ResponseStatus(false,
                        "Trying to subscribe to unknown EVWEB2.pubSubTopic: " + topic,
                        EVWEB2.websocketErrorCodes.unknownTopic);
                onReply.reject(response, topic, server, handler);
                return onReply.promise();
            }

            if (!server.isPassthroughServer() && !server.isLoggedIn()){
                response = new EVWEB2.ResponseStatus(false,
                    "Subscribe failed. Server login required.", EVWEB2.websocketErrorCodes.loginRequired);
                onReply.reject(response, topic, server, handler);
                return onReply.promise();
            }

            var topicName = topic.rawTopicStr;
            var internalCallback = internalCallbacks[topicName];
            
            // Convert to a protocol message
            var requestId = generateId();
            var sessionTopic = topicName + '.' + server.sessionId;
            if(ids !== undefined && ids.length > 0) {
                sessionTopic = formatTopic(topic, ids) + '.' + server.sessionId;
            }

            
            var acknowledge = false;
            if (options !== undefined) {
                acknowledge = options.acknowledge === undefined ? false : options.acknowledge;
            }

            // store the subscribe request
            pendingSubscribeRequests[requestId] = new SubscribeRequest(requestId, server, sessionTopic,
                internalCallback, handler, onReply, acknowledge);

            var flags = new ProtocolFlags(acknowledge, websocket.serializer.isBinary);
            var header = new ProtocolHeader(requestId, sessionTopic, protocolMessageType.subscribe, flags);
            var subscribeMsg = new SubscribeMessage(header);
            var payload = websocket.serializer.serialize(subscribeMsg.marshal());

            try {
                sock.send(payload);
            } catch(e){
                EVWEB2.log("subscribe failed: " + e.message);
                response = new EVWEB2.ResponseStatus(false,
                    "Subscribe failed. Unable to send server request.", EVWEB2.websocketErrorCodes.sendFailed);
                onReply.reject(response, topic, server, handler);
                return onReply.promise();
            }

            // return a deferred that will be resolved when the subscription is made
            return onReply.promise();
        };

        /**
         * This method is used to unsubscribe from an existing subscription.
         * @param {EVWEB2.Subscription} subscription An existing subscription instance
         * @param {Boolean} [acknowledge=true] A flag indicating if acknowledgement is requested when
         * the request completes
         * @returns {Promise<EVWEB2.Subscription, EVWEB2.ResponseStatus>} A promise that returns the subscription
         * instance (now inactive) back to the caller when resolved, or an {@link EVWEB2.ResponseStatus} instance
         * if rejected.
         */
        this.unsubscribe = function(subscription, acknowledge) {
            if(acknowledge === undefined) {
                acknowledge = true;
            }
            var onUnsubscribed = $.Deferred();

            var internalSubscription = activeSubscriptions[subscription.topic];
            var response;
            if (internalSubscription === undefined){
                response = new EVWEB2.ResponseStatus(false,
                    "unsubscribe failed, no active subscriptions found for topic: " + subscription.topic,
                    EVWEB2.websocketErrorCodes.unknownTopic);
                onUnsubscribed.reject(response);
                return onUnsubscribed.promise();
            }

            if (state === wsStates.reconnecting){
                response = new EVWEB2.ResponseStatus(false,
                    "unsubscribe failed, not connected", EVWEB2.websocketErrorCodes.connectionLost);
                onUnsubscribed.reject(response);
                return onUnsubscribed.promise();
            }


            var index = -1;

            var sub = $.grep(internalSubscription.subscriptions, function(elem, i){
               if(elem.subscriptionId === subscription.subscriptionId) {
                    index = i;
                    return true;
               }
            });

            if(sub.length === 0) {
                response = new EVWEB2.ResponseStatus(false,
                    "unsubscribe failed, unknown subscription ID: " + subscription.subscriptionId,
                    EVWEB2.websocketErrorCodes.unknownSubscription);
                onUnsubscribed.reject(response);
                return onUnsubscribed.promise();
            }

            // remove the subscription from the active subscriptions
            internalSubscription.subscriptions.splice(index, 1);

            if(internalSubscription.subscriptions.length === 0) {
                // last subscription to this topic, completely unsubscribe from the server
                var requestId = generateId();
                var flags = new ProtocolFlags(acknowledge, instance.serializer.isBinary);
                var header = new ProtocolHeader(requestId, internalSubscription.topic,
                    protocolMessageType.unsubscribe, flags);
                var unsubscribeMsg = new UnsubscribeMessage(header, subscription.subscriptionId);
                var payload = instance.serializer.serialize(unsubscribeMsg.marshal());

                try{
                    sock.send(payload);
                }catch(e){
                    EVWEB2.log("unsubscribe failed: " + e.message);
                    response = new EVWEB2.ResponseStatus(false,
                        "unsubscribe failed, unable to send server request", EVWEB2.websocketErrorCodes.sendFailed);
                    onUnsubscribed.reject(response);
                    return onUnsubscribed.promise();
                }

                delete activeSubscriptions[subscription.topic];

                pendingUnsubscribeRequests[requestId] = new UnsubscribeRequest(subscription, onUnsubscribed);
            }
            else {
                subscription.isActive = false;
                onUnsubscribed.resolve(subscription);
            }

            return onUnsubscribed.promise();
        };
    };
}());

/*globals EVWEB2:true, uuid:true*/
(function() {
    "use strict";

    /**
     * Definitions of all legacy handling functions.  Each function performs the traditional polling method
     * and formats the response into the web sockets response signature.
     * @internal
     */
    var legacyHandlers = {};
    legacyHandlers[EVWEB2.pubSubTopic.server.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, servers) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                // Set the cached data
                legacyHandlers[topic].data = servers;

                var targetServer = $.grep(servers, function (element) {
                    return element.id === subscription.server.id;
                })[0];

                if (targetServer === undefined) {
                    EVWEB2.log('Target server removed from list:', topic, response);
                }

                subscription.externalCallback(subscription, targetServer);
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                // Use the cached data for the response
                onCallback(new EVWEB2.ResponseStatus(true), legacyHandlers[topic].data);
                return;
            }
            subscription.server.service.getServers(onCallback);
        }
    };
    legacyHandlers[EVWEB2.pubSubTopic.serverStatus.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, status) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push(status);
                subscription.externalCallback(subscription, status.serverStatus);
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                // See if the cached data is available
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data);
                    return;
                }
            }
            if(!subscription.server.isLoggedIn() && !subscription.server.isPassthroughServer()) {
                // We'll just be making an empty request
                callback();
                return;
            }
            subscription.server.getServerStatus(onCallback);
        }
    };
    legacyHandlers[EVWEB2.pubSubTopic.devices.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, devices) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                // Update the devices' servers
                $.each(devices, function(index, element) {
                    element.server = subscription.server;
                });

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    devices: devices
                });

                subscription.externalCallback(subscription, devices);
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data.devices);
                    return;
                }
            }
            subscription.server.configuration.getDevicesConfiguration(onCallback);
        }
    };
    legacyHandlers[EVWEB2.pubSubTopic.cameraOsd.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, cameras) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                var osdInfos = $.map(cameras, function(element){
                    var osdInfo = EVWEB2.util.internal.formatOsdInfo(element.osdInfo);
                    return {
                        osdInfo: osdInfo,
                        cameraId: element.cameraId
                    };
                });

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    osdInfos: osdInfos
                });
                subscription.externalCallback(subscription, osdInfos);
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var cachedData = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (cachedData !== undefined) {
                    // Use the cached data for the response
                    subscription.externalCallback(subscription, cachedData.osdInfos);
                    callback();
                    return;
                }
            }

            var onGetCamerasOsdSuccess = function(data) {
                onCallback(new EVWEB2.ResponseStatus(true), data.camera);
            };

            var onGetCamerasOsdError = function(/*xhr, textStatus, errorThrown*/) {
                onCallback(new EVWEB2.ResponseStatus(false));
            };

            var params = {
                s: subscription.server.sessionId
            };
            var settings = {
                success: onGetCamerasOsdSuccess,
                error: onGetCamerasOsdError,
                url: subscription.server.service.url() + EVWEB2.urls.legacyWebsocketCamerasOsd,
                data: params,
                type: 'GET'
            };
            EVWEB2.ajax(settings, subscription.server.service);
        }
    };
    legacyHandlers[EVWEB2.pubSubTopic.users.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, users) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                // Update the users' servers
                $.each(users, function(index, element) {
                    element.server = subscription.server;
                });

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    users: users
                });

                subscription.externalCallback(subscription, users);
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data.users);
                    return;
                }
            }
            subscription.server.getUsers(onCallback);
        }
    };
    legacyHandlers[EVWEB2.pubSubTopic.userGroups.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, groups) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    groups: groups
                });

                subscription.externalCallback(subscription, groups);
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data.groups);
                    return;
                }
            }
            subscription.server.getUserGroups(onCallback);
        }
    };
    legacyHandlers[EVWEB2.pubSubTopic.cameras.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, cameras) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                // Update the cameras' servers
                $.each(cameras, function(index, element) {
                    element.server = subscription.server;
                });

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    cameras: cameras
                });

                subscription.externalCallback(subscription, cameras);
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data.cameras);
                    return;
                }
            }
            subscription.server.getCameras(onCallback);
        }
    };
    legacyHandlers[EVWEB2.pubSubTopic.activeUsers.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, usageInfo) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    usageInfo: usageInfo
                });
                subscription.externalCallback(subscription, usageInfo);
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data.usageInfo);
                    return;
                }
            }
            subscription.server.getSystemUsageInfo(onCallback);
        }
    };
    legacyHandlers[EVWEB2.pubSubTopic.triggers.rawTopicStr] = {
        data: [],
        store: [],
        fn: function (callback, subscription, topic/*, options, ids*/) {
            // Triggers expects updates of individual triggers that have changed state.
            // As such, store the entire trigger list and notify only on those that
            // have changed.
            var onCallback = function (response, newTriggers) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }
                var store = legacyHandlers[topic].store;
                var sourceTriggersStore = $.grep(store, function(element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if(sourceTriggersStore === undefined) {
                    sourceTriggersStore = {
                        server: subscription.server,
                        triggers: newTriggers
                    };
                    store.push(sourceTriggersStore);
                }

                var updatedTriggers = $.grep(newTriggers, function(element) {
                    var origTrigger = $.grep(sourceTriggersStore.triggers, function(el) {
                        return el.id === element.id;
                    })[0];
                    if(origTrigger === undefined || origTrigger.state !== element.state
                        || origTrigger.name !== element.name) {
                        return element;
                    }
                });
                sourceTriggersStore.triggers = newTriggers;

                $.each(updatedTriggers, function(index, element) {
                    subscription.externalCallback(subscription, element);
                });

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    triggers: updatedTriggers
                });
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (data !== undefined) {
                    // Use the cached data for the response
                    $.each(data.triggers, function(index, element) {
                        subscription.externalCallback(subscription, element);
                    });
                    callback();
                    return;
                }
            }
            EVWEB2.getTriggers(onCallback, subscription.server);
        }
    };

    legacyHandlers[EVWEB2.pubSubTopic.motion.rawTopicStr] = {
        data: [],
        store: [],
        fn: function (callback, subscription, topic/*, options, ids*/) {
            // Motion expects updates of individual cameras that have changed state.
            // As such, store the entire camera status list and notify only on those that
            // have changed.
            var onCallback = function (response, newCameras) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }
                var store = legacyHandlers[topic].store;
                var sourceCamerasStore = $.grep(store, function(element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if(sourceCamerasStore === undefined) {
                    sourceCamerasStore = {
                        server: subscription.server,
                        cameras: newCameras
                    };
                    store.push(sourceCamerasStore);
                }

                var updatedCameras = $.grep(newCameras, function(element) {
                    var origCamera = $.grep(sourceCamerasStore.cameras, function(el) {
                        return el.id === element.id;
                    })[0];
                    if(origCamera === undefined || origCamera.status.motion !== element.status.motion) {
                        return element;
                    }
                });
                sourceCamerasStore.cameras = newCameras;

                $.each(updatedCameras, function(index, element) {
                    subscription.externalCallback(subscription, element.id, element.status.motion);
                });

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    cameras: newCameras
                });

                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var cachedData = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (cachedData !== undefined) {
                    // Use the cached data for the response
                    $.each(cachedData.cameras, function(index, element) {
                        subscription.externalCallback(subscription, element.id, element.status.motion);
                    });
                    callback();
                    return;
                }
            }

            var onGetStatusSuccess = function(data) {
                onCallback(new EVWEB2.ResponseStatus(true), data.camera);
            };

            var onGetStatusError = function(/*xhr, textStatus, errorThrown*/) {
                onCallback(new EVWEB2.ResponseStatus(false));
            };

            var params = {
                s: subscription.server.sessionId
            };
            var settings = {
                success: onGetStatusSuccess,
                error: onGetStatusError,
                url: subscription.server.service.url() + EVWEB2.urls.legacyWebsocketStatus,
                data: params,
                type: 'GET'
            };
            EVWEB2.ajax(settings, subscription.server.service);
        }
    };

    legacyHandlers[EVWEB2.pubSubTopic.loss.rawTopicStr] = {
        data: [],
        store: [],
        fn: function (callback, subscription, topic/*, options, ids*/) {
            // Loss expects updates of individual cameras that have changed state.
            // As such, store the entire camera status list and notify only on those that
            // have changed.
            var onCallback = function (response, newCameras) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }
                var store = legacyHandlers[topic].store;
                var sourceCamerasStore = $.grep(store, function(element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if(sourceCamerasStore === undefined) {
                    sourceCamerasStore = {
                        server: subscription.server,
                        cameras: newCameras
                    };
                    store.push(sourceCamerasStore);
                }

                var updatedCameras = $.grep(newCameras, function(element) {
                    var origCamera = $.grep(sourceCamerasStore.cameras, function(el) {
                        return el.id === element.id;
                    })[0];
                    if(origCamera === undefined || origCamera.status.loss !== element.status.loss) {
                        return element;
                    }
                });
                sourceCamerasStore.cameras = newCameras;

                $.each(updatedCameras, function(index, element) {
                    subscription.externalCallback(subscription, element.id, element.status.loss);
                });

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    cameras: newCameras
                });

                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var cachedData = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (cachedData !== undefined) {
                    // Use the cached data for the response
                    $.each(cachedData.cameras, function(index, element) {
                        subscription.externalCallback(subscription, element.id, element.status.loss);
                    });
                    callback();
                    return;
                }
            }

            var onGetStatusSuccess = function(data) {
                onCallback(new EVWEB2.ResponseStatus(true), data.camera);
            };

            var onGetStatusError = function(/*xhr, textStatus, errorThrown*/) {
                onCallback(new EVWEB2.ResponseStatus(false));
            };

            var params = {
                s: subscription.server.sessionId
            };
            var settings = {
                success: onGetStatusSuccess,
                error: onGetStatusError,
                url: subscription.server.service.url() + EVWEB2.urls.legacyWebsocketStatus,
                data: params,
                type: 'GET'
            };
            EVWEB2.ajax(settings, subscription.server.service);
        }
    };

    legacyHandlers[EVWEB2.pubSubTopic.plugins.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, pluginsList) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    pluginsList: pluginsList
                });
                subscription.externalCallback(subscription, pluginsList);
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data.pluginsList);
                    return;
                }
            }
            subscription.server.getSystemPluginInfo(onCallback);
        }
    };

    legacyHandlers[EVWEB2.pubSubTopic.deviceConnection.rawTopicStr] = {
        data: [],
        store: [],
        fn: function (callback, subscription, topic/*, options, ids*/) {
            // deviceConnection expects updates of individual devices that have changed state.
            // As such, store the entire devices list and notify only on those that
            // have changed.
            var onCallback = function (response, newDevices) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                var store = legacyHandlers[topic].store;
                var sourceDevicesStore = $.grep(store, function(element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if(sourceDevicesStore === undefined) {
                    sourceDevicesStore = {
                        server: subscription.server,
                        devices: newDevices
                    };
                    store.push(sourceDevicesStore);
                }
                var updatedDevices = $.grep(newDevices, function(element) {
                    var origDevice = $.grep(sourceDevicesStore.devices, function(el) {
                        return el.id === element.id;
                    })[0];
                    if(origDevice === undefined || origDevice.connectionStatus !== element.connectionStatus) {
                        return element;
                    }
                });
                sourceDevicesStore.devices = newDevices;

                $.each(updatedDevices, function(index, element) {
                    subscription.externalCallback(subscription, element.id, element.connectionStatus);
                });

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    devices: updatedDevices
                });
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (data !== undefined) {
                    // Use the cached data for the response
                    $.each(data.devices, function(index, element) {
                        subscription.externalCallback(subscription, element.id, element.connectionStatus);
                    });
                    callback();
                    return;
                }
            }
            subscription.server.configuration.getDevicesConfiguration(onCallback);
        }
    };

    legacyHandlers[EVWEB2.pubSubTopic.cameraConnection.rawTopicStr] = {
        data: [],
        store: [],
        fn: function (callback, subscription, topic/*, options, ids*/) {
            // cameraConnection expects updates of individual devices that have changed state.
            // As such, store the entire devices list and notify only on those that
            // have changed.
            var onCallback = function (response, newCameras) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                var store = legacyHandlers[topic].store;
                var sourceCamerasStore = $.grep(store, function(element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if(sourceCamerasStore === undefined) {
                    sourceCamerasStore = {
                        server: subscription.server,
                        cameras: newCameras
                    };
                    store.push(sourceCamerasStore);
                }
                var updatedCameras = $.grep(newCameras, function(element) {
                    var origCamera = $.grep(sourceCamerasStore.cameras, function(el) {
                        return el.id === element.id;
                    })[0];
                    if(origCamera === undefined || origCamera.connectionStatus !== element.connectionStatus) {
                        return element;
                    }
                });
                sourceCamerasStore.cameras = newCameras;

                $.each(updatedCameras, function(index, element) {
                    subscription.externalCallback(subscription, element.id, element.connectionStatus);
                });

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    cameras: updatedCameras
                });
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];
                if (data !== undefined) {
                    // Use the cached data for the response
                    $.each(data.cameras, function(index, element) {
                        subscription.externalCallback(subscription, element.id, element.connectionStatus);
                    });
                    callback();
                    return;
                }
            }
            subscription.server.configuration.getDevicesConfiguration(onCallback);
        }
    };

    legacyHandlers[EVWEB2.pubSubTopic.avgFrameSize.rawTopicStr] = {
        fn: function (callback, subscription, topic, options, ids) {
            var camera = ids[0];

            var onCallback = function (response, frameSize) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();

                    return;
                }

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }
                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    cameraId: camera.id,
                    frameSize: frameSize
                });
                subscription.externalCallback(subscription, camera.id, frameSize);
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id && element.cameraId === camera.id;
                })[0];
                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data.frameSize, data.cameraId);
                    return;
                }
            }
            camera.config.getAverageFrameSize(onCallback);
        }
    };

    legacyHandlers[EVWEB2.pubSubTopic.securityIntegrationDevices.rawTopicStr] = {
        store: [],
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, devices) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                var store = legacyHandlers[topic].store;
                var deviceStore = $.grep(store, function(element) {
                    return element.server.id === subscription.server.id;
                })[0];

                if(deviceStore === undefined) {
                    deviceStore = {
                        server: subscription.server,
                        devices: devices
                    };
                    store.push(deviceStore);
                } else{
                    // update the device list
                    deviceStore.devices = devices;
                }

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }

                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    devices: devices
                });

                subscription.externalCallback(subscription, devices);
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];

                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data.devices);
                    return;
                }
            }
            subscription.server.getSecurityIntegrationsDevices(onCallback);
        }
    };

    legacyHandlers[EVWEB2.pubSubTopic.securityIntegrationSensors.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, sensors) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }

                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    sensors: sensors
                });

                if (sensors.length > 0){
                    var deviceId = sensors[0].device.id;
                    subscription.externalCallback(subscription, deviceId, sensors);
                }
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];

                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data.sensors);
                    return;
                }
            }

            var onGetDevices = function(response, devices){
                if (!response.success){
                    callback();
                    return;
                }

                $.each(devices, function(index, element) {
                    element.getSensors(onCallback);
                });
            };

            // attempt to use cached devices
            var deviceStore = $.grep(legacyHandlers[EVWEB2.pubSubTopic.securityIntegrationDevices.rawTopicStr].store,
                function(element){
                    return element.server.id === subscription.server.id;
                })[0];

            if (deviceStore === undefined){
                subscription.server.getSecurityIntegrationsDevices(onGetDevices);
            }else{
                var response = new EVWEB2.ResponseStatus(true);
                onGetDevices(response, deviceStore.devices);
            }
        }
    };

    legacyHandlers[EVWEB2.pubSubTopic.securityIntegrationSensorStatus.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, sensors) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }

                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    sensors: sensors
                });

                var statusObjects = $.map(sensors, function(obj){
                    return {
                        server: subscription.server,
                        deviceId: obj.device.id,
                        sensorId: obj.id,
                        status: obj.status,
                        alarm: obj.alarm,
                        statusMessage: obj.statusMessage,
                        statusTimestamp: EVWEB2.util.Date2IETF(obj.statusTimestamp)
                    };
                });

                // Call external callback with each statusObj
                $.each(statusObjects, function(index, element){
                    subscription.externalCallback(subscription, element);
                });

                callback();
            };

            // attempt to use cached data
            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];

                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data.sensors);
                    return;
                }
            }

            // make the request(s)
            var onGetDevices = function(response, devices){
                if (!response.success){
                    callback();
                    return;
                }

                $.each(devices, function(index, element) {
                    element.getSensors(onCallback);
                });
            };

            // attempt to use cached devices
            var deviceStore = $.grep(legacyHandlers[EVWEB2.pubSubTopic.securityIntegrationDevices.rawTopicStr].store,
                function(element){
                    return element.server.id === subscription.server.id;
                })[0];

            if (deviceStore === undefined){
                subscription.server.getSecurityIntegrationsDevices(onGetDevices);
            }else{
                var response = new EVWEB2.ResponseStatus(true);
                onGetDevices(response, deviceStore.devices);
            }

        }
    };

    legacyHandlers[EVWEB2.pubSubTopic.securityIntegrationDeviceConnection.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {
            var onCallback = function (response, devices) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }

                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    devices: devices
                });

                // Call external callback with each device connections status
                $.each(devices, function(index, element){
                    subscription.externalCallback(subscription, element.id, element.connectionStatus);
                });

                callback();
            };

            // attempt to use cached data
            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];

                if (data !== undefined) {
                    // Use the cached data for the response
                    onCallback(new EVWEB2.ResponseStatus(true), data.devices);
                    return;
                }
            }

            // attempt to use cached devices
            var deviceStore = $.grep(legacyHandlers[EVWEB2.pubSubTopic.securityIntegrationDevices.rawTopicStr].store,
                function(element){
                    return element.server.id === subscription.server.id;
                })[0];

            if (deviceStore === undefined){
                subscription.server.getSecurityIntegrationsDevices(onCallback);
            }else{
                var response = new EVWEB2.ResponseStatus(true);
                onCallback(response, deviceStore.devices);
            }
        }
    };
    legacyHandlers[EVWEB2.pubSubTopic.associations.rawTopicStr] = {
        fn: function (callback, subscription, topic/*, options, ids*/) {

            var triggerExternalCallback = function(associationsByCameraId){
                for(var key in associationsByCameraId){
                    if (associationsByCameraId.hasOwnProperty(key)) {
                        var cameraId = parseInt(key, 10);
                        subscription.externalCallback(subscription, cameraId, associationsByCameraId[cameraId]);
                    }
                }
            };

            var onCallback = function (response, associations) {
                if (!response.success) {
                    EVWEB2.log('Legacy subscription failed:', topic, response);
                    callback();
                    return;
                }

                var associationsByCameraId = {};
                $.each(associations, function(index, raw){
                    // Process the associations
                    var associationItems = $.map(raw.items, function(element) {
                        return new EVWEB2.AssociationItem(element.id, element.type, element.position,
                            element.statusOnly, element.extra);
                    });

                    var fontInfo = new EVWEB2.FontInfo(raw.fontName, raw.fontSize, raw.fontStyle,
                        raw.fontColor, raw.fontFamily, raw.fontWeight);

                    var association = new EVWEB2.Association(subscription.server, undefined, raw.guid, associationItems,
                        raw.label, raw.overlayStyle, raw.position, raw.backgroundColor,
                        raw.opacity, fontInfo);

                    associationsByCameraId[raw.cameraId] = association;
                });

                // Set the cached data
                if (legacyHandlers[topic].data === undefined) {
                    legacyHandlers[topic].data = [];
                }

                legacyHandlers[topic].data.push({
                    server: subscription.server,
                    associationsByCameraId: associationsByCameraId
                });

                triggerExternalCallback(associationsByCameraId);

                // call external callback
                callback();
            };

            if (legacyHandlers[topic].data !== undefined) {
                var data = $.grep(legacyHandlers[topic].data, function (element) {
                    return element.server.id === subscription.server.id;
                })[0];

                if (data !== undefined) {
                    // Use the cached data for the response
                    triggerExternalCallback(data.associationsByCameraId);
                    callback();
                    return;
                }
            }

            var onGetAssociationsSuccess = function(data) {
                onCallback(new EVWEB2.ResponseStatus(true), data.associations);
            };

            var onGetAssociationsError = function(/*xhr, textStatus, errorThrown*/) {
                onCallback(new EVWEB2.ResponseStatus(false));
            };

            // make request
            var params = {
                s: subscription.server.sessionId
            };
            var settings = {
                success: onGetAssociationsSuccess,
                error: onGetAssociationsError,
                url: subscription.server.service.url() + EVWEB2.urls.associations,
                data: params,
                type: 'GET'
            };
            EVWEB2.ajax(settings, subscription.server.service);
        }
    };

    /**
     * Helper method to replace the the topic string with the item ids.
     * @param {String} string The topic string.
     * @param {Array} args an array of item ids.
     * @returns {String} The topic string with the item IDs
     * @internal
     */
    var formatString = function(string, args) {
        var result = string;
        var i = args.length;

        while (i--) {
            result = result.replace(new RegExp('\\{' + i + '\\}', 'gm'), args[i]);
        }
        return result;
    };

    /**
     * Format the session Id topic with the item ids passed.
     * @param {String} topic The topic string.
     * @param {Array} ids An array of either EVWEB2 types or strings.
     * @returns {String} The session ID topic with item IDs
     * @internal
     */
    var formatTopic = function(topic, ids) {
        var formatStr = topic.rawTopicStr;
        var requiredTypes = topic.idTypes;
        var formattedIds = [];

        var instanceOfAny = function(obj, types) {
            for (var i=0; i < types.length; ++i){
                if (obj instanceof types[i]){
                    return true;
                }
            }
            return false;
        };

        var getId = function(obj){
            if (instanceOfAny(obj, [EVWEB2.Camera, EVWEB2.DeviceConfig, EVWEB2.Trigger])) {
                return obj.id;
            }
            // default case
            return obj.toString();
        };

        for(var i = 0; i < requiredTypes.length; ++i){
            formattedIds.push(getId(ids[i]));
        }

        return formatString(formatStr, formattedIds);
    };


    /**
     * The LegacyWebSocketHandler object mimics the behavior of {@link EVWEB2.WebSocketHandler}
     * using the traditional polling mechanisms found in the API.  It is loaded dynamically to override
     * the web socket implementation if the browser doesn't support web sockets or binary data parsing
     * functionality.
     * @param {EVWEB2.Service} [service=null] The service instance.
     * @class
     * @deprecated Web Socket functionality has been removed from the web API in 9.6.0.
     * @category Service
     */
    EVWEB2.LegacyWebSocketHandler = function (service) {
        /**
         * Object to determine if legacy websockets are being used.
         * @type {Object}
         */
        this.isLegacy = true;

        /**
         * A reference to the service instance.
         * @type {EVWEB2.Service}
         */
        this.service = null;

        /**
         * The interval for calling {@link legacyPoll}.
         * @type {Number|null}
         */
        var pollTimeout = null;

        /**
         * Interval duration (in ms) of the interval for calling {@link legacyPoll}.
         * @private
         * @type {number}
         */
        var pollTimeoutValue = 3000;

        /**
         * List of active subscriptions.
         * @private
         * @type {Array}
         */
        var subscriptions = [];

        // Assign the values
        if (service !== undefined) {
            this.service = service;
        }

        /**
         * Generate a unique random id for protocol requests
         * @private
         * @returns {String} Unique random ID
         */
        var generateId = function() {
            return uuid.v4();
        };

        /**
         * Calls the legacy handler function for each subscription.
         * @private
         */
        var legacyPoll = function () {
            // Reset any legacyHandlers data
            var topicStr;
            for (topicStr in legacyHandlers) {
                if (legacyHandlers.hasOwnProperty(topicStr) && legacyHandlers[topicStr].data !== undefined) {
                    delete legacyHandlers[topicStr].data;
                }
            }

            var index = 0;
            var onComplete = function () {
                var subscriptionInfo = subscriptions[index];
                if (subscriptionInfo === undefined) {
                    clearTimeout(pollTimeout);
                    // We're at the end of the chain
                    pollTimeout = setTimeout(legacyPoll, pollTimeoutValue);
                    return;
                }

                var subscription = subscriptionInfo.subscription;
                var targetHandler = legacyHandlers[subscriptionInfo.topic];
                index++;
                // Perform the subscription poll
                if (targetHandler === undefined) {
                    // Continue the execution chain
                    onComplete();
                }
                else {
                    targetHandler.fn(onComplete, subscription, subscriptionInfo.topic, subscriptionInfo.options,
                        subscriptionInfo.ids);
                }
            };

            // Start the subscription chain
            onComplete();
        };

        /**
         * Retrieve the websocket configuration information.
         * @param {Function} callback The callback function to call when the response completes. The callback is passed
         * an {@link EVWEB2.ResponseStatus} instance with the details of the response and (on success) an instance of
         * {@link EVWEB2.WebsocketConfig}.
         */
        this.getConfig = function (callback) {
            if (typeof callback !== 'function') {
                throw new Error('Callback required');
            }
            var websocket = this;

            var onGetConfigError = function (/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, 'An error occurred.');
                callback(errorResponse);
            };

            var onGetConfigSuccess = function (data /*, textStatus, xhr*/) {
                var successResponse = new EVWEB2.ResponseStatus(data.success, data.errorText);

                var hostUrl = websocket.service.hostUrl;
                if (hostUrl.substr(hostUrl.length - 1) !== "/") {
                    hostUrl = hostUrl.slice(0, hostUrl.length - 1);
                }
                var websocketConfig = new EVWEB2.WebsocketConfig(hostUrl, data.port);

                callback(successResponse, websocketConfig);
            };

            var settings = {
                success: onGetConfigSuccess,
                error: onGetConfigError,
                url: websocket.service.url() + EVWEB2.urls.brokerConfig,
                data: {}
            };

            EVWEB2.ajax(settings, websocket.service);
        };

        /**
         * This method initiates a websocket connection with the server.
         * @param {Function} callback Callback function to be executed when the call completes.
         * @param {EVWEB2.WebsocketConfig} config The configuration information for the websocket connection
         * @param {Number} timeout Number of milliseconds to wait for websocket connection to be opened
         */
        this.init = function (callback/*, config, timeout*/) {
            // Do nothing
            callback();
        };

        /**
         * Fakes subscribing to websocket messages by individually polling for content and routes the event payload
         * to the appropriate callbacks.
         * @private
         * @param {EVWEB2.pubSubTopic} topic The topic to subscribe to.
         * @param {EVWEB2.Server} server The server associated with the subscription.
         * @param {Function} handler The callback responsible for handling events published to the given topic
         * @param {Object} [options] Additional available options.
         * @param {Array} [ids=[]] ids is an array of either EVWEB2 types or strings. The ids required by a topic
         * are documented as part of each {@link EVWEB2.pubSubTopic} topic.
         * @returns {Promise<EVWEB2.Subscription, EVWEB2.ResponseStatus>} A promise that returns the new subscription
         * instance to the caller when resolved, or an {@link EVWEB2.ResponseStatus} instance when rejected.
         */
        this.subscribe = function (topic, server, handler, options, ids) {
            var onReply = $.Deferred();
            var response;

            if (topic === undefined) {
                response = new EVWEB2.ResponseStatus(false,
                    "Trying to subscribe to unknown EVWEB2.pubSubTopic: " + topic,
                    EVWEB2.websocketErrorCodes.unknownTopic);
                onReply.reject(response, topic, server, handler);
                return onReply.promise();
            }

            var subscriptionId = generateId();
            var topicName = topic.rawTopicStr;
            var sessionTopic = topicName + '.' + server.sessionId;
            if (ids !== undefined && ids.length > 0) {
                sessionTopic = formatTopic(topic, ids) + '.' + server.sessionId;
            }

            var subscription = new EVWEB2.Subscription(subscriptionId, server, sessionTopic, handler);

            // NOTE: There can be multiple subscriptions per topic in the poll chain which
            // is where cached data values come into play
            subscriptions.push({
                'subscription': subscription,
                'topic': topicName,
                'options': options,
                'ids': ids
            });
            if (pollTimeout === null) {
                pollTimeout = setTimeout(legacyPoll, pollTimeoutValue);
            }

            onReply.resolve(subscription);
            return onReply.promise();
        };

        /**
         * This method is used to unsubscribe from an existing subscription.
         * @param {EVWEB2.Subscription} subscription An existing subscription instance
         * @param {Boolean} [acknowledge=true] A flag indicating if acknowledgement is requested when
         * the request completes
         * @returns {Promise<EVWEB2.Subscription, EVWEB2.ResponseStatus>} A promise that returns the subscription
         * instance (now inactive) back to the caller when resolved, or an {@link EVWEB2.ResponseStatus} instance
         * if rejected.
         */
        this.unsubscribe = function (subscription/*, acknowledge*/) {
            var onUnsubscribed = $.Deferred();

            var internalSubscription = $.grep(subscriptions, function(element) {
                return element.subscription === subscription;
            })[0];
            var response;
            if (internalSubscription === undefined){
                response = new EVWEB2.ResponseStatus(false,
                    "unsubscribe failed, no active subscriptions found for topic: " + subscription.topic,
                    EVWEB2.websocketErrorCodes.unknownTopic);
                onUnsubscribed.reject(response);
                return onUnsubscribed.promise();
            }

            // Remove the subscription
            var index = $.inArray(internalSubscription, subscriptions);
            if(index !== -1) {
                subscriptions.splice(index, 1);
            }

            if(subscriptions.length === 0 && pollTimeout !== null) {
                clearTimeout(pollTimeout);
                pollTimeout = null;
            }

            onUnsubscribed.resolve(subscription);
            return onUnsubscribed.promise();
        };
    };
    if(window.WebSocket === undefined || window.DataView === undefined || window.ArrayBuffer === undefined) {
        // Override the existing web socket handler with the legacy version.
        EVWEB2.WebSocketHandler = EVWEB2.LegacyWebSocketHandler;
    }
}());

/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * The item types available to bookmark items.
     * @enum {number}
     * @readonly
     * @category Case Management
     */
    EVWEB2.bookmarkItemTypes = {
        /**
         * Camera
         */
        camera: 0,
        /**
         * Audio
         */
        audio: 1,
        /**
         * Serial
         */
        serial: 2,
        /**
         * Event
         */
        event: 3
    };

    /**
     * Container for bookmark item information.
     * @param {EVWEB2.Server} server The server associated with the item.
     * @param {Number} id The item ID
     * @param {EVWEB2.bookmarkItemTypes} type The type of the item.
     * @constructor
     * @category Case Management
     */
    EVWEB2.BookmarkItem = function(server, id, type) {
        /**
         * The server associated with the item.
         * @type {EVWEB2.Server}
         */
        this.server = server;

        /**
         * The item ID
         * @type {Number}
         */
        this.id = id;

        /**
         * The type of the item.
         * @type {EVWEB2.bookmarkItemTypes}
         */
        this.type = type;
    };

    /**
     * Container for bookmark information.
     * @param {String} name The bookmark name
     * @param {String} guid The unique bookmark id
     * @param {Date} start The start time of the bookmark.
     * @param {Date} end The end time of the bookmark.
     * @param {EVWEB2.BookmarkItem[]} items The items associated with the bookmark.
     * @param {String} [description=""] The case description
     * @param {Number} [size=0] The size of the bookmark, in KB.
     * @param {String} [caseId=null] The associated case ID, if applicable.
     * @constructor
     * @category Case Management
     */
    EVWEB2.Bookmark = function(name, guid, start, end, items, description, size, caseId) {
        /**
         * The bookmark name
         * @type {string}
         */
        this.name = name;

        /**
         * The unique bookmark id
         * @type {string}
         */
        this.guid = guid;

        /**
         * The start time of the bookmark
         * @type {Date}
         */
        this.start = start;

        /**
         * The end time of the bookmark
         * @type {Date}
         */
        this.end = end;

        /**
         * The items associated with the bookmark
         * @type {EVWEB2.BookmarkItem[]}
         */
        this.items = items;

        /**
         * The bookmark description
         * @type {string}
         */
        this.description = '';

        /**
         * The size of the bookmark in KB.
         * @type {Number}
         */
        this.size = 0;

        /**
         * The associated case ID, if applicable.
         * @type {String|null}
         */
        this.caseId = null;

        if (description !== undefined) {
            this.description = description;
        }
        if (size !== undefined) {
            this.size = size;
        }
        if (caseId !== undefined) {
            this.caseId = caseId;
        }

        /**
         * Updates a bookmark instance. NOTE: this function only updates base bookmark information (e.g. name,
         * description). To modify the items associated with a bookmark, see {@link EVWEB2.Bookmark.addItem} and
         * {@link EVWEB2.Bookmark.deleteItem}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback
         * is passed a {@link EVWEB2.ResponseStatus} instance and the updated bookmark.
         */
        this.update = function(callback) {
            var instance = this;

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                instance.name = data.bookmark.name;
                instance.description = data.bookmark.description;
                instance.start = EVWEB2.util.IETF2Date(data.bookmark.start);
                instance.end = EVWEB2.util.IETF2Date(data.bookmark.end);

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, instance);
            };

            var data = {
                s: $.map(instance.items, function(element) {
                    return element.server.sessionId;
                }),
                guid: instance.guid,
                name: instance.name,
                description: instance.description,
                start: EVWEB2.util.Date2IETF(instance.start),
                end: EVWEB2.util.Date2IETF(instance.end)
            };

            if(instance.caseId !== null) {
                data['case'] = instance.caseId;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.items[0].server.service.url() + EVWEB2.urls.bookmark,
                type: 'PUT',
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, instance.items[0].server.service);
        };

        /**
         * Delete a bookmark.
         * @param {Function} callback Callback function to be executed when the call completes. Callback
         * is passed a {@link EVWEB2.ResponseStatus} instance.
         */
        this.deleteBookmark = function(callback) {
            var instance = this;

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };

            var data = {
                s: $.map(instance.items, function(element) {
                    return element.server.sessionId;
                }),
                guid: instance.guid
            };

            if(instance.caseId !== null) {
                data['case'] = instance.caseId;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.items[0].server.service.url() + EVWEB2.urls.bookmark,
                type: 'DELETE',
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, instance.items[0].server.service);
        };

        /**
         * Adds an item to a bookmark.
         * @param {Function} callback Callback function to be executed when the call completes. Callback
         * is passed a {@link EVWEB2.ResponseStatus} instance and the updated bookmark.
         * @param {EVWEB2.BookmarkItem} bookmarkItem The bookmark item to add to the bookmark.
         */
        this.addItem = function(callback, bookmarkItem) {
            var instance = this;

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                instance.items.push(bookmarkItem);
                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, instance);
            };

            var data = {
                s: $.map(instance.items, function(element) {
                    return element.server.sessionId;
                }),
                guid: instance.guid,
                id: bookmarkItem.id,
                type: bookmarkItem.type,
                sessionId: bookmarkItem.server.sessionId
            };
            if(instance.caseId !== null) {
                data['case'] = instance.caseId;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: bookmarkItem.server.service.url() + EVWEB2.urls.bookmarkItems,
                type: 'POST',
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, bookmarkItem.server.service);
        };

        /**
         * Deletes an item from the bookmark.
         * @param {Function} callback Callback function to be executed when the call completes. Callback
         * is passed a {@link EVWEB2.ResponseStatus} instance and the updated bookmark.
         * @param {EVWEB2.BookmarkItem} bookmarkItem The bookmark item to add to the bookmark.
         */
        this.deleteItem = function(callback, bookmarkItem) {
            var instance = this;

            var internalItem = $.grep(instance.items, function(element) {
                return element.id === bookmarkItem.id
                    && element.type === bookmarkItem.type
                    && element.server === bookmarkItem.server;
            })[0];
            if(internalItem === undefined) {
                var errorResponse = new EVWEB2.ResponseStatus(false, "Item not removed from bookmark.");
                callback(errorResponse);
                return;
            }

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var index = $.inArray(internalItem, instance.items);
                if(index !== -1) {
                    instance.items.splice(index, 1);
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, instance);
            };

            var data = {
                s: internalItem.server.sessionId,
                guid: instance.guid,
                id: internalItem.id,
                type: internalItem.type
            };
            if(instance.caseId !== null) {
                data['case'] = instance.caseId;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: internalItem.server.service.url() + EVWEB2.urls.bookmarkItems,
                type: 'DELETE',
                data: data
            };

            EVWEB2.ajax(settings, internalItem.server.service);
        };

    };

    /**
     * Container for case information
     * @param {EVWEB2.Server[]} servers The server(s) the case is stored on
     * @param {String} guid The unique case id
     * @param {String} name The case name
     * @param {String} [description=""] The case description
     * @param {Number} [count=0] The number of bookmarks associated with the case
     * @constructor
     * @category Case Management
     */
    EVWEB2.Case = function(servers, guid, name, description, count) {
        /**
         * The server(s) the case is stored on
         * @type {EVWEB2.Server[]}
         */
        this.servers = servers;

        /**
         * The unique case id
         * @type {string}
         */
        this.guid = guid;

        /**
         * The case name
         * @type {string}
         */
        this.name = name;

        /**
         * The case description
         * @type {string}
         */
        this.description = '';

        /**
         * The number of bookmarks associated with the case
         * @type {number}
         */
        this.count = 0;

        if(description !== undefined) {
            this.description = description;
        }
        if(count !== undefined) {
            this.count = count;
        }

        /**
         * Update a case instance. NOTE: this function only updates case information (e.g. name, description).
         * To modify bookmarks associated with a case see {@link EVWEB2.Bookmark.update}.
         * @param {Function} callback Callback function to be executed when the call completes. Callback
         * is passed a {@link EVWEB2.ResponseStatus} instance and the updated case.
         */
        this.update = function(callback) {
            var instance = this;

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }
                var caseInfo = data['case'];
                instance.servers = $.grep(instance.servers, function(el) {
                    return $.inArray(el.sessionId.toString(), caseInfo.servers) !== -1;
                });
                instance.guid = caseInfo.guid;
                instance.name = caseInfo.name;
                instance.description = caseInfo.description;
                instance.count = caseInfo.bookmarks;

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, instance);
            };

            var data = {
                s: $.map(instance.servers, function(element) {
                    return element.sessionId;
                }),
                guid: instance.guid,
                name: instance.name,
                description: instance.description
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.servers[0].service.url() + EVWEB2.urls.bookmarkCases,
                type: 'PUT',
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, instance.servers[0].service);
        };

        /**
         * Deletes this case.
         * @param {Function} callback Callback function to be executed when the call completes. Callback
         * is passed a {@link EVWEB2.ResponseStatus} instance.
         */
        this.deleteCase = function(callback) {
            var instance = this;

            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse);
            };

            var data = {
                s: $.map(instance.servers, function(element) {
                    return element.sessionId;
                }),
                guid: instance.guid
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.servers[0].service.url() + EVWEB2.urls.bookmarkCases,
                type: 'DELETE',
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, instance.servers[0].service);
        };

        /**
         * Retreive the list of bookmarks for this case.  Note: The bookmarks retrieved through this method are also
         * returned by {@link EVWEB2.Service.getBookmarks}.  This method is provided only for convenience when working
         * with specific cases.
         * @param {Function} callback Callback function to be executed when the call completes. Callback
         * is passed a {@link EVWEB2.ResponseStatus} instance and an array of {@link EVWEB2.Bookmark} instances.
         */
        this.getBookmarks = function(callback) {
            var instance = this;
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr));
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var serverMap = {};
                $.each(instance.servers, function(index, element) {
                    serverMap[element.sessionId] = element;
                });

                var bookmarks = $.map(data.bookmarks, function(element) {
                    var items = $.map(element.items, function(el) {
                        return new EVWEB2.BookmarkItem(serverMap[el.server], el.id, el.type);
                    });
                    var start = EVWEB2.util.IETF2Date(element.start);
                    var end = EVWEB2.util.IETF2Date(element.end);

                    return new EVWEB2.Bookmark(element.name, element.guid, start, end, items, element.description,
                        element.size, element['case']);
                });

                var successResponse = new EVWEB2.ResponseStatus(true);
                callback(successResponse, bookmarks);
            };

            var data = {
                s: $.map(instance.servers, function(element) {
                    return element.sessionId;
                }),
                guid: instance.guid
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: instance.servers[0].service.url() + EVWEB2.urls.bookmark,
                type: 'GET',
                data: data,
                traditional: true
            };

            EVWEB2.ajax(settings, instance.servers[0].service);
        };
    };

}());
/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * Definitions for types of uses for serial ports.
     * @enum {number}
     * @readonly
     * @category Serial
     */
    EVWEB2.SerialPortUses = {
        /**
         * Unused
         */
        Unused: 0,
        /**
         * POS
         */
        POS: 1,
        /**
         * PTZ
         */
        PTZ: 2,
        /**
         * ATM
         */
        ATM: 3,
        /**
         * Access Control
         */
        AccessControl: 4,
        /**
         * Internal
         */
        Internal: 5
    };

    /**
     * Definitions for types of IP serial port connections.
     * @enum {number}
     * @readonly
     * @category Serial
     */
    EVWEB2.SerialIpTypes = {
        /**
         * TCP
         */
        TCP: 0,
        /**
         * HTTP
         */
        HTTP: 1,
        /**
         * TCP Listener
         */
        TcpListener: 2,
        /**
         * UDP
         */
        UDP: 3
    };

    /**
     * Definitions for types of parity for Uart serial ports.
     * @enum {number}
     * @readonly
     * @category Serial
     */
    EVWEB2.SerialPortParity = {
        /**
         * None
         */
        None: 0,
        /**
         * Odd
         */
        Odd: 1,
        /**
         * Even
         */
        Even: 2
    };

    /**
     * Definitions for types of flow control for Uart serial ports.
     * @enum {number}
     * @readonly
     * @category Serial
     */
    EVWEB2.SerialPortFlowControl = {
        /**
         * None
         */
        None: 0,
        /**
         * Software
         */
        Software: 1,
        /**
         * Hardware
         */
        Hardware: 2
    };

    /**
     * Definitions for types of serial devices.
     * @enum {number}
     * @readonly
     * @category Serial
     */
    EVWEB2.SerialDeviceTypes = {
        /**
         * Unknown
         */
        Unknown: 0,
        /**
         * UART
         */
        Uart: 1,
        /**
         * IP
         */
        Ip: 2
    };

    /**
     * Definitions for types of serial profile transmission markers.
     * @enum {number}
     * @readonly
     * @category Serial
     */
    EVWEB2.SerialProfileMarkerTypes = {
        /**
         * Standard
         */
        Standard: 0,
        /**
         * XML
         */
        XML: 1
    };


    /**
     * Definitions for field positions in serial profile rules.
     * @enum {number}
     * @readonly
     * @category Serial
     */
    EVWEB2.SerialProfileRuleFieldPositions = {
        /**
         * Before
         */
        Before: 0,
        /**
         * After
         */
        After: 1
    };

    /**
     * Definitions for the types of operators for serial profile rules.
     * @enum {number}
     * @readonly
     * @category Serial
     */
    EVWEB2.SerialProfileRuleOperatorTypes = {
        /**
         * Unknown
         */
        Unknown: 0,
        /**
         * Equal
         */
        Equal: 1,
        /**
         * Not equal
         */
        NotEqual: 2,
        /**
         * Greater than or equal
         */
        GreaterOrEqual: 3,
        /**
         * Less than or equal
         */
        LessOrEqual: 4,
        /**
         * Greater than
         */
        GreaterThan: 5,
        /**
         * Less than
         */
        LessThan: 6,
        /**
         * Contains
         */
        Contains: 7,
        /**
         * Does not contain
         */
        NotContains: 8
    };

    /**
     * Server serial supports information, detailing the supported functionality related to serial devices.
     * @param {Boolean} [advancedLineEnding=false] Whether the server supports advanced line endings.
     * @param {Boolean} [sotMarkers=false] Whether the server supports SOT markers.
     * @param {Boolean} [xmlFormatting=false] Whether the server supports XML formatting in transmission markers.
     * @param {Boolean} [replace=false] Whether the server supports replacements.
     * @param {Boolean} [rules=false] Whether the server supports rules.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.ServerSerialFunctionality = function(advancedLineEnding, sotMarkers, xmlFormatting, replace, rules) {

        /**
         * Whether the server supports advanced line endings.
         * @type {boolean}
         */
        this.advancedLineEnding = false;

        /**
         * Whether the server supports SOT markers.
         * @type {boolean}
         */
        this.sotMarkers = false;

        /**
         * Whether the server supports XML formatting in transmission markers.
         * @type {boolean}
         */
        this.xmlFormatting = false;

        /**
         * Whether the server supports replacements.
         * @type {boolean}
         */
        this.replace = false;

        /**
         * Whether the server supports rules.
         * @type {boolean}
         */
        this.rules = false;

        //Assign the constructor values
        if(advancedLineEnding !== undefined) {
            this.advancedLineEnding = advancedLineEnding;
        }
        if(sotMarkers !== undefined) {
            this.sotMarkers = sotMarkers;
        }
        if(xmlFormatting !== undefined) {
            this.xmlFormatting = xmlFormatting;
        }
        if(replace !== undefined) {
            this.replace = replace;
        }
        if(rules !== undefined) {
            this.rules = rules;
        }
    };

    /**
     * Server serial support information, detailing the available types, uses, and supported functionality
     * of serial ports on the server.
     * @param {EVWEB2.Server} server The server associated with this information.
     * @param {EVWEB2.ServerSerialFunctionality} supports The supported functionality of serial devices.
     * @param {Number} [numUart=0] The number of supported Uart serial devices.
     * @param {Number} [numIp=0] The number of supported IP serial devices.
     * @param {EVWEB2.SerialPortUses[]} [uses=[]] The supported uses of serial devices.
     * @param {EVWEB2.SerialIpTypes[]} [ipTypes=[]] The supported types of IP serial devices.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.ServerSerialSupport = function(server, supports, numUart, numIp, uses, ipTypes) {

        /**
         * The server associated with this information.
         * @type {EVWEB2.Server}
         */
        this.server = server;

        /**
         * The supported functionality of serial devices.
         * @type {EVWEB2.ServerSerialFunctionality}
         */
        this.supports = supports;

        /**
         * The number of supported Uart serial devices.
         * @type {number}
         */
        this.numUart = 0;

        /**
         * The number of supported IP serial devices.
         * @type {number}
         */
        this.numIp = 0;

        /**
         * The supported uses of serial devices.
         * @type {EVWEB2.SerialPortUses[]}
         */
        this.uses = [];

        /**
         * The supported uses of serial devices.
         * @type {EVWEB2.SerialIpTypes[]}
         */
        this.ipTypes = [];

        //Assign the constructor values
        if(numUart !== undefined) {
            this.numUart = numUart;
        }
        if(numIp !== undefined) {
            this.numIp = numIp;
        }
        if(uses !== undefined) {
            this.uses = uses;
        }
        if(ipTypes !== undefined) {
            this.ipTypes = ipTypes;
        }
    };

    /**
     * Container object for Uart serial device information.
     * @param {String} port The name of the server port for the serial device.
     * @param {Number} [baudRate=4800] The baud rate of the serial device.
     * @param {Number} [dataBits=8] The number of configured data bits for the serial device.
     * @param {Number} [stopBits=1] The number of configured stop bits for the serial device.
     * @param {EVWEB2.SerialPortParity} [parity=EVWEB2.SerialPortParity.None] The parity of the serial device.
     * @param {EVWEB2.SerialPortFlowControl} [flowControl=EVWEB2.SerialPortFlowControl.None] The flow control of the
     *   serial device.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.UartSerialDeviceConnectionInfo = function(port, baudRate, dataBits, stopBits, parity, flowControl) {
        /**
         * The name of the server port for the serial device.
         * @type {String}
         */
        this.port = port;

        /**
         * The baud rate of the serial device.
         * @type {Number}
         */
        this.baudRate = 4800;

        /**
         * The number of configured data bits for the serial device.
         * @type {Number}
         */
        this.dataBits = 8;

        /**
         * The number of configured stop bits for the serial device.
         * @type {Number}
         */
        this.stopBits = 1;

        /**
         * The parity of the serial device.
         * @type {EVWEB2.SerialPortParity}
         */
        this.parity = EVWEB2.SerialPortParity.None;

        /**
         * The flow control of the serial device.
         * @type {EVWEB2.SerialPortFlowControl}
         */
        this.flowControl = EVWEB2.SerialPortFlowControl.None;

        //Assign the constructor values
        if(baudRate !== undefined) {
            this.baudRate = baudRate;
        }
        if(dataBits !== undefined) {
            this.dataBits = dataBits;
        }
        if(stopBits !== undefined) {
            this.stopBits = stopBits;
        }
        if(parity !== undefined) {
            this.parity = parity;
        }
        if(flowControl !== undefined) {
            this.flowControl = flowControl;
        }
    };


    /**
     * Container object for Uart serial device information.
     * @param {String} address The IP address of the serial device.
     * @param {EVWEB2.SerialIpTypes} [type=EVWEB2.SerialIpTypes.TCP] The type of the serial device.
     * @param {Number} [ipPort=0] The IP port of the serial device.
     * @param {Number} [remotePort=] The remote port to use for the serial device.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.IpSerialDeviceConnectionInfo = function(address, type, ipPort, remotePort) {
        /**
         * The IP address of the serial device.
         * @type {String}
         */
        this.address = address;

        /**
         * The type of the serial device.
         * @type {EVWEB2.SerialIpTypes}
         */
        this.type = EVWEB2.SerialIpTypes.TCP;

        /**
         * The IP port of the serial device.
         * @type {Number}
         */
        this.ipPort = 0;

        /**
         * The remote port to use for the serial device.
         * @type {Number}
         */
        this.remotePort = 0;

        //Assign the constructor values
        if(type !== undefined) {
            this.type = type;
        }
        if(ipPort !== undefined) {
            this.ipPort = ipPort;
        }
        if(remotePort !== undefined) {
            this.remotePort = remotePort;
        }
    };

    /**
     * Container object for Uart serial device information.
     * @param {Number} [maxLineLength=80] The configured max line length of the serial device.
     * @param {String} [lineEnding=''] The token indicating a line end for the serial device.
     * @param {Number} [timeout=0] The timeout for the line ending, in seconds.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.SerialDeviceLineInfo = function(maxLineLength, lineEnding, timeout) {
        /**
         * The configured max line length of the serial device.
         * @type {number}
         */
        this.maxLineLength = 80;

        /**
         * The token indicating a line end for the serial device.
         * @type {string}
         */
        this.lineEnding = '';

        /**
         * The timeout for the line ending, in seconds.
         * @type {number}
         */
        this.timeout = 0;

        //Assign the constructor values
        if(maxLineLength !== undefined) {
            this.maxLineLength = maxLineLength;
        }
        if(lineEnding !== undefined) {
            this.lineEnding = lineEnding;
        }
        if(timeout !== undefined) {
            this.timeout = timeout;
        }
    };

    /**
     * Container object for stored serial data items.
     * @param {String} [data=''] The stored serial data.
     * @param {Date} [start=null] The start time of the serial data.
     * @param {Date} [end=null] The end time of the serial data.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.SerialStoredData = function(data, start, end) {
        /**
         * The stored serial data.
         * @type {String}
         */
        this.data = '';

        /**
         * The start time of the serial data.
         * @type {Date}
         */
        this.start = null;

        /**
         * The end time of the serial data.
         * @type {Date}
         */
        this.end = null;

        //Assign the constructor values
        if(data !== undefined) {
            this.data = data;
        }
        if(start !== undefined) {
            this.start = start;
        }
        if(end !== undefined) {
            this.end = end;
        }
    };

    /**
     * Container object for serial device information.
     * @param {EVWEB2.Server} server The server associated with this serial device.
     * @param {Number} id The ID of the serial device.
     * @param {String} name The name of the serial device.
     * @param {EVWEB2.UartSerialDeviceConnectionInfo|EVWEB2.IpSerialDeviceConnectionInfo} connectionInfo The connection
     *  info for the serial device.
     * @param {EVWEB2.SerialDeviceLineInfo} lineInfo The line processing information for the serial device.
     * @param {EVWEB2.SerialPortUses} [use=EVWEB2.SerialPortUses.Unused] The use of the serial device.
     * @param {EVWEB2.SerialDeviceTypes} [type=EVWEB2.SerialDeviceTypes.Unknown] The type of the serial device.
     * @param {Number|null} [profile=null] The ID of the serial profile associated with the serial device.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.SerialDevice = function(server, id, name, connectionInfo, lineInfo, use, type, profile) {
        /**
         * The server associated with this serial device.
         * @type {EVWEB2.Server}
         */
        this.server = server;

        /**
         * The ID of the serial device.
         * @type {Number}
         */
        this.id = id;

        /**
         * The name of the serial device.
         * @type {String}
         */
        this.name = name;

        /**
         * The connection info for the serial device.
         * @type {EVWEB2.UartSerialDeviceConnectionInfo|EVWEB2.IpSerialDeviceConnectionInfo}
         */
        this.connectionInfo = connectionInfo;

        /**
         * The line processing information for the serial device.
         * @type {EVWEB2.SerialDeviceLineInfo}
         */
        this.lineInfo = lineInfo;

        /**
         * The use of the serial device.
         * @type {EVWEB2.SerialPortUses}
         */
        this.use = EVWEB2.SerialPortUses.Unused;

        /**
         * The type of the serial device.
         * @type {EVWEB2.SerialDeviceTypes}
         */
        this.type = EVWEB2.SerialDeviceTypes.Unknown;

        /**
         * The ID of the serial profile associated with the serial device.
         * @type {Number|null}
         */
        this.profile = null;

        /**
         * The applied stream ID for this serial device.  This value is set by {@link EVWEB2.SerialDevice.getData},
         * either using the provided stream ID or a server-generated value received in the response.
         * @type {Number|null}
         * @internal
         * @private
         */
        var appliedStreamId = null;

        //Assign the constructor values
        if(use !== undefined) {
            this.use = use;
        }
        if(type !== undefined) {
            this.type = type;
        }
        if(profile !== undefined) {
            this.profile = profile;
        }

        /**
         * Retrieves stream data from a serial device.
         * @param {function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and a array of strings of any
         *  serial data.
         * @param {Number} [streamId] The unique stream ID for the feed.  If this is not provided, one will be
         * automatically generated.
         */
        this.getData = function(callback, streamId) {
            var device = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                if(appliedStreamId === null) {
                    appliedStreamId = data.stream;
                }

                callback(successResponse, data.data);
            };

            if(streamId !== undefined) {
                appliedStreamId = streamId;
            }

            var data = {
                s: device.server.sessionId,
                serial: device.id
            };

            if(appliedStreamId !== null) {
                data.stream = appliedStreamId;
            }

            var settings = {
                success: onSuccess,
                error: onError,
                url: device.server.service.url() + EVWEB2.urls.serialData,
                data: data
            };

            EVWEB2.ajax(settings, device.server.service);
        };

        /**
         * Retrieves stored data from a serial device.
         * @param {function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response, an array
         *  of {@link EVWEB2.SerialStoredData} instances, and a boolean indicating whether the search has
         *  finished retrieving all of the data.  If this value is false, then re-calling this method is
         *  recommended to ensure that all stored data is retrieved.
         * @param {Number} searchId The ID of the search associated with the stored serial data.
         * automatically generated.
         */
        this.getStoredData = function(callback, searchId) {
            var device = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                var storedData = $.map(data.stored, function(element) {
                    return new EVWEB2.SerialStoredData(element.data, EVWEB2.util.IETF2Date(element.start),
                        EVWEB2.util.IETF2Date(element.end));
                });

                callback(successResponse, storedData, data.complete);
            };

            var data = {
                s: searchId,
                serial: device.id
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: device.server.service.url() + EVWEB2.urls.serialStoredData,
                data: data
            };

            EVWEB2.ajax(settings, device.server.service);
        };

    };

    /**
     * Container object for serial profile case sensitivity settings.
     * @param {Boolean} [transmissionMarkers=false] Whether transmission markers are case sensitive.
     * @param {Boolean} [keywords=false] Whether keywords are case sensitive.
     * @param {Boolean} [masks=false] Whether masks are case sensitive.
     * @param {Boolean} [replacements=false] Whether replacements are case sensitive.
     * @param {Boolean} [rules=false] Whether rules are case sensitive.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.SerialCaseSensitivity = function(transmissionMarkers, keywords, masks, replacements, rules) {
        /**
         * Whether transmission markers are case sensitive.
         * @type {boolean}
         */
        this.transmissionMarkers = false;

        /**
         * Whether keywords are case sensitive.
         * @type {boolean}
         */
        this.keywords = false;

        /**
         * Whether masks are case sensitive.
         * @type {boolean}
         */
        this.masks = false;

        /**
         * Whether replacements are case sensitive.
         * @type {boolean}
         */
        this.replacements = false;

        /**
         * Whether rules are case sensitive.
         * @type {boolean}
         */
        this.rules = false;

        //Assign the constructor values
        if(transmissionMarkers !== undefined) {
            this.transmissionMarkers = transmissionMarkers;
        }
        if(keywords !== undefined) {
            this.keywords = keywords;
        }
        if(masks !== undefined) {
            this.masks = masks;
        }
        if(replacements !== undefined) {
            this.replacements = replacements;
        }
        if(rules !== undefined) {
            this.rules = rules;
        }
    };

    /**
     * Container object for serial profile transmission markers settings.
     * @param {EVWEB2.SerialProfileMarkerTypes} [type=EVWEB2.SerialProfileMarkerTypes.Standard] The type of the profile
     *  marker.
     * @param {String} [start=""] The start of transmission marker.
     * @param {String} [end=""] The end of transmission marker.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.SerialProfileMarkers = function(type, start, end) {
        /**
         * The type of the profile marker.
         * @type {EVWEB2.SerialProfileMarkerTypes}
         */
        this.type = EVWEB2.SerialProfileMarkerTypes.Standard;

        /**
         * The start of transmission marker.
         * @type {string}
         */
        this.start = '';

        /**
         * The end of transmission marker.
         * @type {string}
         */
        this.end = '';

        //Assign the constructor values
        if(type !== undefined) {
            this.type = type;
        }
        if(start !== undefined) {
            this.start = start;
        }
        if(end !== undefined) {
            this.end = end;
        }
    };

    /**
     * Container object for a serial profile keyword.
     * @param {EVWEB2.SerialProfile} profile The serial profile associated with this keyword.
     * @param {Number} id The ID of the serial profile keyword.
     * @param {String} [match=""] The match text of the keyword.
     * @param {Boolean} [enabled=false] Whether the keyword is enabled.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.SerialProfileKeyword = function(profile, id, match, enabled) {
        /**
         * The serial profile associated with this keyword.
         * @type {EVWEB2.SerialProfile}
         */
        this.profile = profile;

        /**
         * The ID of the serial profile keyword.
         * @type {Number}
         */
        this.id = id;

        /**
         * The match text of the keyword.
         * @type {string}
         */
        this.match = "";

        /**
         * Whether the keyword is enabled.
         * @type {boolean}
         */
        this.enabled = false;

        //Assign the constructor values
        if(match !== undefined) {
            this.match = match;
        }
        if(enabled !== undefined) {
            this.enabled = enabled;
        }
    };

    /**
     * Container object for a serial profile line mask.
     * @param {EVWEB2.SerialProfile} profile The serial profile associated with this line mask.
     * @param {String} [match=""] The match text of the mask.
     * @param {Boolean} [live=false] Whether the mask is enabled for live.
     * @param {Boolean} [search=false] Whether the mask is enabled for search.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.SerialProfileLineMask = function(profile, match, live, search) {
        /**
         * The serial profile associated with this line mask.
         * @type {EVWEB2.SerialProfile}
         */
        this.profile = profile;

        /**
         * The match text of the mask.
         * @type {string}
         */
        this.match = "";

        /**
         * Whether the mask is enabled for live.
         * @type {boolean}
         */
        this.live = false;

        /**
         * Whether the mask is enabled for search.
         * @type {boolean}
         */
        this.search = false;

        //Assign the constructor values
        if(match !== undefined) {
            this.match = match;
        }
        if(live !== undefined) {
            this.live = live;
        }
        if(search !== undefined) {
            this.search = search;
        }
    };

    /**
     * Container object for a serial profile replacement.
     * @param {EVWEB2.SerialProfile} profile The serial profile associated with this replacement.
     * @param {String} [match=""] The match text of the replacement.
     * @param {String} [replace=""] The replace text of the replacement.
     * @param {Boolean} [live=false] Whether the replacement is enabled for live.
     * @param {Boolean} [search=false] Whether the replacement is enabled for search.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.SerialProfileReplacement = function(profile, match, replace, live, search) {
        /**
         * The serial profile associated with this replacement.
         * @type {EVWEB2.SerialProfile}
         */
        this.profile = profile;

        /**
         * The match text of the replacement.
         * @type {string}
         */
        this.match = "";

        /**
         * The match text of the replacement.
         * @type {string}
         */
        this.replace = "";

        /**
         * Whether the replacement is enabled for live.
         * @type {boolean}
         */
        this.live = false;

        /**
         * Whether the replacement is enabled for search.
         * @type {boolean}
         */
        this.search = false;

        //Assign the constructor values
        if(match !== undefined) {
            this.match = match;
        }
        if(replace !== undefined) {
            this.replace = replace;
        }
        if(live !== undefined) {
            this.live = live;
        }
        if(search !== undefined) {
            this.search = search;
        }

    };

    /**
     * Container object for a serial profile rule.
     * @param {EVWEB2.SerialProfile} profile The serial profile associated with this rule.
     * @param {Number} id The ID of the serial profile rule.
     * @param {String} name The name of the rule.
     * @param {EVWEB2.SerialProfileRulePattern[]} [patterns=[]] The patterns defining the rule.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.SerialProfileRule = function(profile, id, name, patterns) {
        /**
         * The serial profile associated with this rule.
         * @type {EVWEB2.SerialProfile}
         */
        this.profile = profile;

        /**
         * The ID of the serial profile rule.
         * @type {Number}
         */
        this.id = id;

        /**
         * TThe name of the rule.
         * @type {string}
         */
        this.name = name;

        /**
         * The patterns defining the rule.
         * @type {EVWEB2.SerialProfileRulePattern[]}
         */
        this.patterns = [];

        //Assign the constructor values
        if(patterns !== undefined) {
            this.patterns = patterns;
        }
    };

    /**
     * Container object for a serial profile rule pattern.
     * @param {Number} id The ID of the rule pattern.
     * @param {EVWEB2.SerialProfileRuleFieldPositions} [position=EVWEB2.SerialProfileRuleFieldPositions.Before] The
     *  position of the field.
     * @param {String} [field=""] The field of the rule.
     * @param {EVWEB2.SerialProfileRuleOperatorTypes} [op=EVWEB2.SerialProfileRuleOperatorTypes.Equal] The operator of
     *  the rule.
     * @param {String} [value=""] The value of the rule
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.SerialProfileRulePattern = function(id, position, field, op, value) {
        /**
         * The ID of the rule pattern.
         * @type {Number}
         */
        this.id = id;

        /**
         * The position of the field.
         * @type {EVWEB2.SerialProfileRuleFieldPositions}
         */
        this.position = EVWEB2.SerialProfileRuleFieldPositions.Before;

        /**
         * The field of the rule.
         * @type {string}
         */
        this.field = "";

        /**
         * The operator of the rule.
         * @type {EVWEB2.SerialProfileRuleOperatorTypes}
         */
        this.op = EVWEB2.SerialProfileRuleOperatorTypes.Equal;

        /**
         * The value of the rule
         * @type {string}
         */
        this.value = "";

        //Assign the constructor values
        if(position !== undefined) {
            this.position = position;
        }
        if(field !== undefined) {
            this.field = field;
        }
        if(op !== undefined) {
            this.op = op;
        }
        if(value !== undefined) {
            this.value = value;
        }
    };

    /**
     * Container object for serial profile information.
     * @param {EVWEB2.Server} server The server associated with this serial profile.
     * @param {Number} id The ID of the serial profile.
     * @param {String} name The name of the serial profile.
     * @param {EVWEB2.FontInfo} fontInfo The font settings for the serial profile.
     * @param {EVWEB2.SerialCaseSensitivity} caseSensitivity The case sensitivity settings for the serial profile.
     * @param {EVWEB2.SerialProfileMarkers} markers The markers configuration for the serial profile.
     * @param {Number} [retention=87840] The retention period of the profile, in seconds.
     * @class
     * @constructor
     * @category Serial
     */
    EVWEB2.SerialProfile = function(server, id, name, fontInfo, caseSensitivity, markers, retention) {
        /**
         * The server associated with this serial profile.
         * @type {EVWEB2.Server}
         */
        this.server = server;

        /**
         * The ID of the serial profile.
         * @type {Number}
         */
        this.id = id;

        /**
         * The name of the serial profile.
         * @type {String}
         */
        this.name = name;

        /**
         * The font settings for the serial profile.
         * @type {EVWEB2.FontInfo}
         */
        this.fontInfo = fontInfo;

        /**
         * The case sensitivity settings for the serial profile.
         * @type {EVWEB2.SerialCaseSensitivity}
         */
        this.caseSensitivity = caseSensitivity;

        /**
         * The markers configuration for the serial profile.
         * @type {EVWEB2.SerialProfileMarkers}
         */
        this.markers = markers;

        /**
         * The retention period of the profile, in seconds.
         * @type {number}
         */
        this.retention = 87840;

        //Assign the constructor values
        if(retention !== undefined) {
            this.retention = retention;
        }

        /**
         * Retrieves information on the keywords configured for a profile.
         * @param {function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         *  {@link EVWEB2.SerialProfileKeyword} instances.
         */
        this.getKeywords = function(callback) {
            var profile = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                var keywords = $.map(data.keywords, function(element) {
                    return new EVWEB2.SerialProfileKeyword(profile, element.id, element.match, element.enabled);
                });

                callback(successResponse, keywords);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: profile.server.service.url() + EVWEB2.urls.serialProfileKeywords,
                data: {
                    s: profile.server.sessionId,
                    profile: profile.id
                }
            };

            EVWEB2.ajax(settings, profile.server.service);
        };

        /**
         * Retrieves information on the line masks configured for a profile.
         * @param {function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         *  {@link EVWEB2.SerialProfileLineMask} instances.
         */
        this.getLineMasks = function(callback) {
            var profile = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                var keywords = $.map(data.masks, function(element) {
                    return new EVWEB2.SerialProfileLineMask(profile, element.match, element.live, element.search);
                });

                callback(successResponse, keywords);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: profile.server.service.url() + EVWEB2.urls.serialProfileLineMasks,
                data: {
                    s: profile.server.sessionId,
                    profile: profile.id
                }
            };

            EVWEB2.ajax(settings, profile.server.service);
        };

        /**
         * Retrieves information on the replacements configured for a profile.
         * @param {function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         *  {@link EVWEB2.SerialProfileReplacement} instances.
         */
        this.getReplacements = function(callback) {
            var profile = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                var replacements = $.map(data.replacements, function(element) {
                    return new EVWEB2.SerialProfileReplacement(profile, element.match, element.replace,
                        element.live, element.search);
                });

                callback(successResponse, replacements);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: profile.server.service.url() + EVWEB2.urls.serialProfileReplacements,
                data: {
                    s: profile.server.sessionId,
                    profile: profile.id
                }
            };

            EVWEB2.ajax(settings, profile.server.service);
        };

        /**
         * Retrieves information on the rules configured for a profile.
         * @param {function} callback Function Callback function to be executed when the call completes. Callback is passed a
         *  {@link EVWEB2.ResponseStatus} instance with the details of the response and an array of
         *  {@link EVWEB2.SerialProfileRule} instances.
         */
        this.getRules = function(callback) {
            var profile = this;

            var onError = function(/*xhr, textStatus, errorThrown*/) {
                var errorResponse = new EVWEB2.ResponseStatus(false,'An error occurred.');
                callback(errorResponse);
            };

            var onSuccess = function(data/*, textStatus, xhr*/) {
                if(!data.success) {
                    //Send the error response
                    var errorResponse = new EVWEB2.ResponseStatus(false, data.errorText);
                    callback(errorResponse);
                    return;
                }

                var successResponse = new EVWEB2.ResponseStatus(true);

                var rules = $.map(data.rules, function(element) {
                    var patterns = $.map(element.patterns, function(el) {
                        return new EVWEB2.SerialProfileRulePattern(el.id, el.fieldPosition, el.field, el.op, el.value);
                    });
                    return new EVWEB2.SerialProfileRule(profile, element.id, element.name, patterns);
                });

                callback(successResponse, rules);
            };

            var settings = {
                success: onSuccess,
                error: onError,
                url: profile.server.service.url() + EVWEB2.urls.serialProfileRules,
                data: {
                    s: profile.server.sessionId,
                    profile: profile.id
                }
            };

            EVWEB2.ajax(settings, profile.server.service);
        };

    };

}());
/*globals EVWEB2:true*/

(function() {
    "use strict";

    /**
     * The types of events.
     * @enum {number}
     * @readonly
     * @category Events
     */
    EVWEB2.EventType = {
        /**
         * Unknown
         */
        unknown: 0,
        /**
         * Video Motion
         */
        videoMotion: 1,
        /**
         * Video Loss
         */
        videoLoss: 2,
        /**
         * Input Trigger
         */
        inputTrigger: 3,
        /**
         * Serial Port
         */
        serialPort: 4,
        /**
         * Serial Profile
         */
        serialProfile: 5,
        /**
         * Button Input
         */
        buttonInput: 6,
        /**
         * Device Failure
         */
        deviceFailure: 7,
        /**
         * Device Temperature
         */
        deviceTemperature: 8,
        /**
         * Device Fan
         */
        deviceFan: 9,
        /**
         * Device Power Supply
         */
        devicePowerSupply: 10,
        /**
         * Storage
         */
        storage: 11,
        /**
         * Subscription Expiration
         */
        subscriptionExpiration: 12,
        /**
         * Video Throttling
         */
        videoThrottling: 13,
        /**
         * System Voltage
         */
        systemVoltage: 14,
        /**
         * System Temperature
         */
        systemTemperature: 15,
        /**
         * System Fan
         */
        systemFan: 16,
        /**
         * Archive Connection
         */
        archiveConnection: 17,
        /**
         * Archive Task
         */
        archiveTask: 18,
        /**
         * Record Content Age
         */
        recordContentAge: 19,
        /**
         * Archive Content Age
         */
        archiveContentAge: 20,
        /**
         * IP Camera Connection
         */
        ipCameraConnection: 21,
        /**
         * Soft Trigger
         */
        softTrigger: 22,
        /**
         * Time Trigger
         */
        timeTrigger: 23,
        /**
         * Analytics
         */
        analytics: 24,
        /**
         * Outbound Connection
         */
        outboundConnection: 25,
        /**
         * Security Integration Connection
         */
        securityIntegrationConnection: 26,
        /**
         * Security Integration Alert
         */
        securityIntegrationAlert: 27,
        /**
         * Security Integration Alarm
         */
        securityIntegrationAlarm: 28,
        /**
         * Serial Port Connection
         */
        serialPortConnection: 29
    };

    /**
     * The types of items associated with events.
     * @enum {number}
     * @readonly
     * @category Events
     */
    EVWEB2.EventItemType = {
        /**
         * Unknown
         */
        unknown: 0,
        /**
         * Camera
         */
        camera: 1,
        /**
         * Audio
         */
        audio: 2,
        /**
         * Input Trigger
         */
        inputTrigger: 3,
        /**
         * Serial Keyword
         */
        serialKeyword: 4,
        /**
         * Serial Profile
         */
        serialProfile: 5,
        /**
         * Analytics Rule
         */
        analyticsRule: 6,
        /**
         * Security Integration Sensor
         */
        securityIntegrationSensor: 7
    };

    /**
     * The EventExtraInfo object represents an additional device information associated with an event.
     * @param {EVWEB2.Server} server The server associated with the event.
     * @param {Number} id The ID of the additional item associated with the event.
     * @param {EVWEB2.EventItemType} type The type of the additional item associated with the event.
     * @class
     * @category Events
     */
    EVWEB2.EventExtraInfo = function(server, id, type) {
        /**
         * The server associated with the event.
         * @type {EVWEB2.Server}
         */
        this.server = server;

        /**
         * The ID of the additional item associated with the event.
         * @type {Number}
         */
        this.id = id;

        /**
         * The type of the additional item associated with the event.
         * @type {EVWEB2.EventItemType}
         */
        this.type = type;

    };

    /**
     * The Event object represents an active event on the server.
     * @param {EVWEB2.Server} server The server associated with the event.
     * @param {EVWEB2.EventType} type The type of event.
     * @param {Date} time The time that the event was triggered.
     * @param {Number} [deviceId] Device ID of device associated with the event.
     * @param {EVWEB2.EventExtraInfo} [extraInfo] Extra information associated with the event.
     * @class
     * @category Events
     */
    EVWEB2.Event = function(server, type, time, deviceId, extraInfo) {
        /**
         * The server associated with the event.
         * @type {EVWEB2.Server}
         */
        this.server = server;

        /**
         * The type of event.
         * @type {EVWEB2.EventType}
         */
        this.type = type;

        /**
         * The time that the event was triggered.
         * @type {Date}
         */
        this.time = time;

        /**
         * Device ID of device associated with the event.
         * @type {Number|null}
         */
        this.deviceId = null;

        /**
         * Extra information associated with the event.
         * @type {EVWEB2.EventExtraInfo|null}
         */
        this.extraInfo = null;

        if(deviceId !== undefined) {
            this.deviceId = deviceId;
        }
        if(extraInfo !== undefined) {
            this.extraInfo = extraInfo;
        }
    };
}());

/*globals EVWEB2:true*/
(function() {
    "use strict";

    /**
     * The available types of archive targets.
     * @enum {Number}
     * @readonly
     * @category Archiving
     */
    EVWEB2.archiveTargetType = {
        /**
         * None
         */
        none: 0,
        /**
         * SMB
         */
        smb: 1,
        /**
         * NFS
         */
        nfs: 2,
        /**
         * iSCSI
         */
        iscsi: 3,
        /**
         * Cloud Drive (Legacy)
         */
        cloud: 4,
        /**
         * Amazon S3
         */
        aws_s3: 5,
        /**
         * Cloud Drive 2.0
         */
        cloud_drive_2: 6
    };

    /** 
     * The available methods for archive content expiration.
     * @enum {Number}
     * @readonly
     * @category Archiving
     */
    EVWEB2.archiveExpirationType = {
        /**
         * None
         */
        none: 0,
        /**
         * At least.  Note: This should never occur with an archive target.
         */
        atLeast: 1,
        /**
         * At most
         */
        atMost: 2
    };

    /**
     * The ArchiveTarget is a container for an nvr archive target.
     * @param {EVWEB2.Server} [server=null] The {@link EVWEB2.Server} instance associated with the archive target.
     * @param {Number} [id=0] The server-assigned identifier for the archive target.
     * @param {Boolean} [enabled=false] Whether the target is currently enabled.
     * @param {EVWEB2.archiveTargetType} [type=EVWEB2.archiveTargetType.none] The type of this target.
     * @param {EVWEB2.ArchiveUploadConfig} [upload=null] The uploading configuration for this target.
     * @param {EVWEB2.ArchiveSearchConfig} [search=null] The direct search configuration for this target.
     * @class
     * @category Archiving
     */
    EVWEB2.ArchiveTarget = function(server, id, enabled, type, upload, search) {

        /**
         * The {@link EVWEB2.Server} instance associated with the archive target.
         * @type {EVWEB2.Server}
         */
        this.server = server || null;

        /**
         * The server-assigned identifier for the archive target.
         * @type {Number}
         */
        this.id = id || 0;

        /**
         * Whether the target is currently enabled.
         * @type {Boolean}
         */
        this.enabled = enabled || false;

        /**
         * The type of this target.
         * @type {EVWEB2.archiveTargetType}
         */
        this.type = type || EVWEB2.archiveTargetType.none;

        /**
         * The uploading configuration for this target.
         * @type {EVWEB2.ArchiveUploadConfig|null}
         */
        this.upload = upload || null;

        /**
         * The direct search configuration for this target.
         * @type {EVWEB2.ArchiveSearchConfig}
         */
        this.search = search || null;
    };

    /**
     * ArchiveUploadConfig represents the upload configuration for an {@link EVWEB2.ArchiveTarget}. Note that targets
     * of the {@link EVWEB2.archiveTargetType.cloud} do not use most of these settings, as uploading for that kind of
     * archive is managed differently.
     * @param {String} [address] The address used to upload to the archive.
     * @param {Boolean} [hasBookmarks=false] Whether the archive supports bookmarking.
     * @param {Number} [percentToUse=0] The percent of archive disk space to use for storage. Cloud archives will always
     * use 100% of available disk space
     * @param {String} [username] The username used to upload to the archive.
     * @param {String} [password] The password used to upload to the archive.
     * @param {String} [mountPoint] The mount point of the archive on the nvr file system.
     * @param {Number} [desiredContentAge] The minimum desired amount of footage, in seconds, that the archive should
     * store. Storing less than this will cause the server to emit an alarm state.
     * @param {EVWEB2.archiveExpirationType} [expirationType=EVWEB2.archiveExpirationType.none] The type of content expiration
     * used to determine the lifetime of uploaded footage. Content on an archive is always stored up to an effective "maximum"
     * age, meaning that this value should always be {@link EVWEB2.archiveExpirationType.atMost}.
     * @param {Number} [expirationDuration] The amount of time, in seconds, that determines how content expires on the server,
     * used in tandem with the 'expirationType' property.
     * @class
     * @category Archiving
     */
    EVWEB2.ArchiveUploadConfig = function(address, hasBookmarks, percentToUse, username, password, mountPoint,
        desiredContentAge, expirationType, expirationDuration) {

        /**
         * The address used to upload to the archive.
         * @type {String}
         */
        this.address = address || '';

        /**
         * Whether the archive supports bookmarking.
         * @type {Boolean}
         */
        this.hasBookmarks = hasBookmarks || false;

        /**
         * The percent of archive disk space to use for storage. Cloud archives will always use 100%
         * of available disk space
         * @type {Number}
         */
        this.percentToUse = percentToUse || 0;

        /**
         * The username used to upload to the archive.
         * @type {String}
         */
        this.username = username;

        /**
         * The password used to upload to the archive.
         * @type {String}
         */
        this.password = password;

        /**
         * The mount point of the archive on the nvr file system.
         * @type {String}
         */
        this.mountPoint = mountPoint;

        /**
         * The minimum desired amount of footage, in seconds, that the archive should
         * store. Storing less than this will cause the server to emit an alarm state.
         * @type {Number}
         */
        this.desiredContentAge = desiredContentAge;

        /**
         * The type of content expiration used to determine the lifetime of uploaded footage. Content on
         * an archive is always stored up to an effective "maximum" age, meaning that this value should
         * always be {@link EVWEB2.archiveExpirationType.atMost}.
         * @type {EVWEB2.archiveExpirationType}
         */
        this.expirationType = expirationType || EVWEB2.archiveExpirationType.none;

        /**
         * The amount of time, in seconds, that determines how content expires on the server,
         * used in tandem with the 'expirationType' property.
         * @type {Number}
         */
        this.expirationDuration = expirationDuration;
    };

    /**
     * An ArchiveSearchConfig represents the configuration for direct search on an {@link EVWEB2.ArchiveTarget}.
     * @class
     * @param {Boolean} [enabled=false] Whether direct archive search is enabled for this target.
     * @param {String} [address=''] The address used to conduct direct search on this target.
     * @param {String} [username=''] The username used for direct search.
     * @param {String} [password=''] The password used for direct search.
     * @category Archiving
     */
    EVWEB2.ArchiveSearchConfig = function(enabled, address, username, password) {

        /**
         * Whether direct archive search is enabled for this target.
         * @type {Boolean}
         */
        this.enabled = enabled || false;

        /**
         * The address used to conduct direct search on this target.
         * @type {String}
         */
        this.address = address || '';

        /**
         * The username used for direct search.
         * @type {String}
         */
        this.username = username || '';

        /**
         * The password used for direct search.
         * @type {String}
         */
        this.password = password || '';
    };
}());

/*globals EVWEB2:true*/
(function() {
    'use strict';

    /**
     * The byte length of our injected frame header.
     * @type {Number}
     * @constant
     */
    var FRAME_HEAD_LENGTH = 29;

    /**
     * The byte length of the h624 sei rbsp, containing the payload of type sei_userdata_unregistered,
     * that we include with frames to provide metadata. This is effectively {@link FRAME_HEAD_LENGTH}
     * plus 16 bytes for the guid and 2 for the sei_userdata type/length.
     * @type {Number}
     * @constant
     */
    var SEI_RBSP_LENGTH = FRAME_HEAD_LENGTH + 18;

    /**
     * EVWEB2.VideoStream exposes a video frame stream.
     * An instance can be used for multiple start/stop calls across a single server session.
     * @param {String} url The endpoint location used to stream video.
     * @param {EVWEB2.cameraFormats} format The video format being used for this stream.
     * @constructor
     * @category Camera
     */
    EVWEB2.VideoStream = function(url, format) {
        /**
         * The endpoint location used to stream video.
         * @type {String}
         */
        this.url = url;

        /**
         * The video format being used for this stream. One of {@link EVWEB2.cameraFormats}.
         * @type {Number}
         */
        this.format = format;

        /**
         * The underlying websocket connection on which frames are received. Unused when streaming via legacy
         * polling.
         * @type {WebSocket}
         */
        this._conn = null;

        /**
         * A text decoder, used to read RFC timestamps from a frame payload.
         * @type {TextDecoder}
         */
        this._decoder = new TextDecoder();

        /**
         * Opens the video stream, wiring frame/error callbacks with provided functions.
         * @param {Function} onFrame Callback invoked when a frame is received. Callback is given an instance of
         * {@link EVWEB2.VideoFrame} from the stream.
         * @param {Function} onError. Callback invoked when a stream error is encountered. Callback is passed
         * no parameters.
         */
        this.start = function(onFrame, onError) {
            if (this._conn) {
                return;
            }

            this._conn = new WebSocket(this.url);
            this._conn.binaryType = 'arraybuffer';

            var self = this;
            this._conn.onmessage = function(message) {
                var data = new Uint8Array(message.data);
                var head;
                if (self.format === EVWEB2.cameraFormats.h264) {
                    // we don't need to slice the sei off of the buffer as decoders will skip over it
                    head = self._readSeiHead(data);
                } else {
                    head = self._readBinaryHead(data);
                    data = data.subarray(FRAME_HEAD_LENGTH);
                }

                onFrame(new EVWEB2.VideoFrame(head.time, head.flags, head.isIframe, data));
            };
            this._conn.onerror = onError;
            this._conn.onclose = onError;
        };

        /**
         * Closes the video stream. No further frames will be received once this message is called unless start()
         * is invoked again.
         */
        this.stop = function() {
            if (!this._conn) {
                return;
            }

            this._conn.onmessage = null;
            this._conn.onerror = null;
            this._conn.onclose = null;

            this._conn.close();
            this._conn = null;
        };

        /**
         * Parse h264 metadata, which comes in an SEI with sei_userdata_unregistered, out of a websocket message.
         * Since this has to be done on every frame, we take advantage of the fact that the web service
         * provides the unregistered userdata SEI at the beginning of the message.
         * @param {Uint8Array} data The websocket payload.
         * @return {{time: Date, flags: Number, isIframe: Boolean}} The frame metadata.
         * @private
         */
        this._readSeiHead = function(data) {
            // The rbsp will be of fixed length once prevention bytes are stripped.
            var rbsp = new Uint8Array(SEI_RBSP_LENGTH);

            // Grab the complete RBSP minus the emulation prevention bytes.
            // Skip the first startcode and the forbidden_zero/ref_idc/type byte.
            // see ITU-T H.264 7.3.1
            for (var i = 5, ri = 0; i < data.length; ++i, ++ri) {
                if (data[i] === 0x00 && data[i+1] === 0x00 && data[i+2] === 0x00 && data[i+3] === 0x01) {
                    break;
                }
                if (data[i] === 0x00 && data[i+1] === 0x00 && data[i+2] === 0x03) {
                    rbsp[ri] = data[i];
                    rbsp[ri+1] = data[i+1];
                    i += 2;
                    ++ri;
                } else {
                    rbsp[ri] = data[i];
                }
            }

            // The rbsp now contains the full sei_message with payload type user_data_unregistered.
            // The full layout is:
            //  0: [1 byte]    u8: sei payload type
            //  1: [1 byte]    u8: sei payload length
            //  2: [16 byte] uuid: our constant guid for these metadata payloads
            // 18: [24 byte]  str: RFC3339 timestamp
            // 42: [4 byte]   u32: frame flags
            // 30: [1 byte]  bool: idr flag
            var time = new Date(this._decoder.decode(rbsp.subarray(18, 42)));
            var flags = rbsp[42]<<24 | rbsp[43]<<16 | rbsp[44]<<8 | rbsp[45];
            var isIframe = rbsp[46] === 0x01;
            return {
                time: time,
                flags: flags,
                isIframe: isIframe,
            };
        };

        /**
         * Parse non-h264 metadata, which comes in as a binary structure, out of a websocket message.
         * @param {Uint8Array} data The websocket payload.
         * @return {{time: Date, flags: Number, isIframe: Boolean}} The frame metadata.
         * @private
         */
        this._readBinaryHead = function(data) {
            // The following offsets have what we need:
            //  0: [24 byte] str: RFC3339 timestamp
            // 24: [4 byte]  u32: frame flags
            // 28: [1 byte] bool: idr flag
            var time = new Date(this._decoder.decode(data.subarray(0, 24)));
            var flags = data[24]<<24 | data[25]<<16 | data[26]<<8 | data[27];
            var isIframe = data[28] === 0x01;
            return {
                time: time,
                flags: flags,
                isIframe: isIframe,
            };
        };
    };

    /**
     * EVWEB2.VideoFrame represents a single video frame emitted from our server.
     * @param {Date} time The frame time.
     * @param {Number} flags Bitset of frame flags.
     * @param {Boolean} isIframe Whether this frame is an independent (i-frame) data slice. Irrelevant for video sources
     * that do not use interframe compression.
     * @param {Uint8Array} data The frame payload.
     * @constructor
     * @category Camera
     */
    EVWEB2.VideoFrame = function(time, flags, isIframe, data) {
        /**
         * The frame time.
         * @type {Date}
         */
        this.time = time;

        /**
         * Bitset of frame flags.
         * @type {Number}
         */
        this.flags = flags;

        /**
         * Whether this frame is an independent (i-frame) data slice. Irrelevant for video sources
         * that do not use interframe compression.
         * @type {Boolean}
         */
        this.isIframe = isIframe;

        /**
         * The frame payload.
         * @type {Uint8Array}
         */
        this.data = data;
    };
}());

/*globals EVWEB2:true*/
(function() {
    'use strict';

    /**
     * Enumeration of associated source types for analytic rules.
     * @enum {Number}
     * @readonly
     * @category Analytics
     */
    EVWEB2.analyticRuleSourceType = {
        /**
         * Unknown (invalid)
         */
        unknown: 0,
        /**
         * Source is an associated camera
         */
        camera: 1,
        /**
         * Source is an associated audio device
         */
        audio: 2
    };

    /**
     * Points to a camera source associated with an analytic rule.
     * @param {Number} [id=0] The camera ID.
     * @class
     * @category Analytics
     */
    EVWEB2.AssociatedCameraSource = function(id) {
        /**
         * The camera ID.
         * @type {Number}
         */
        this.id = id;
    };

    /**
     * Points to an audio source associated with an analytic rule.
     * @param {Number} [id=0] The audio device ID.
     * @class
     * @category Analytics
     */
    EVWEB2.AssociatedAudioSource = function(id) {
        /**
         * The audio device ID.
         * @type {Number}
         */
        this.id = id;
    };

    /**
     * Defines an analytic rule configuration.
     * @param {EVWEB2.Server} [server=null] The server that hosts this rule.
     * @param {Number} [id=0] The rule ID.
     * @param {Number} [deviceId=0] The ID of the device to which this rule is attached.
     * @param {EVWEB2.AssociatedCameraSource|EVWEB2.AssociatedAudioSource} [sourceId=null] The identifier of the source
     * with which this rule is associated.
     * @param {String} [name=''] The name of this rule.
     * @param {EVWEB2.AnalyticRuleOSDConfig} [osdConfig=null] Rule OSD configuration, used when the rule presents
     * metadata for providing an analytic overlay over video.
     * @param {Boolean} [metadataEnabled=false] Whether metadata is enabled on this rule. If true, push notifications
     * for the rule will be dispatched with the metadata for the triggered event as part of the notification payload.
     * @param {EVWEB2.EventMetadataTemplate[]} [metadataTemplates=[]] The set of metadata fields that status
     * events for this rule may present.
     * @class
     * @category Analytics
     */
    EVWEB2.AnalyticRule = function(server, id, deviceId, sourceId, name, osdConfig, metadataEnabled,
        metadataTemplates) {
        /**
         * The server that hosts this rule.
         * @type {EVWEB2.Server}
         */
        this.server = server || null;

        /**
         * The rule ID.
         * @type {Number}
         */
        this.id = id || 0;

        /**
         * The ID of the IP device to which this rule is attached. This is not necessarily the source that emits the
         * data being tracked for analytic matches, see {@link EVWEB2.AnalyticRule#sourceId|this.sourceId} to determine
         * the nature of that association.
         * @type {Number}
         */
        this.deviceId = deviceId || 0;

        /**
         * The identifier of the source with which this rule is associated.
         * @type {EVWEB2.AssociatedCameraSource|EVWEB2.AssociatedAudioSource}
         */
        this.sourceId = sourceId || null;

        /**
         * The name of this rule.
         * @type {String}
         */
        this.name = name || '';

        /**
         * Rule OSD configuration, used when the rule presents metadata for drawing shapes over video.
         * @type {EVWEB2.AnalyticRuleOSDConfig}
         */
        this.osdConfig = osdConfig || null;

        /**
         * Whether metadata is enabled on this rule (presented on status events).
         * @type {Boolean}
         */
        this.metadataEnabled = metadataEnabled || false;

        /**
         * The set of metadata fields that status events for this rule may present.
         * @type {EVWEB2.EventMetadataTemplate[]}
         */
        this.metadataTemplates = metadataTemplates || [];
        
        /**
         * Callback invoked by
         * {@link EVWEB2.AnalyticRule#pushNotificationSubscribe|pushNotificationSubscribe()}.
         * @callback EVWEB2.AnalyticRule~onPushNotificationSubscribe
         * @param {EVWEB2.ResponseStatus} response Success state of the response.
         */
        /**
         * Register a client to receive push notifications for alarmed matches associated with this rule.
         * @param {EVWEB2.AnalyticRule~onPushNotificationSubscribe} callback Callback to be invoked on completion.
         * @param {String} clientId The client ID, generated in a previous call to
         * {@link EVWEB2.PushNotification#registerClient|EVWEB2.PushNotification.registerClient()}.
         */
        this.pushNotificationSubscribe = function(callback, clientId) {
            var onSuccess = function(data/*, textStatus, xhr*/) {
                callback(new EVWEB2.ResponseStatus(data.success));
            };
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                callback(new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr)));
            };

            EVWEB2.ajax({
                url: this.server.service.url() + EVWEB2.urls.analyticRulePush,
                type: 'POST',
                data: {
                    s: this.server.sessionId,
                    clientId: clientId,
                    deviceId: this.deviceId,
                    ruleId: this.id
                },
                success: onSuccess,
                error: onError
            }, this.server.service);
        };
        
        /**
         * Callback invoked by
         * {@link EVWEB2.AnalyticRule#pushNotificationUnsubscribe|pushNotificationUnsubscribe()}.
         * @callback EVWEB2.AnalyticRule~onPushNotificationUnsubscribe
         * @param {EVWEB2.ResponseStatus} response Success state of the response.
         */
        /**
         * Remove a client's registration for push notifications associated with this rule.
         * @param {EVWEB2.AnalyticRule~onPushNotificationUnsubscribe} callback Callback to be invoked on completion.
         * @param {String} clientId The client ID, generated in a previous call to
         * {@link EVWEB2.PushNotification#registerClient|EVWEB2.PushNotification.registerClient()}.
         */
        this.pushNotificationUnsubscribe = function(callback, clientId) {
            var onSuccess = function(data/*, textStatus, xhr*/) {
                callback(new EVWEB2.ResponseStatus(data.success));
            };
            var onError = function(xhr/*, textStatus, errorThrown*/) {
                callback(new EVWEB2.ResponseStatus(false, EVWEB2.util.getErrorText(xhr)));
            };

            EVWEB2.ajax({
                url: this.server.service.url() + EVWEB2.urls.analyticRulePush,
                type: 'DELETE',
                data: {
                    s: this.server.sessionId,
                    clientId: clientId,
                    deviceId: this.deviceId,
                    ruleId: this.id
                },
                success: onSuccess,
                error: onError
            }, this.server.service);
        };
    };

    /**
     * OSD configuration for an analytic rule that draws shapes over video.
     * @param {RGBA} [backgroundColor=[0,0,0,0]] The overlay background color.
     * @param {RGBA} [borderColor=[0,0,0,0]] The overlay border color.
     * @class
     * @category Analytics
     */
    EVWEB2.AnalyticRuleOSDConfig = function(backgroundColor, borderColor) {
        /**
         * The overlay background color.
         * @type {RGBA}
         */
        this.backgroundColor = backgroundColor || [0,0,0,0];

        /**
         * The overlay border color.
         * @type {RGBA}
         */
        this.borderColor = borderColor || [0,0,0,0];
    };
}());

/*globals EVWEB2:true*/
(function() {
    'use strict';

    /**
     * Enumeration of event metadata types.
     * @enum {Number}
     * @readonly
     * @category Events
     */
    EVWEB2.eventMetadataValueType = {
        /**
         * Unknown (invalid)
         */
        unknown: 0,
        /**
         * Numeric form
         */
        number: 1,
        /**
         * String form
         */
        string: 2,
        /**
         * Well-known textual representation of geometry (WKT) form,
         * as specified in ISO/IEC 13249-3:2016
         */
        wkt: 3
    };

    /**
     * Defines a metadata template (a key-value set that different status events may present).
     * Metadata that may be provided alongside analytic status events are as follows:
     * <pre>
     * * "ObjectId": {@link EVWEB2.eventMetadataValueType.string}
     * * "BoundingBox": {@link EVWEB2.eventMetadataValueType.wkt}
     * * "PersonKey": {@link EVWEB2.eventMetadataValueType.string}
     * </pre>
     * @param {String} [key=''] The key.
     * @param {EVWEB2.eventMetadataValueType} [valueType=EVWEB2.eventMetadataValueType.unknown] The type of value.
     * @class
     * @category Events
     */
    EVWEB2.EventMetadataTemplate = function(key, valueType) {
        /**
         * The key.
         * @type {String}
         */
        this.key = key || '';

        /**
         * The type of value.
         * @type {EVWEB2.eventMetadataValueType}
         */
        this.valueType = valueType || EVWEB2.eventMetadataValueType.unknown;
    };
}());
